(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@preact/signals'), require('preact/jsx-runtime'), require('preact/hooks'), require('preact'), require('preact/compat')) :
  typeof define === 'function' && define.amd ? define(['exports', '@preact/signals', 'preact/jsx-runtime', 'preact/hooks', 'preact', 'preact/compat'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.SXInteractiveEventModal = {}, global.preactSignals, global.jsxRuntime, global.preactHooks, global.preact, global.preactCompat));
})(this, (function (exports, signals, jsxRuntime, hooks, preact, compat) { 'use strict';

  const createInputField = (field) => {
      const reactiveInputField = signals.signal({
          ...field,
          rerender: () => (reactiveInputField.value = { ...reactiveInputField.value }),
      });
      return reactiveInputField;
  };

  /**
   * Origin of SVG: https://www.svgrepo.com/svg/506771/time
   * License: PD License
   * Author Salah Elimam
   * Author website: https://www.figma.com/@salahelimam
   * */
  function TimeIcon({ strokeColor }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("path", { d: "M12 8V12L15 15", stroke: strokeColor, "stroke-width": "2", "stroke-linecap": "round" }), jsxRuntime.jsx("circle", { cx: "12", cy: "12", r: "9", stroke: strokeColor, "stroke-width": "2" })] })] }) }));
  }

  /**
   * Origin of SVG: https://www.svgrepo.com/svg/506772/user
   * License: PD License
   * Author Salah Elimam
   * Author website: https://www.figma.com/@salahelimam
   * */
  function UserIcon({ strokeColor }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("path", { d: "M15 7C15 8.65685 13.6569 10 12 10C10.3431 10 9 8.65685 9 7C9 5.34315 10.3431 4 12 4C13.6569 4 15 5.34315 15 7Z", stroke: strokeColor, "stroke-width": "2" }), jsxRuntime.jsx("path", { d: "M5 19.5C5 15.9101 7.91015 13 11.5 13H12.5C16.0899 13 19 15.9101 19 19.5V20C19 20.5523 18.5523 21 18 21H6C5.44772 21 5 20.5523 5 20V19.5Z", stroke: strokeColor, "stroke-width": "2" })] })] }) }));
  }

  /**
   * Origin of SVG: https://www.svgrepo.com/svg/506838/list
   * License: PD License
   * Author: Salah Elimam
   * Author website: https://www.figma.com/@salahelimam
   * */
  function DescriptionIcon({ strokeColor }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("rect", { x: "4", y: "4", width: "16", height: "16", rx: "3", stroke: strokeColor, "stroke-width": "2" }), jsxRuntime.jsx("path", { d: "M16 10L8 10", stroke: strokeColor, "stroke-width": "2", "stroke-linecap": "round" }), jsxRuntime.jsx("path", { d: "M16 14L8 14", stroke: strokeColor, "stroke-width": "2", "stroke-linecap": "round" })] })] }) }));
  }

  /**
   * Origin of SVG: https://www.svgrepo.com/svg/489502/location-pin
   * License: PD License
   * Author: Dariush Habibpour
   * Author website: https://redl.ink/dariush/links?ref=svgrepo.com
   * */
  function LocationPinIcon({ strokeColor }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsxs("g", { "clip-path": "url(#clip0_429_11046)", children: [jsxRuntime.jsx("rect", { x: "12", y: "11", width: "0.01", height: "0.01", stroke: strokeColor, "stroke-width": "2", "stroke-linejoin": "round" }), jsxRuntime.jsx("path", { d: "M12 22L17.5 16.5C20.5376 13.4624 20.5376 8.53757 17.5 5.5C14.4624 2.46244 9.53757 2.46244 6.5 5.5C3.46244 8.53757 3.46244 13.4624 6.5 16.5L12 22Z", stroke: strokeColor, "stroke-width": "2", "stroke-linejoin": "round" })] }), jsxRuntime.jsx("defs", { children: jsxRuntime.jsx("clipPath", { id: "clip0_429_11046", children: jsxRuntime.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })] })] }) }));
  }

  const definePlugin = (name, definition) => {
      definition.name = name;
      return definition;
  };

  // regex for strings between 00:00 and 23:59
  const timeStringRegex = /^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
  const dateTimeStringRegex = /^(\d{4})-(\d{2})-(\d{2}) (0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
  const dateStringRegex = /^(\d{4})-(\d{2})-(\d{2})$/;

  const DateFormats$1 = {
      DATE_STRING: /^\d{4}-\d{2}-\d{2}$/,
      TIME_STRING: /^\d{2}:\d{2}$/,
      DATE_TIME_STRING: /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/,
  };

  let InvalidDateTimeError$1 = class InvalidDateTimeError extends Error {
      constructor(dateTimeSpecification) {
          super(`Invalid date time specification: ${dateTimeSpecification}`);
      }
  };

  const toJSDate$1 = (dateTimeSpecification) => {
      if (!DateFormats$1.DATE_TIME_STRING.test(dateTimeSpecification) &&
          !DateFormats$1.DATE_STRING.test(dateTimeSpecification))
          throw new InvalidDateTimeError$1(dateTimeSpecification);
      return new Date(Number(dateTimeSpecification.slice(0, 4)), Number(dateTimeSpecification.slice(5, 7)) - 1, Number(dateTimeSpecification.slice(8, 10)), Number(dateTimeSpecification.slice(11, 13)), // for date strings this will be 0
      Number(dateTimeSpecification.slice(14, 16)) // for date strings this will be 0
      );
  };
  const toIntegers$1 = (dateTimeSpecification) => {
      const hours = dateTimeSpecification.slice(11, 13), minutes = dateTimeSpecification.slice(14, 16);
      return {
          year: Number(dateTimeSpecification.slice(0, 4)),
          month: Number(dateTimeSpecification.slice(5, 7)) - 1,
          date: Number(dateTimeSpecification.slice(8, 10)),
          hours: hours !== '' ? Number(hours) : undefined,
          minutes: minutes !== '' ? Number(minutes) : undefined,
      };
  };

  let NumberRangeError$1 = class NumberRangeError extends Error {
      constructor(min, max) {
          super(`Number must be between ${min} and ${max}.`);
          Object.defineProperty(this, "min", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: min
          });
          Object.defineProperty(this, "max", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: max
          });
      }
  };

  const doubleDigit$1 = (number) => {
      if (number < 0 || number > 99)
          throw new NumberRangeError$1(0, 99);
      return String(number).padStart(2, '0');
  };

  const toDateString$2 = (date) => {
      return `${date.getFullYear()}-${doubleDigit$1(date.getMonth() + 1)}-${doubleDigit$1(date.getDate())}`;
  };
  const toTimeString$1 = (date) => {
      return `${doubleDigit$1(date.getHours())}:${doubleDigit$1(date.getMinutes())}`;
  };
  const toDateTimeString$2 = (date) => {
      return `${toDateString$2(date)} ${toTimeString$1(date)}`;
  };

  class InvalidTimeStringError extends Error {
      constructor(timeString) {
          super(`Invalid time string: ${timeString}`);
      }
  }

  const minuteTimePointMultiplier = 1.6666666666666667; // 100 / 60
  const timePointsFromString = (timeString) => {
      if (!timeStringRegex.test(timeString) && timeString !== '24:00')
          throw new InvalidTimeStringError(timeString);
      const [hoursInt, minutesInt] = timeString
          .split(':')
          .map((time) => parseInt(time, 10));
      let minutePoints = (minutesInt * minuteTimePointMultiplier).toString();
      if (minutePoints.split('.')[0].length < 2)
          minutePoints = `0${minutePoints}`;
      return Number(hoursInt + minutePoints);
  };

  const dateFromDateTime = (dateTime) => {
      return dateTime.slice(0, 10);
  };
  const timeFromDateTime = (dateTime) => {
      return dateTime.slice(11);
  };

  var WeekDay$1;
  (function (WeekDay) {
      WeekDay[WeekDay["SUNDAY"] = 0] = "SUNDAY";
      WeekDay[WeekDay["MONDAY"] = 1] = "MONDAY";
      WeekDay[WeekDay["TUESDAY"] = 2] = "TUESDAY";
      WeekDay[WeekDay["WEDNESDAY"] = 3] = "WEDNESDAY";
      WeekDay[WeekDay["THURSDAY"] = 4] = "THURSDAY";
      WeekDay[WeekDay["FRIDAY"] = 5] = "FRIDAY";
      WeekDay[WeekDay["SATURDAY"] = 6] = "SATURDAY";
  })(WeekDay$1 || (WeekDay$1 = {}));

  WeekDay$1.MONDAY;
  const DEFAULT_EVENT_COLOR_NAME = 'primary';

  class CalendarEventImpl {
      constructor(_config, id, start, end, title, people, location, description, calendarId, _options = undefined, _customContent = {}, _foreignProperties = {}) {
          Object.defineProperty(this, "_config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: _config
          });
          Object.defineProperty(this, "id", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: id
          });
          Object.defineProperty(this, "start", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: start
          });
          Object.defineProperty(this, "end", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: end
          });
          Object.defineProperty(this, "title", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: title
          });
          Object.defineProperty(this, "people", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: people
          });
          Object.defineProperty(this, "location", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: location
          });
          Object.defineProperty(this, "description", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: description
          });
          Object.defineProperty(this, "calendarId", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: calendarId
          });
          Object.defineProperty(this, "_options", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: _options
          });
          Object.defineProperty(this, "_customContent", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: _customContent
          });
          Object.defineProperty(this, "_foreignProperties", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: _foreignProperties
          });
          Object.defineProperty(this, "_previousConcurrentEvents", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "_totalConcurrentEvents", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "_nDaysInGrid", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "_eventFragments", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: {}
          });
      }
      get _isSingleDayTimed() {
          return (dateTimeStringRegex.test(this.start) &&
              dateTimeStringRegex.test(this.end) &&
              dateFromDateTime(this.start) === dateFromDateTime(this.end));
      }
      get _isSingleDayFullDay() {
          return (dateStringRegex.test(this.start) &&
              dateStringRegex.test(this.end) &&
              this.start === this.end);
      }
      get _isMultiDayTimed() {
          return (dateTimeStringRegex.test(this.start) &&
              dateTimeStringRegex.test(this.end) &&
              dateFromDateTime(this.start) !== dateFromDateTime(this.end));
      }
      get _isMultiDayFullDay() {
          return (dateStringRegex.test(this.start) &&
              dateStringRegex.test(this.end) &&
              this.start !== this.end);
      }
      get _isSingleHybridDayTimed() {
          if (!this._config.isHybridDay)
              return false;
          if (!dateTimeStringRegex.test(this.start) ||
              !dateTimeStringRegex.test(this.end))
              return false;
          const startDate = dateFromDateTime(this.start);
          const endDate = dateFromDateTime(this.end);
          const endDateMinusOneDay = toDateString$2(new Date(toJSDate$1(endDate).getTime() - 86400000));
          if (startDate !== endDate && startDate !== endDateMinusOneDay)
              return false;
          const dayBoundaries = this._config.dayBoundaries.value;
          const eventStartTimePoints = timePointsFromString(timeFromDateTime(this.start));
          const eventEndTimePoints = timePointsFromString(timeFromDateTime(this.end));
          return ((eventStartTimePoints >= dayBoundaries.start &&
              (eventEndTimePoints <= dayBoundaries.end ||
                  eventEndTimePoints > eventStartTimePoints)) ||
              (eventStartTimePoints < dayBoundaries.end &&
                  eventEndTimePoints <= dayBoundaries.end));
      }
      get _color() {
          if (this.calendarId &&
              this._config.calendars.value &&
              this.calendarId in this._config.calendars.value) {
              return this._config.calendars.value[this.calendarId].colorName;
          }
          return DEFAULT_EVENT_COLOR_NAME;
      }
      _getForeignProperties() {
          return this._foreignProperties;
      }
      _getExternalEvent() {
          return {
              id: this.id,
              start: this.start,
              end: this.end,
              title: this.title,
              people: this.people,
              location: this.location,
              description: this.description,
              calendarId: this.calendarId,
              _options: this._options,
              ...this._getForeignProperties(),
          };
      }
  }

  class CalendarEventBuilder {
      constructor(_config, id, start, end) {
          Object.defineProperty(this, "_config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: _config
          });
          Object.defineProperty(this, "id", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: id
          });
          Object.defineProperty(this, "start", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: start
          });
          Object.defineProperty(this, "end", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: end
          });
          Object.defineProperty(this, "people", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "location", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "description", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "title", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "calendarId", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "_foreignProperties", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: {}
          });
          Object.defineProperty(this, "_options", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: undefined
          });
          Object.defineProperty(this, "_customContent", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: {}
          });
      }
      build() {
          return new CalendarEventImpl(this._config, this.id, this.start, this.end, this.title, this.people, this.location, this.description, this.calendarId, this._options, this._customContent, this._foreignProperties);
      }
      withTitle(title) {
          this.title = title;
          return this;
      }
      withPeople(people) {
          this.people = people;
          return this;
      }
      withLocation(location) {
          this.location = location;
          return this;
      }
      withDescription(description) {
          this.description = description;
          return this;
      }
      withForeignProperties(foreignProperties) {
          this._foreignProperties = foreignProperties;
          return this;
      }
      withCalendarId(calendarId) {
          this.calendarId = calendarId;
          return this;
      }
      withOptions(options) {
          this._options = options;
          return this;
      }
      withCustomContent(customContent) {
          this._customContent = customContent;
          return this;
      }
  }

  const deepCloneEvent = (calendarEvent, $app) => {
      const calendarEventInternal = new CalendarEventBuilder($app.config, calendarEvent.id, calendarEvent.start, calendarEvent.end)
          .withTitle(calendarEvent.title)
          .withPeople(calendarEvent.people)
          .withCalendarId(calendarEvent.calendarId)
          .withForeignProperties(JSON.parse(JSON.stringify(calendarEvent._getForeignProperties())))
          .withLocation(calendarEvent.location)
          .withDescription(calendarEvent.description)
          .withOptions(calendarEvent._options)
          .withCustomContent(calendarEvent._customContent)
          .build();
      calendarEventInternal._nDaysInGrid = calendarEvent._nDaysInGrid;
      return calendarEventInternal;
  };

  const concatenatePeople = (people) => {
      return people.reduce((acc, person, index) => {
          if (index === 0)
              return person;
          if (index === people.length - 1)
              return `${acc} & ${person}`;
          return `${acc}, ${person}`;
      }, '');
  };

  const dateFn$1 = (dateTimeString, locale) => {
      const { year, month, date } = toIntegers$1(dateTimeString);
      return new Date(year, month, date).toLocaleDateString(locale, {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
      });
  };
  const timeFn = (dateTimeString, locale) => {
      const { year, month, date, hours, minutes } = toIntegers$1(dateTimeString);
      return new Date(year, month, date, hours, minutes).toLocaleTimeString(locale, {
          hour: 'numeric',
          minute: 'numeric',
      });
  };
  const getTimeStamp = (calendarEvent, // to facilitate testing. In reality, we will always have a full CalendarEventInternal
  locale, delimiter = '\u2013') => {
      const eventTime = { start: calendarEvent.start, end: calendarEvent.end };
      if (calendarEvent._isSingleDayFullDay) {
          return dateFn$1(eventTime.start, locale);
      }
      if (calendarEvent._isMultiDayFullDay) {
          return `${dateFn$1(eventTime.start, locale)} ${delimiter} ${dateFn$1(eventTime.end, locale)}`;
      }
      if (calendarEvent._isSingleDayTimed && eventTime.start !== eventTime.end) {
          return `${dateFn$1(eventTime.start, locale)} <span aria-hidden="true">⋅</span> ${timeFn(eventTime.start, locale)} ${delimiter} ${timeFn(eventTime.end, locale)}`;
      }
      if (calendarEvent._isSingleDayTimed &&
          calendarEvent.start === calendarEvent.end) {
          return `${dateFn$1(eventTime.start, locale)}, ${timeFn(eventTime.start, locale)}`;
      }
      return `${dateFn$1(eventTime.start, locale)}, ${timeFn(eventTime.start, locale)} ${delimiter} ${dateFn$1(eventTime.end, locale)}, ${timeFn(eventTime.end, locale)}`;
  };

  /**
   * Can be used for generating a random id for an entity
   * Should, however, never be used in potentially resource intense loops,
   * since the performance cost of this compared to new Date().getTime() is ca x4 in v8
   * */
  const randomStringId$2 = () => 's' + Math.random().toString(36).substring(2, 11);
  const addMinutes = (to, nMinutes) => {
      const { year, month, date, hours, minutes } = toIntegers$1(to);
      const isDateTimeString = hours !== undefined && minutes !== undefined;
      const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
      jsDate.setMinutes(jsDate.getMinutes() + nMinutes);
      if (isDateTimeString) {
          return toDateTimeString$2(jsDate);
      }
      return toDateString$2(jsDate);
  };

  const createClickOutsideListener = ($app, modalId, withCallback) => {
      return function (e) {
          if (!(e.target instanceof HTMLElement))
              return;
          if (e.target.closest(`#${modalId}`))
              return;
          if (e.target.closest('.sx__interactive-event-modal__header'))
              return;
          if (e.target.closest('.sx__date-picker-popup'))
              return;
          if (e.target.closest('.sx__time-picker-popup'))
              return;
          if (e.target.closest('.sx__modal-delete-actions'))
              return;
          if (e.target.closest('.sx__event-form'))
              return;
          if (e.target.closest('.sx__app-combobox__list'))
              return;
          if (e.target.closest('.sx__app-select__list'))
              return;
          $app.config.plugins.eventModal.close();
          withCallback();
      };
  };

  const setPosition = (appDOMRect, eventDOMRect, modalHeight = 600, modalWidth = 540) => {
      eventDOMRect || (eventDOMRect = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          height: 0,
          width: 0,
          x: 0,
          y: 0,
          toJSON() { },
      });
      const MODAL_WIDTH = modalWidth;
      const INLINE_SPACE_BETWEEN_MODAL_AND_EVENT = 10;
      const WIDTH_NEEDED = MODAL_WIDTH + INLINE_SPACE_BETWEEN_MODAL_AND_EVENT;
      const hasSpaceTop = eventDOMRect.bottom - appDOMRect.top > modalHeight;
      const eventBottomLessThanAppBottom = eventDOMRect.bottom < appDOMRect.bottom;
      const eventTopLessThanAppTop = eventDOMRect.top < appDOMRect.top;
      let top = 0;
      let left = 0;
      let animationStart = '0%';
      if (appDOMRect.bottom - eventDOMRect.top > modalHeight &&
          !eventTopLessThanAppTop) {
          top = eventDOMRect.top;
      }
      else if (hasSpaceTop && eventBottomLessThanAppBottom) {
          top = eventDOMRect.bottom - modalHeight;
      }
      else if (hasSpaceTop && !eventBottomLessThanAppBottom) {
          top = appDOMRect.bottom - modalHeight;
      }
      else {
          top = appDOMRect.top;
      }
      if (appDOMRect.right - eventDOMRect.right > WIDTH_NEEDED) {
          left = eventDOMRect.right + INLINE_SPACE_BETWEEN_MODAL_AND_EVENT;
          animationStart = '-10%';
      }
      else if (eventDOMRect.left - appDOMRect.left > WIDTH_NEEDED) {
          left = eventDOMRect.left - WIDTH_NEEDED;
          animationStart = '10%';
      }
      else {
          left = appDOMRect.left;
      }
      document.documentElement.style.setProperty('--sx-event-modal-animation-start', animationStart);
      document.documentElement.style.setProperty('--sx-event-modal-top', `${top}px`);
      document.documentElement.style.setProperty('--sx-event-modal-left', `${left}px`);
  };

  function EditIcon({ color }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("svg", { className: "sx__modal-edit-icon", xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24", children: jsxRuntime.jsx("path", { fill: color, d: "M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z" }) }) }));
  }

  function TrashIcon({ color }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("svg", { className: "sx__modal-trash-icon", xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24", children: jsxRuntime.jsx("path", { fill: color, d: "M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z" }) }) }));
  }

  const useIconColors = ($app) => {
      const ICON_COLOR_LIGHT_MODE = '#000';
      const ICON_COLOR_DARK_MODE = 'var(--sx-color-neutral-variant)';
      const iconColor = signals.signal($app.calendarState.isDark.value
          ? ICON_COLOR_DARK_MODE
          : ICON_COLOR_LIGHT_MODE);
      signals.effect(() => {
          if ($app.calendarState.isDark.value)
              iconColor.value = ICON_COLOR_DARK_MODE;
          else
              iconColor.value = ICON_COLOR_LIGHT_MODE;
      });
      return iconColor;
  };

  var ViewLevel;
  (function (ViewLevel) {
      ViewLevel["HOURLY"] = "hourly";
      ViewLevel["DAILY"] = "daily";
  })(ViewLevel || (ViewLevel = {}));

  function EventDisplay({ $app, calendarEvent }) {
      const iconColor = useIconColors($app);
      const modalPlugin = $app.config.plugins
          .eventModal;
      const currentViewIsResource = $app.calendarState.view.value === ViewLevel.HOURLY ||
          $app.calendarState.view.value === ViewLevel.DAILY;
      let resourceColorName = undefined;
      if (currentViewIsResource) {
          const resourceDefinition = $app.resourceViewConfig.resources.value.find((r) => r.id === calendarEvent._getForeignProperties().resourceId);
          resourceColorName = (resourceDefinition === null || resourceDefinition === void 0 ? void 0 : resourceDefinition.colorName) || 'primary';
      }
      const eventColorName = resourceColorName || calendarEvent._color;
      const openForm = () => {
          let originalEvent = undefined;
          modalPlugin.isEditingRecurringEvent.value = false;
          if (calendarEvent.isCopy ||
              ('rrule' in calendarEvent._getForeignProperties() &&
                  calendarEvent._getForeignProperties().rrule)) {
              originalEvent = $app.calendarEvents.list.value.find((event) => event.id === calendarEvent.id && !event.isCopy);
              modalPlugin.isEditingRecurringEvent.value = true;
          }
          modalPlugin.formValues.value = deepCloneEvent(originalEvent || calendarEvent, $app)._getExternalEvent();
          // hide modal before showing it again. This will make the transition smoother when repositioning the modal
          modalPlugin.isOpen.value = false;
          modalPlugin.modalState.value = 'edit';
          setTimeout(() => {
              modalPlugin.isOpen.value = true;
          }, 100);
      };
      const openDeleteActions = () => {
          modalPlugin.modalState.value = 'delete';
      };
      const additionalFields = $app.config._customComponentFns.interactiveModalAdditionalFields;
      const additionalFieldsId = hooks.useState(additionalFields ? randomStringId$2() : undefined)[0];
      hooks.useEffect(() => {
          if (additionalFields) {
              additionalFields(document.querySelector(`[data-ccid="${additionalFieldsId}"]`), {
                  calendarEvent,
              });
          }
      }, []);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsxs("header", { className: "sx__interactive-event-modal__header", children: [jsxRuntime.jsx("button", { className: "sx__modal-action-button", onClick: openForm, children: jsxRuntime.jsx(EditIcon, { color: 'rgb(128, 128, 128)' }) }), jsxRuntime.jsx("button", { className: "sx__modal-action-button", onClick: openDeleteActions, children: jsxRuntime.jsx(TrashIcon, { color: 'rgb(128, 128, 128)' }) })] }), jsxRuntime.jsxs("div", { className: "sx__has-icon sx__event-modal__title", children: [jsxRuntime.jsx("div", { style: {
                                  backgroundColor: `var(--sx-color-${eventColorName}-container)`,
                              }, "data-color": eventColorName, className: "sx__interactive-event-modal__color-icon sx__event-icon" }), calendarEvent.title] }), jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__time", children: [jsxRuntime.jsx(TimeIcon, { strokeColor: iconColor.value }), jsxRuntime.jsx("div", { dangerouslySetInnerHTML: {
                                  __html: getTimeStamp(calendarEvent, $app.config.locale.value),
                              } })] }), Array.isArray(calendarEvent.people) &&
                      calendarEvent.people.length > 0 && (jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__people", children: [jsxRuntime.jsx(UserIcon, { strokeColor: iconColor.value }), concatenatePeople(calendarEvent.people)] })), calendarEvent.location && (jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__location", children: [jsxRuntime.jsx(LocationPinIcon, { strokeColor: iconColor.value }), calendarEvent.location] })), calendarEvent.description && (jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__description", children: [jsxRuntime.jsx(DescriptionIcon, { strokeColor: iconColor.value }), calendarEvent.description] })), additionalFields && (jsxRuntime.jsx("div", { "data-ccid": additionalFieldsId, className: "sx__interactive-event-modal__additional-fields" }))] }) }));
  }

  function TextField({ initialValue, onChange, label, fieldName, id, errorMessage, }) {
      const [inputValue, setInputValue] = hooks.useState(initialValue);
      const handleInput = (newValue) => {
          setInputValue(newValue);
          onChange(newValue);
      };
      const BASE_WRAPPER_CLASS = 'sx__text-field-wrapper';
      const [wrapperClasses, setWrapperClasses] = hooks.useState([BASE_WRAPPER_CLASS]);
      hooks.useEffect(() => {
          if (inputValue.length > 0) {
              if (!wrapperClasses.includes('sx__has-value')) {
                  setWrapperClasses([BASE_WRAPPER_CLASS, 'sx__has-value']);
              }
          }
          else {
              if (wrapperClasses.includes('sx__has-value')) {
                  setWrapperClasses([BASE_WRAPPER_CLASS]);
              }
          }
      }, [inputValue]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { className: wrapperClasses.join(' '), children: [jsxRuntime.jsx("input", { id: id, className: 'sx__text-field-input', value: inputValue, onInput: (e) => handleInput(e.currentTarget.value), name: fieldName, type: "text" }), jsxRuntime.jsx("label", { className: 'sx__text-field-label', htmlFor: fieldName, children: label })] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
  }

  function AppButton({ onClick, children, additionalClasses, }) {
      return (jsxRuntime.jsx("button", { className: 'sx__app-button' + (additionalClasses ? ` ${additionalClasses}` : ''), onClick: onClick, children: children }));
  }

  const AppContext$1 = preact.createContext({});

  const DateFormats = {
      DATE_STRING: /^\d{4}-\d{2}-\d{2}$/,
      TIME_STRING: /^\d{2}:\d{2}$/,
      DATE_TIME_STRING: /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/,
  };

  class InvalidDateTimeError extends Error {
      constructor(dateTimeSpecification) {
          super(`Invalid date time specification: ${dateTimeSpecification}`);
      }
  }

  const toJSDate = (dateTimeSpecification) => {
      if (!DateFormats.DATE_TIME_STRING.test(dateTimeSpecification) &&
          !DateFormats.DATE_STRING.test(dateTimeSpecification))
          throw new InvalidDateTimeError(dateTimeSpecification);
      return new Date(Number(dateTimeSpecification.slice(0, 4)), Number(dateTimeSpecification.slice(5, 7)) - 1, Number(dateTimeSpecification.slice(8, 10)), Number(dateTimeSpecification.slice(11, 13)), // for date strings this will be 0
      Number(dateTimeSpecification.slice(14, 16)) // for date strings this will be 0
      );
  };
  const toIntegers = (dateTimeSpecification) => {
      const hours = dateTimeSpecification.slice(11, 13), minutes = dateTimeSpecification.slice(14, 16);
      return {
          year: Number(dateTimeSpecification.slice(0, 4)),
          month: Number(dateTimeSpecification.slice(5, 7)) - 1,
          date: Number(dateTimeSpecification.slice(8, 10)),
          hours: hours !== '' ? Number(hours) : undefined,
          minutes: minutes !== '' ? Number(minutes) : undefined,
      };
  };

  const toLocalizedMonth = (date, locale) => {
      return date.toLocaleString(locale, { month: 'long' });
  };
  const toLocalizedDateString = (date, locale) => {
      return date.toLocaleString(locale, {
          month: 'numeric',
          day: 'numeric',
          year: 'numeric',
      });
  };
  const getOneLetterDayNames = (week, locale) => {
      return week.map((date) => {
          return date.toLocaleString(locale, { weekday: 'short' }).charAt(0);
      });
  };
  const getDayNameShort = (date, locale) => date.toLocaleString(locale, { weekday: 'short' });
  const getDayNamesShort = (week, locale) => {
      return week.map((date) => getDayNameShort(date, locale));
  };
  const getOneLetterOrShortDayNames = (week, locale) => {
      if (['zh-cn', 'zh-tw', 'ca-es'].includes(locale.toLowerCase())) {
          return getDayNamesShort(week, locale);
      }
      return getOneLetterDayNames(week, locale);
  };

  var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='utf-8'%3f%3e%3c!-- Uploaded to: SVG Repo%2c www.svgrepo.com%2c Generator: SVG Repo Mixer Tools --%3e%3csvg width='800px' height='800px' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M6 9L12 15L18 9' stroke='%23DED8E1' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e";

  /**
   * Can be used for generating a random id for an entity
   * Should, however, never be used in potentially resource intense loops,
   * since the performance cost of this compared to new Date().getTime() is ca x4 in v8
   * */
  const randomStringId$1 = () => 's' + Math.random().toString(36).substring(2, 11);

  const isKeyEnterOrSpace = (keyboardEvent) => keyboardEvent.key === 'Enter' || keyboardEvent.key === ' ';

  function AppInput$1() {
      const datePickerInputId = randomStringId$1();
      const datePickerLabelId = randomStringId$1();
      const inputWrapperId = randomStringId$1();
      const $app = hooks.useContext(AppContext$1);
      const getLocalizedDate = (dateString) => {
          if (dateString === '')
              return $app.translate('MM/DD/YYYY');
          return toLocalizedDateString(toJSDate(dateString), $app.config.locale.value);
      };
      hooks.useEffect(() => {
          $app.datePickerState.inputDisplayedValue.value = getLocalizedDate($app.datePickerState.selectedDate.value);
      }, [$app.datePickerState.selectedDate.value, $app.config.locale.value]);
      const [wrapperClasses, setWrapperClasses] = hooks.useState([]);
      const setInputElement = () => {
          const inputWrapperEl = document.getElementById(inputWrapperId);
          $app.datePickerState.inputWrapperElement.value =
              inputWrapperEl instanceof HTMLDivElement ? inputWrapperEl : undefined;
      };
      hooks.useEffect(() => {
          if ($app.config.teleportTo)
              setInputElement();
          const newClasses = ['sx__date-input-wrapper'];
          if ($app.datePickerState.isOpen.value)
              newClasses.push('sx__date-input--active');
          setWrapperClasses(newClasses);
      }, [$app.datePickerState.isOpen.value]);
      const handleKeyUp = (event) => {
          if (event.key === 'Enter')
              handleInputValue(event);
      };
      const handleInputValue = (event) => {
          event.stopPropagation(); // prevent date picker from closing
          try {
              $app.datePickerState.inputDisplayedValue.value = event.target.value;
              $app.datePickerState.close();
          }
          catch (e) {
              // nothing to do
          }
      };
      hooks.useEffect(() => {
          const inputElement = document.getElementById(datePickerInputId);
          if (inputElement === null)
              return;
          inputElement.addEventListener('change', handleInputValue); // Preact onChange triggers on every input
          return () => inputElement.removeEventListener('change', handleInputValue);
      });
      const handleClick = (event) => {
          handleInputValue(event);
          $app.datePickerState.open();
      };
      const handleButtonKeyDown = (keyboardEvent) => {
          if (isKeyEnterOrSpace(keyboardEvent)) {
              keyboardEvent.preventDefault();
              $app.datePickerState.open();
              setTimeout(() => {
                  const element = document.querySelector('[data-focus="true"]');
                  if (element instanceof HTMLElement)
                      element.focus();
              }, 50);
          }
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { className: wrapperClasses.join(' '), id: inputWrapperId, children: [jsxRuntime.jsx("label", { for: datePickerInputId, id: datePickerLabelId, className: "sx__date-input-label", children: $app.config.label || $app.translate('Date') }), jsxRuntime.jsx("input", { id: datePickerInputId, tabIndex: $app.datePickerState.isDisabled.value ? -1 : 0, name: $app.config.name || 'date', "aria-describedby": datePickerLabelId, value: $app.datePickerState.inputDisplayedValue.value, "data-testid": "date-picker-input", className: "sx__date-input", onClick: handleClick, onKeyUp: handleKeyUp, type: "text" }), jsxRuntime.jsx("button", { type: "button", tabIndex: $app.datePickerState.isDisabled.value ? -1 : 0, "aria-label": $app.translate('Choose Date'), onKeyDown: handleButtonKeyDown, onClick: () => $app.datePickerState.open(), className: "sx__date-input-chevron-wrapper", children: jsxRuntime.jsx("img", { className: "sx__date-input-chevron", src: img, alt: "" }) })] }) }));
  }

  var DatePickerView;
  (function (DatePickerView) {
      DatePickerView["MONTH_DAYS"] = "month-days";
      DatePickerView["YEARS"] = "years";
  })(DatePickerView || (DatePickerView = {}));

  const YEARS_VIEW = 'years-view';
  const MONTH_VIEW = 'months-view';
  const DATE_PICKER_WEEK = 'date-picker-week';

  class NumberRangeError extends Error {
      constructor(min, max) {
          super(`Number must be between ${min} and ${max}.`);
          Object.defineProperty(this, "min", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: min
          });
          Object.defineProperty(this, "max", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: max
          });
      }
  }

  const doubleDigit = (number) => {
      if (number < 0 || number > 99)
          throw new NumberRangeError(0, 99);
      return String(number).padStart(2, '0');
  };

  const toDateString$1 = (date) => {
      return `${date.getFullYear()}-${doubleDigit(date.getMonth() + 1)}-${doubleDigit(date.getDate())}`;
  };
  const toTimeString = (date) => {
      return `${doubleDigit(date.getHours())}:${doubleDigit(date.getMinutes())}`;
  };
  const toDateTimeString$1 = (date) => {
      return `${toDateString$1(date)} ${toTimeString(date)}`;
  };

  const addMonths = (to, nMonths) => {
      const { year, month, date, hours, minutes } = toIntegers(to);
      const isDateTimeString = hours !== undefined && minutes !== undefined;
      const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
      let expectedMonth = (jsDate.getMonth() + nMonths) % 12;
      if (expectedMonth < 0)
          expectedMonth += 12;
      jsDate.setMonth(jsDate.getMonth() + nMonths);
      // handle date overflow and underflow
      if (jsDate.getMonth() > expectedMonth) {
          jsDate.setDate(0);
      }
      else if (jsDate.getMonth() < expectedMonth) {
          jsDate.setMonth(jsDate.getMonth() + 1);
          jsDate.setDate(0);
      }
      if (isDateTimeString) {
          return toDateTimeString$1(jsDate);
      }
      return toDateString$1(jsDate);
  };
  const addDays = (to, nDays) => {
      const { year, month, date, hours, minutes } = toIntegers(to);
      const isDateTimeString = hours !== undefined && minutes !== undefined;
      const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
      jsDate.setDate(jsDate.getDate() + nDays);
      if (isDateTimeString) {
          return toDateTimeString$1(jsDate);
      }
      return toDateString$1(jsDate);
  };

  const setDateOfMonth = (dateString, date) => {
      dateString = dateString.slice(0, 8) + doubleDigit(date) + dateString.slice(10);
      return dateString;
  };
  const getFirstDayOPreviousMonth = (dateString) => {
      dateString = addMonths(dateString, -1);
      return setDateOfMonth(dateString, 1);
  };
  const getFirstDayOfNextMonth = (dateString) => {
      dateString = addMonths(dateString, 1);
      return setDateOfMonth(dateString, 1);
  };

  function Chevron({ direction, onClick, buttonText, disabled = false, }) {
      const handleKeyDown = (keyboardEvent) => {
          if (isKeyEnterOrSpace(keyboardEvent))
              onClick();
      };
      return (jsxRuntime.jsx("button", { type: "button", disabled: disabled, className: "sx__chevron-wrapper sx__ripple", onMouseUp: onClick, onKeyDown: handleKeyDown, tabIndex: 0, children: jsxRuntime.jsx("i", { className: `sx__chevron sx__chevron--${direction}`, children: buttonText }) }));
  }

  function MonthViewHeader({ setYearsView }) {
      const $app = hooks.useContext(AppContext$1);
      const dateStringToLocalizedMonthName = (selectedDate) => {
          const selectedDateJS = toJSDate(selectedDate);
          return toLocalizedMonth(selectedDateJS, $app.config.locale.value);
      };
      const getYearFrom = (datePickerDate) => {
          return toIntegers(datePickerDate).year;
      };
      const [selectedDateMonthName, setSelectedDateMonthName] = hooks.useState(dateStringToLocalizedMonthName($app.datePickerState.datePickerDate.value));
      const [datePickerYear, setDatePickerYear] = hooks.useState(getYearFrom($app.datePickerState.datePickerDate.value));
      const setPreviousMonth = () => {
          $app.datePickerState.datePickerDate.value = getFirstDayOPreviousMonth($app.datePickerState.datePickerDate.value);
      };
      const setNextMonth = () => {
          $app.datePickerState.datePickerDate.value = getFirstDayOfNextMonth($app.datePickerState.datePickerDate.value);
      };
      hooks.useEffect(() => {
          setSelectedDateMonthName(dateStringToLocalizedMonthName($app.datePickerState.datePickerDate.value));
          setDatePickerYear(getYearFrom($app.datePickerState.datePickerDate.value));
      }, [$app.datePickerState.datePickerDate.value]);
      const handleOpenYearsView = (e) => {
          e.stopPropagation();
          setYearsView();
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("header", { className: "sx__date-picker__month-view-header", children: [jsxRuntime.jsx(Chevron, { direction: 'previous', onClick: () => setPreviousMonth(), buttonText: $app.translate('Previous month') }), jsxRuntime.jsx("button", { type: "button", className: "sx__date-picker__month-view-header__month-year", onClick: (event) => handleOpenYearsView(event), children: selectedDateMonthName + ' ' + datePickerYear }), jsxRuntime.jsx(Chevron, { direction: 'next', onClick: () => setNextMonth(), buttonText: $app.translate('Next month') })] }) }));
  }

  function DayNames() {
      const $app = hooks.useContext(AppContext$1);
      const aWeek = $app.timeUnitsImpl.getWeekFor(toJSDate($app.datePickerState.datePickerDate.value));
      const dayNames = getOneLetterOrShortDayNames(aWeek, $app.config.locale.value);
      return (jsxRuntime.jsx("div", { className: "sx__date-picker__day-names", children: dayNames.map((dayName) => (jsxRuntime.jsx("span", { "data-testid": "day-name", className: "sx__date-picker__day-name", children: dayName }))) }));
  }

  const isToday = (date) => {
      const today = new Date();
      return (date.getDate() === today.getDate() &&
          date.getMonth() === today.getMonth() &&
          date.getFullYear() === today.getFullYear());
  };
  const isSameMonth = (date1, date2) => {
      return (date1.getMonth() === date2.getMonth() &&
          date1.getFullYear() === date2.getFullYear());
  };

  var WeekDay;
  (function (WeekDay) {
      WeekDay[WeekDay["SUNDAY"] = 0] = "SUNDAY";
      WeekDay[WeekDay["MONDAY"] = 1] = "MONDAY";
      WeekDay[WeekDay["TUESDAY"] = 2] = "TUESDAY";
      WeekDay[WeekDay["WEDNESDAY"] = 3] = "WEDNESDAY";
      WeekDay[WeekDay["THURSDAY"] = 4] = "THURSDAY";
      WeekDay[WeekDay["FRIDAY"] = 5] = "FRIDAY";
      WeekDay[WeekDay["SATURDAY"] = 6] = "SATURDAY";
  })(WeekDay || (WeekDay = {}));

  const DEFAULT_LOCALE = 'en-US';
  const DEFAULT_FIRST_DAY_OF_WEEK = WeekDay.MONDAY;

  const dateFn = (dateTimeString, locale) => {
      const { year, month, date } = toIntegers(dateTimeString);
      return new Date(year, month, date).toLocaleDateString(locale, {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
      });
  };
  const getLocalizedDate = dateFn;

  function MonthViewWeek({ week }) {
      const $app = hooks.useContext(AppContext$1);
      const weekDays = week.map((day) => {
          const classes = ['sx__date-picker__day'];
          if (isToday(day))
              classes.push('sx__date-picker__day--today');
          if (toDateString$1(day) === $app.datePickerState.selectedDate.value)
              classes.push('sx__date-picker__day--selected');
          if (!isSameMonth(day, toJSDate($app.datePickerState.datePickerDate.value)))
              classes.push('is-leading-or-trailing');
          return {
              day,
              classes,
          };
      });
      const isDateSelectable = (date) => {
          const dateString = toDateString$1(date);
          return dateString >= $app.config.min && dateString <= $app.config.max;
      };
      const selectDate = (date) => {
          $app.datePickerState.selectedDate.value = toDateString$1(date);
          $app.datePickerState.close();
      };
      const hasFocus = (weekDay) => toDateString$1(weekDay.day) === $app.datePickerState.datePickerDate.value;
      const handleKeyDown = (event) => {
          if (event.key === 'Enter') {
              $app.datePickerState.selectedDate.value =
                  $app.datePickerState.datePickerDate.value;
              $app.datePickerState.close();
              return;
          }
          const keyMapDaysToAdd = new Map([
              ['ArrowDown', 7],
              ['ArrowUp', -7],
              ['ArrowLeft', -1],
              ['ArrowRight', 1],
          ]);
          $app.datePickerState.datePickerDate.value = addDays($app.datePickerState.datePickerDate.value, keyMapDaysToAdd.get(event.key) || 0);
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { "data-testid": DATE_PICKER_WEEK, className: "sx__date-picker__week", children: weekDays.map((weekDay) => (jsxRuntime.jsx("button", { type: "button", tabIndex: hasFocus(weekDay) ? 0 : -1, disabled: !isDateSelectable(weekDay.day), "aria-label": getLocalizedDate($app.datePickerState.datePickerDate.value, $app.config.locale.value), className: weekDay.classes.join(' '), "data-focus": hasFocus(weekDay) ? 'true' : undefined, onClick: () => selectDate(weekDay.day), onKeyDown: handleKeyDown, children: weekDay.day.getDate() }))) }) }));
  }

  function MonthView({ seatYearsView }) {
      const elementId = randomStringId$1();
      const $app = hooks.useContext(AppContext$1);
      const [month, setMonth] = hooks.useState([]);
      const renderMonth = () => {
          const newDatePickerDate = toJSDate($app.datePickerState.datePickerDate.value);
          setMonth($app.timeUnitsImpl.getMonthWithTrailingAndLeadingDays(newDatePickerDate.getFullYear(), newDatePickerDate.getMonth()));
      };
      hooks.useEffect(() => {
          renderMonth();
      }, [$app.datePickerState.datePickerDate.value]);
      hooks.useEffect(() => {
          const observer = new MutationObserver((mutations) => {
              mutations.forEach((mutation) => {
                  const mutatedElement = mutation.target;
                  if (mutatedElement.dataset.focus === 'true')
                      mutatedElement.focus();
              });
          });
          const monthViewElement = document.getElementById(elementId);
          observer.observe(monthViewElement, {
              childList: true,
              subtree: true,
              attributes: true,
          });
          return () => observer.disconnect();
      }, []);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { id: elementId, "data-testid": MONTH_VIEW, className: "sx__date-picker__month-view", children: [jsxRuntime.jsx(MonthViewHeader, { setYearsView: seatYearsView }), jsxRuntime.jsx(DayNames, {}), month.map((week) => (jsxRuntime.jsx(MonthViewWeek, { week: week })))] }) }));
  }

  function YearsViewAccordion({ year, setYearAndMonth, isExpanded, expand, }) {
      const $app = hooks.useContext(AppContext$1);
      const yearWithDates = $app.timeUnitsImpl.getMonthsFor(year);
      const handleClickOnMonth = (event, month) => {
          event.stopPropagation();
          setYearAndMonth(year, month.getMonth());
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("li", { className: isExpanded ? 'sx__is-expanded' : '', children: [jsxRuntime.jsx("button", { type: "button", className: "sx__date-picker__years-accordion__expand-button sx__ripple--wide", onClick: () => expand(year), children: year }), isExpanded && (jsxRuntime.jsx("div", { className: "sx__date-picker__years-view-accordion__panel", children: yearWithDates.map((month) => (jsxRuntime.jsx("button", { type: "button", className: "sx__date-picker__years-view-accordion__month", onClick: (event) => handleClickOnMonth(event, month), children: toLocalizedMonth(month, $app.config.locale.value) }))) }))] }) }));
  }

  function YearsView({ setMonthView }) {
      const $app = hooks.useContext(AppContext$1);
      const minYear = toJSDate($app.config.min).getFullYear();
      const maxYear = toJSDate($app.config.max).getFullYear();
      const years = Array.from({ length: maxYear - minYear + 1 }, (_, i) => minYear + i);
      const { year: selectedYear } = toIntegers($app.datePickerState.selectedDate.value);
      const [expandedYear, setExpandedYear] = hooks.useState(selectedYear);
      const setNewDatePickerDate = (year, month) => {
          $app.datePickerState.datePickerDate.value = toDateString$1(new Date(year, month, 1));
          setMonthView();
      };
      hooks.useEffect(() => {
          var _a;
          const initiallyExpandedYear = (_a = document
              .querySelector('.sx__date-picker__years-view')) === null || _a === void 0 ? void 0 : _a.querySelector('.sx__is-expanded');
          if (!initiallyExpandedYear)
              return;
          initiallyExpandedYear.scrollIntoView({
              block: 'center',
          });
      }, []);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("ul", { className: "sx__date-picker__years-view", "data-testid": YEARS_VIEW, children: years.map((year) => (jsxRuntime.jsx(YearsViewAccordion, { year: year, setYearAndMonth: (year, month) => setNewDatePickerDate(year, month), isExpanded: expandedYear === year, expand: (year) => setExpandedYear(year) }))) }) }));
  }

  const isScrollable$2 = (el) => {
      if (el) {
          const hasScrollableContent = el.scrollHeight > el.clientHeight;
          const overflowYStyle = window.getComputedStyle(el).overflowY;
          const isOverflowHidden = overflowYStyle.indexOf('hidden') !== -1;
          return hasScrollableContent && !isOverflowHidden;
      }
      return true;
  };
  const getScrollableParents$2 = (el, acc = []) => {
      if (!el ||
          el === document.body ||
          el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          acc.push(window);
          return acc;
      }
      if (isScrollable$2(el)) {
          acc.push(el);
      }
      return getScrollableParents$2((el.assignedSlot
          ? el.assignedSlot.parentNode
          : el.parentNode), acc);
  };

  const POPUP_CLASS_NAME = 'sx__date-picker-popup';
  function AppPopup$1() {
      const $app = hooks.useContext(AppContext$1);
      const [datePickerView, setDatePickerView] = hooks.useState(DatePickerView.MONTH_DAYS);
      const basePopupClasses = [POPUP_CLASS_NAME, $app.config.placement];
      const [classList, setClassList] = hooks.useState(basePopupClasses);
      hooks.useEffect(() => {
          setClassList([
              ...basePopupClasses,
              $app.datePickerState.isDark.value ? 'is-dark' : '',
              $app.config.teleportTo ? 'is-teleported' : '',
          ]);
      }, [$app.datePickerState.isDark.value]);
      const clickOutsideListener = (event) => {
          const target = event.target;
          if (!target.closest(`.${POPUP_CLASS_NAME}`))
              $app.datePickerState.close();
      };
      const escapeKeyListener = (e) => {
          if (e.key === 'Escape') {
              if ($app.config.listeners.onEscapeKeyDown)
                  $app.config.listeners.onEscapeKeyDown($app);
              else
                  $app.datePickerState.close();
          }
      };
      hooks.useEffect(() => {
          document.addEventListener('click', clickOutsideListener);
          document.addEventListener('keydown', escapeKeyListener);
          return () => {
              document.removeEventListener('click', clickOutsideListener);
              document.removeEventListener('keydown', escapeKeyListener);
          };
      }, []);
      const remSize = Number(getComputedStyle(document.documentElement).fontSize.split('px')[0]);
      const popupHeight = 362;
      const popupWidth = 332;
      const getFixedPositionStyles = () => {
          const inputWrapperEl = $app.datePickerState.inputWrapperElement.value;
          const inputRect = inputWrapperEl === null || inputWrapperEl === void 0 ? void 0 : inputWrapperEl.getBoundingClientRect();
          if (inputWrapperEl === undefined || !(inputRect instanceof DOMRect))
              return undefined;
          return {
              top: $app.config.placement.includes('bottom')
                  ? inputRect.height + inputRect.y + 1 // 1px border
                  : inputRect.y - remSize - popupHeight, // subtract remsize to leave room for label text
              left: $app.config.placement.includes('start')
                  ? inputRect.x
                  : inputRect.x + inputRect.width - popupWidth,
              width: popupWidth,
              position: 'fixed',
          };
      };
      const [fixedPositionStyle, setFixedPositionStyle] = hooks.useState(getFixedPositionStyles());
      hooks.useEffect(() => {
          const inputWrapper = $app.datePickerState.inputWrapperElement.value;
          if (inputWrapper === undefined)
              return;
          const scrollableParents = getScrollableParents$2(inputWrapper);
          const scrollListener = () => setFixedPositionStyle(getFixedPositionStyles());
          scrollableParents.forEach((parent) => parent.addEventListener('scroll', scrollListener));
          return () => scrollableParents.forEach((parent) => parent.removeEventListener('scroll', scrollListener));
      }, []);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { style: $app.config.teleportTo ? fixedPositionStyle : undefined, "data-testid": "date-picker-popup", className: classList.join(' '), children: datePickerView === DatePickerView.MONTH_DAYS ? (jsxRuntime.jsx(MonthView, { seatYearsView: () => setDatePickerView(DatePickerView.YEARS) })) : (jsxRuntime.jsx(YearsView, { setMonthView: () => setDatePickerView(DatePickerView.MONTH_DAYS) })) }) }));
  }

  function AppWrapper({ $app }) {
      const initialClassList = ['sx__date-picker-wrapper'];
      const [classList, setClassList] = hooks.useState(initialClassList);
      hooks.useEffect(() => {
          var _a;
          const list = [...initialClassList];
          if ($app.datePickerState.isDark.value)
              list.push('is-dark');
          if ((_a = $app.config.style) === null || _a === void 0 ? void 0 : _a.fullWidth)
              list.push('has-full-width');
          if ($app.datePickerState.isDisabled.value)
              list.push('is-disabled');
          setClassList(list);
      }, [$app.datePickerState.isDark.value, $app.datePickerState.isDisabled.value]);
      let appPopupJSX = jsxRuntime.jsx(AppPopup$1, {});
      if ($app.config.teleportTo)
          appPopupJSX = compat.createPortal(appPopupJSX, $app.config.teleportTo);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { className: classList.join(' '), children: jsxRuntime.jsxs(AppContext$1.Provider, { value: $app, children: [jsxRuntime.jsx(AppInput$1, {}), $app.datePickerState.isOpen.value && appPopupJSX] }) }) }));
  }

  class DatePickerApp {
      constructor($app) {
          Object.defineProperty(this, "$app", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: $app
          });
      }
      render(el) {
          preact.render(preact.createElement(AppWrapper, {
              $app: this.$app,
          }), el);
      }
      get value() {
          return this.$app.datePickerState.selectedDate.value;
      }
      set value(value) {
          this.$app.datePickerState.selectedDate.value = value;
      }
      get disabled() {
          return this.$app.datePickerState.isDisabled.value;
      }
      set disabled(value) {
          this.$app.datePickerState.isDisabled.value = value;
      }
      setTheme(theme) {
          this.$app.datePickerState.isDark.value = theme === 'dark';
      }
      getTheme() {
          return this.$app.datePickerState.isDark.value ? 'dark' : 'light';
      }
  }

  var Month;
  (function (Month) {
      Month[Month["JANUARY"] = 0] = "JANUARY";
      Month[Month["FEBRUARY"] = 1] = "FEBRUARY";
      Month[Month["MARCH"] = 2] = "MARCH";
      Month[Month["APRIL"] = 3] = "APRIL";
      Month[Month["MAY"] = 4] = "MAY";
      Month[Month["JUNE"] = 5] = "JUNE";
      Month[Month["JULY"] = 6] = "JULY";
      Month[Month["AUGUST"] = 7] = "AUGUST";
      Month[Month["SEPTEMBER"] = 8] = "SEPTEMBER";
      Month[Month["OCTOBER"] = 9] = "OCTOBER";
      Month[Month["NOVEMBER"] = 10] = "NOVEMBER";
      Month[Month["DECEMBER"] = 11] = "DECEMBER";
  })(Month || (Month = {}));

  class NoYearZeroError extends Error {
      constructor() {
          super('Year zero does not exist in the Gregorian calendar.');
      }
  }

  class ExtendedDateImpl extends Date {
      constructor(yearArg, monthArg, dateArg) {
          super(yearArg, monthArg, dateArg);
          if (yearArg === 0)
              throw new NoYearZeroError();
          this.setFullYear(yearArg); // Overwrite the behavior of JS-Date, whose constructor does not allow years 0-99
      }
      get year() {
          return this.getFullYear();
      }
      get month() {
          return this.getMonth();
      }
      get date() {
          return this.getDate();
      }
  }

  class TimeUnitsImpl {
      constructor(config) {
          Object.defineProperty(this, "config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: config
          });
      }
      get firstDayOfWeek() {
          return this.config.firstDayOfWeek.value;
      }
      set firstDayOfWeek(firstDayOfWeek) {
          this.config.firstDayOfWeek.value = firstDayOfWeek;
      }
      getMonthWithTrailingAndLeadingDays(year, month) {
          if (year === 0)
              throw new NoYearZeroError();
          const firstDateOfMonth = new Date(year, month, 1);
          const monthWithDates = [this.getWeekFor(firstDateOfMonth)];
          let isInMonth = true;
          let first = monthWithDates[0][0]; // first day of first week of month
          while (isInMonth) {
              const newFirstDayOfWeek = new Date(first.getFullYear(), first.getMonth(), first.getDate() + 7);
              if (newFirstDayOfWeek.getMonth() === month) {
                  monthWithDates.push(this.getWeekFor(newFirstDayOfWeek));
                  first = newFirstDayOfWeek;
              }
              else {
                  isInMonth = false;
              }
          }
          return monthWithDates;
      }
      getWeekFor(date) {
          const week = [this.getFirstDateOfWeek(date)];
          while (week.length < 7) {
              const lastDateOfWeek = week[week.length - 1];
              const nextDateOfWeek = new Date(lastDateOfWeek);
              nextDateOfWeek.setDate(lastDateOfWeek.getDate() + 1);
              week.push(nextDateOfWeek);
          }
          return week;
      }
      getMonthsFor(year) {
          return Object.values(Month)
              .filter((month) => !isNaN(Number(month)))
              .map((month) => new ExtendedDateImpl(year, Number(month), 1));
      }
      getFirstDateOfWeek(date) {
          const dateIsNthDayOfWeek = date.getDay() - this.firstDayOfWeek;
          const firstDateOfWeek = date;
          if (dateIsNthDayOfWeek === 0) {
              return firstDateOfWeek;
          }
          else if (dateIsNthDayOfWeek > 0) {
              firstDateOfWeek.setDate(date.getDate() - dateIsNthDayOfWeek);
          }
          else {
              firstDateOfWeek.setDate(date.getDate() - (7 + dateIsNthDayOfWeek));
          }
          return firstDateOfWeek;
      }
  }

  class TimeUnitsBuilder {
      constructor() {
          Object.defineProperty(this, "config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
      }
      build() {
          return new TimeUnitsImpl(this.config);
      }
      withConfig(config) {
          this.config = config;
          return this;
      }
  }

  var DateFormatDelimiter;
  (function (DateFormatDelimiter) {
      DateFormatDelimiter["SLASH"] = "/";
      DateFormatDelimiter["DASH"] = "-";
      DateFormatDelimiter["PERIOD"] = ".";
  })(DateFormatDelimiter || (DateFormatDelimiter = {}));
  var DateFormatOrder;
  (function (DateFormatOrder) {
      DateFormatOrder["DMY"] = "DMY";
      DateFormatOrder["MDY"] = "MDY";
      DateFormatOrder["YMD"] = "YMD";
  })(DateFormatOrder || (DateFormatOrder = {}));

  const formatRules = {
      slashMDY: {
          delimiter: DateFormatDelimiter.SLASH,
          order: DateFormatOrder.MDY,
      },
      slashDMY: {
          delimiter: DateFormatDelimiter.SLASH,
          order: DateFormatOrder.DMY,
      },
      slashYMD: {
          delimiter: DateFormatDelimiter.SLASH,
          order: DateFormatOrder.YMD,
      },
      periodDMY: {
          delimiter: DateFormatDelimiter.PERIOD,
          order: DateFormatOrder.DMY,
      },
      dashYMD: {
          delimiter: DateFormatDelimiter.DASH,
          order: DateFormatOrder.YMD,
      },
  };
  const dateFormatLocalizedRules = new Map([
      ['en-US', formatRules.slashMDY],
      ['en-GB', formatRules.slashDMY],
      ['zh-CN', formatRules.slashYMD],
      ['de-DE', formatRules.periodDMY],
      ['sv-SE', formatRules.dashYMD],
  ]);

  class LocaleNotSupportedError extends Error {
      constructor(locale) {
          super(`Locale not supported: ${locale}`);
      }
  }

  class InvalidDateFormatError extends Error {
      constructor(dateFormat, locale) {
          super(`Invalid date format: ${dateFormat} for locale: ${locale}`);
      }
  }

  const _getMatchesOrThrow = (format, matcher, locale) => {
      const matches = format.match(matcher);
      if (!matches)
          throw new InvalidDateFormatError(format, locale);
      return matches;
  };
  const toDateString = (format, locale) => {
      const internationalFormat = /^\d{4}-\d{2}-\d{2}$/;
      if (internationalFormat.test(format))
          return format; // allow international format regardless of locale
      const localeDateFormatRule = dateFormatLocalizedRules.get(locale);
      if (!localeDateFormatRule)
          throw new LocaleNotSupportedError(locale);
      const { order, delimiter } = localeDateFormatRule;
      const pattern224Slashed = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/;
      const pattern224Dotted = /^(\d{1,2})\.(\d{1,2})\.(\d{4})$/;
      const pattern442Slashed = /^(\d{4})\/(\d{1,2})\/(\d{1,2})$/;
      if (order === DateFormatOrder.DMY && delimiter === DateFormatDelimiter.SLASH) {
          const matches = _getMatchesOrThrow(format, pattern224Slashed, locale);
          const [, day, month, year] = matches;
          return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
      }
      if (order === DateFormatOrder.MDY && delimiter === DateFormatDelimiter.SLASH) {
          const matches = _getMatchesOrThrow(format, pattern224Slashed, locale);
          const [, month, day, year] = matches;
          return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
      }
      if (order === DateFormatOrder.YMD && delimiter === DateFormatDelimiter.SLASH) {
          const matches = _getMatchesOrThrow(format, pattern442Slashed, locale);
          const [, year, month, day] = matches;
          return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
      }
      if (order === DateFormatOrder.DMY && delimiter === DateFormatDelimiter.PERIOD) {
          const matches = _getMatchesOrThrow(format, pattern224Dotted, locale);
          const [, day, month, year] = matches;
          return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
      }
      throw new InvalidDateFormatError(format, locale);
  };

  const createDatePickerState = (config, selectedDateParam) => {
      var _a;
      const currentDayDateString = toDateString$1(new Date());
      const initialSelectedDate = typeof selectedDateParam === 'string'
          ? selectedDateParam
          : currentDayDateString;
      const isOpen = signals.signal(false);
      const isDisabled = signals.signal(config.disabled || false);
      const datePickerView = signals.signal(DatePickerView.MONTH_DAYS);
      const selectedDate = signals.signal(initialSelectedDate);
      const datePickerDate = signals.signal(initialSelectedDate || currentDayDateString);
      const isDark = signals.signal(((_a = config.style) === null || _a === void 0 ? void 0 : _a.dark) || false);
      const inputDisplayedValue = signals.signal(selectedDateParam || '');
      const lastValidDisplayedValue = signals.signal(selectedDateParam || '');
      signals.effect(() => {
          try {
              const newValue = toDateString(inputDisplayedValue.value, config.locale.value);
              if (newValue < config.min || newValue > config.max) {
                  inputDisplayedValue.value = lastValidDisplayedValue.value;
                  return;
              }
              selectedDate.value = newValue;
              datePickerDate.value = newValue;
              lastValidDisplayedValue.value = inputDisplayedValue.value;
          }
          catch (e) {
              // nothing to do
          }
      });
      let wasInitialized = false;
      const handleOnChange = (selectedDate) => {
          if (!wasInitialized)
              return (wasInitialized = true);
          config.listeners.onChange(selectedDate);
      };
      signals.effect(() => {
          var _a;
          if ((_a = config.listeners) === null || _a === void 0 ? void 0 : _a.onChange)
              handleOnChange(selectedDate.value);
      });
      return {
          inputWrapperElement: signals.signal(undefined),
          isOpen,
          isDisabled,
          datePickerView,
          selectedDate,
          datePickerDate,
          inputDisplayedValue,
          isDark,
          open: () => (isOpen.value = true),
          close: () => (isOpen.value = false),
          toggle: () => (isOpen.value = !isOpen.value),
          setView: (view) => (datePickerView.value = view),
      };
  };

  class DatePickerAppSingletonImpl {
      constructor(datePickerState, config, timeUnitsImpl, translate) {
          Object.defineProperty(this, "datePickerState", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: datePickerState
          });
          Object.defineProperty(this, "config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: config
          });
          Object.defineProperty(this, "timeUnitsImpl", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: timeUnitsImpl
          });
          Object.defineProperty(this, "translate", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: translate
          });
      }
  }

  class DatePickerAppSingletonBuilder {
      constructor() {
          Object.defineProperty(this, "datePickerState", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "timeUnitsImpl", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "translate", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
      }
      build() {
          return new DatePickerAppSingletonImpl(this.datePickerState, this.config, this.timeUnitsImpl, this.translate);
      }
      withDatePickerState(datePickerState) {
          this.datePickerState = datePickerState;
          return this;
      }
      withConfig(config) {
          this.config = config;
          return this;
      }
      withTimeUnitsImpl(timeUnitsImpl) {
          this.timeUnitsImpl = timeUnitsImpl;
          return this;
      }
      withTranslate(translate) {
          this.translate = translate;
          return this;
      }
  }

  var Placement;
  (function (Placement) {
      Placement["TOP_START"] = "top-start";
      Placement["TOP_END"] = "top-end";
      Placement["BOTTOM_START"] = "bottom-start";
      Placement["BOTTOM_END"] = "bottom-end";
  })(Placement || (Placement = {}));

  class ConfigImpl {
      constructor(locale = DEFAULT_LOCALE, firstDayOfWeek = DEFAULT_FIRST_DAY_OF_WEEK, min = toDateString$1(new Date(1970, 0, 1)), max = toDateString$1(new Date(new Date().getFullYear() + 50, 11, 31)), placement = Placement.BOTTOM_START, listeners = {}, style = {}, teleportTo, label, name, disabled) {
          Object.defineProperty(this, "min", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: min
          });
          Object.defineProperty(this, "max", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: max
          });
          Object.defineProperty(this, "placement", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: placement
          });
          Object.defineProperty(this, "listeners", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: listeners
          });
          Object.defineProperty(this, "style", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: style
          });
          Object.defineProperty(this, "teleportTo", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: teleportTo
          });
          Object.defineProperty(this, "label", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: label
          });
          Object.defineProperty(this, "name", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: name
          });
          Object.defineProperty(this, "disabled", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: disabled
          });
          Object.defineProperty(this, "locale", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "firstDayOfWeek", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          this.locale = signals.signal(locale);
          this.firstDayOfWeek = signals.signal(firstDayOfWeek);
      }
  }

  class ConfigBuilder {
      constructor() {
          Object.defineProperty(this, "locale", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "firstDayOfWeek", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "min", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "max", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "placement", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "listeners", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "style", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "teleportTo", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "label", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "name", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "disabled", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
      }
      build() {
          return new ConfigImpl(this.locale, this.firstDayOfWeek, this.min, this.max, this.placement, this.listeners, this.style, this.teleportTo, this.label, this.name, this.disabled);
      }
      withLocale(locale) {
          this.locale = locale;
          return this;
      }
      withFirstDayOfWeek(firstDayOfWeek) {
          this.firstDayOfWeek = firstDayOfWeek;
          return this;
      }
      withMin(min) {
          this.min = min;
          return this;
      }
      withMax(max) {
          this.max = max;
          return this;
      }
      withPlacement(placement) {
          this.placement = placement;
          return this;
      }
      withListeners(listeners) {
          this.listeners = listeners;
          return this;
      }
      withStyle(style) {
          this.style = style;
          return this;
      }
      withTeleportTo(teleportTo) {
          this.teleportTo = teleportTo;
          return this;
      }
      withLabel(label) {
          this.label = label;
          return this;
      }
      withName(name) {
          this.name = name;
          return this;
      }
      withDisabled(disabled) {
          this.disabled = disabled;
          return this;
      }
  }

  const datePickerDeDE = {
      Date: 'Datum',
      'MM/DD/YYYY': 'TT.MM.JJJJ',
      'Next month': 'Nächster Monat',
      'Previous month': 'Vorheriger Monat',
      'Choose Date': 'Datum auswählen',
  };

  const calendarDeDE = {
      Today: 'Heute',
      Month: 'Monat',
      Week: 'Woche',
      Day: 'Tag',
      'Select View': 'Ansicht auswählen',
      events: 'Ereignisse',
      event: 'Ereignis',
      'No events': 'Keine Ereignisse',
      'Next period': 'Nächster Zeitraum',
      'Previous period': 'Vorheriger Zeitraum',
      to: 'bis', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Ganztägige und mehrtägige Ereignisse',
      'Link to {{n}} more events on {{date}}': 'Link zu {{n}} weiteren Ereignissen am {{date}}',
      'Link to 1 more event on {{date}}': 'Link zu 1 weiteren Ereignis am {{date}}',
  };

  const deDE = {
      ...datePickerDeDE,
      ...calendarDeDE,
  };

  const datePickerEnUS = {
      Date: 'Date',
      'MM/DD/YYYY': 'MM/DD/YYYY',
      'Next month': 'Next month',
      'Previous month': 'Previous month',
      'Choose Date': 'Choose Date',
  };

  const calendarEnUS = {
      Today: 'Today',
      Month: 'Month',
      Week: 'Week',
      Day: 'Day',
      'Select View': 'Select View',
      events: 'events',
      event: 'event',
      'No events': 'No events',
      'Next period': 'Next period',
      'Previous period': 'Previous period',
      to: 'to', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Full day- and multiple day events',
      'Link to {{n}} more events on {{date}}': 'Link to {{n}} more events on {{date}}',
      'Link to 1 more event on {{date}}': 'Link to 1 more event on {{date}}',
  };

  const enUS = {
      ...datePickerEnUS,
      ...calendarEnUS,
  };

  const datePickerItIT = {
      Date: 'Data',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Mese successivo',
      'Previous month': 'Mese precedente',
      'Choose Date': 'Scegli la data',
  };

  const calendarItIT = {
      Today: 'Oggi',
      Month: 'Mese',
      Week: 'Settimana',
      Day: 'Giorno',
      'Select View': 'Seleziona la vista',
      events: 'eventi',
      event: 'evento',
      'No events': 'Nessun evento',
      'Next period': 'Periodo successivo',
      'Previous period': 'Periodo precedente',
      to: 'a', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Eventi della giornata e plurigiornalieri',
      'Link to {{n}} more events on {{date}}': 'Link a {{n}} eventi in più il {{date}}',
      'Link to 1 more event on {{date}}': 'Link a 1 evento in più il {{date}}',
  };

  const itIT = {
      ...datePickerItIT,
      ...calendarItIT,
  };

  const datePickerEnGB = {
      Date: 'Date',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Next month',
      'Previous month': 'Previous month',
      'Choose Date': 'Choose Date',
  };

  const calendarEnGB = {
      Today: 'Today',
      Month: 'Month',
      Week: 'Week',
      Day: 'Day',
      'Select View': 'Select View',
      events: 'events',
      event: 'event',
      'No events': 'No events',
      'Next period': 'Next period',
      'Previous period': 'Previous period',
      to: 'to', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Full day- and multiple day events',
      'Link to {{n}} more events on {{date}}': 'Link to {{n}} more events on {{date}}',
      'Link to 1 more event on {{date}}': 'Link to 1 more event on {{date}}',
  };

  const enGB = {
      ...datePickerEnGB,
      ...calendarEnGB,
  };

  const datePickerSvSE = {
      Date: 'Datum',
      'MM/DD/YYYY': 'ÅÅÅÅ-MM-DD',
      'Next month': 'Nästa månad',
      'Previous month': 'Föregående månad',
      'Choose Date': 'Välj datum',
  };

  const calendarSvSE = {
      Today: 'Idag',
      Month: 'Månad',
      Week: 'Vecka',
      Day: 'Dag',
      'Select View': 'Välj vy',
      events: 'händelser',
      event: 'händelse',
      'No events': 'Inga händelser',
      'Next period': 'Nästa period',
      'Previous period': 'Föregående period',
      to: 'till', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Heldags- och flerdagshändelser',
      'Link to {{n}} more events on {{date}}': 'Länk till {{n}} fler händelser den {{date}}',
      'Link to 1 more event on {{date}}': 'Länk till 1 händelse till den {{date}}',
  };

  const svSE = {
      ...datePickerSvSE,
      ...calendarSvSE,
  };

  const datePickerZhCN = {
      Date: '日期',
      'MM/DD/YYYY': '年/月/日',
      'Next month': '下个月',
      'Previous month': '上个月',
      'Choose Date': '选择日期',
  };

  const calendarZhCN = {
      Today: '今天',
      Month: '月',
      Week: '周',
      Day: '日',
      'Select View': '选择视图',
      events: '场活动',
      event: '活动',
      'No events': '没有活动',
      'Next period': '下一段时间',
      'Previous period': '上一段时间',
      to: '至', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': '全天和多天活动',
      'Link to {{n}} more events on {{date}}': '链接到{{date}}上的{{n}}个更多活动',
      'Link to 1 more event on {{date}}': '链接到{{date}}上的1个更多活动',
  };

  const zhCN = {
      ...datePickerZhCN,
      ...calendarZhCN,
  };

  const datePickerZhTW = {
      Date: '日期',
      'MM/DD/YYYY': '年/月/日',
      'Next month': '下個月',
      'Previous month': '上個月',
      'Choose Date': '選擇日期',
  };

  const calendarZhTW = {
      Today: '今天',
      Month: '月',
      Week: '周',
      Day: '日',
      'Select View': '選擇檢視模式',
      events: '場活動',
      event: '活動',
      'No events': '沒有活動',
      'Next period': '下一段時間',
      'Previous period': '上一段時間',
      to: '到', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': '全天和多天活動',
      'Link to {{n}} more events on {{date}}': '連接到{{date}}上的{{n}}個更多活動',
      'Link to 1 more event on {{date}}': '連接到{{date}}上的1個更多活動',
  };

  const zhTW = {
      ...datePickerZhTW,
      ...calendarZhTW,
  };

  const datePickerJaJP = {
      Date: '日付',
      'MM/DD/YYYY': '年/月/日',
      'Next month': '次の月',
      'Previous month': '前の月',
      'Choose Date': '日付を選択',
  };

  const calendarJaJP = {
      Today: '今日',
      Month: '月',
      Week: '週',
      Day: '日',
      'Select View': 'ビューを選択',
      events: 'イベント',
      event: 'イベント',
      'No events': 'イベントなし',
      'Next period': '次の期間',
      'Previous period': '前の期間',
      to: 'から', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': '終日および複数日イベント',
      'Link to {{n}} more events on {{date}}': '{{date}} に{{n}}件のイベントへのリンク',
      'Link to 1 more event on {{date}}': '{{date}} に1件のイベントへのリンク',
  };

  const jaJP = {
      ...datePickerJaJP,
      ...calendarJaJP,
  };

  const datePickerRuRU = {
      Date: 'Дата',
      'MM/DD/YYYY': 'ММ/ДД/ГГГГ',
      'Next month': 'Следующий месяц',
      'Previous month': 'Прошлый месяц',
      'Choose Date': 'Выберите дату',
  };

  const calendarRuRU = {
      Today: 'Сегодня',
      Month: 'Месяц',
      Week: 'Неделя',
      Day: 'День',
      'Select View': 'Выберите вид',
      events: 'события',
      event: 'событие',
      'No events': 'Нет событий',
      'Next period': 'Следующий период',
      'Previous period': 'Прошлый период',
      to: 'по', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'События на целый день и несколько дней подряд',
      'Link to {{n}} more events on {{date}}': 'Ссылка на {{n}} дополнительных событий на {{date}}',
      'Link to 1 more event on {{date}}': 'Ссылка на 1 дополнительное событие на {{date}}',
  };

  const ruRU = {
      ...datePickerRuRU,
      ...calendarRuRU,
  };

  const datePickerKoKR = {
      Date: '일자',
      'MM/DD/YYYY': '년/월/일',
      'Next month': '다음 달',
      'Previous month': '이전 달',
      'Choose Date': '날짜 선택',
  };

  const calendarKoKR = {
      Today: '오늘',
      Month: '월',
      Week: '주',
      Day: '일',
      'Select View': '보기 선택',
      events: '일정들',
      event: '일정',
      'No events': '일정 없음',
      'Next period': '다음',
      'Previous period': '이전',
      to: '부터', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': '종일 및 복수일 일정',
      'Link to {{n}} more events on {{date}}': '{{date}}에 {{n}}개 이상의 이벤트로 이동',
      'Link to 1 more event on {{date}}': '{{date}}에 1개 이상의 이벤트로 이동',
  };

  const koKR = {
      ...datePickerKoKR,
      ...calendarKoKR,
  };

  const datePickerFrFR = {
      Date: 'Date',
      'MM/DD/YYYY': 'JJ/MM/AAAA',
      'Next month': 'Mois suivant',
      'Previous month': 'Mois précédent',
      'Choose Date': 'Choisir une date',
  };

  const calendarFrFR = {
      Today: "Aujourd'hui",
      Month: 'Mois',
      Week: 'Semaine',
      Day: 'Jour',
      'Select View': 'Choisir la vue',
      events: 'événements',
      event: 'événement',
      'No events': 'Aucun événement',
      'Next period': 'Période suivante',
      'Previous period': 'Période précédente',
      to: 'à', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': "Événements d'une ou plusieurs journées",
      'Link to {{n}} more events on {{date}}': 'Lien vers {{n}} autres événements le {{date}}',
      'Link to 1 more event on {{date}}': 'Lien vers 1 autre événement le {{date}}',
  };

  const frFR = {
      ...datePickerFrFR,
      ...calendarFrFR,
  };

  const datePickerDaDK = {
      Date: 'Dato',
      'MM/DD/YYYY': 'ÅÅÅÅ-MM-DD',
      'Next month': 'Næste måned',
      'Previous month': 'Foregående måned',
      'Choose Date': 'Vælg dato',
  };

  const calendarDaDK = {
      Today: 'I dag',
      Month: 'Måned',
      Week: 'Uge',
      Day: 'Dag',
      'Select View': 'Vælg visning',
      events: 'begivenheder',
      event: 'begivenhed',
      'No events': 'Ingen begivenheder',
      'Next period': 'Næste periode',
      'Previous period': 'Forgående periode',
      to: 'til', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Heldagsbegivenheder og flerdagsbegivenheder',
      'Link to {{n}} more events on {{date}}': 'Link til {{n}} flere begivenheder den {{date}}',
      'Link to 1 more event on {{date}}': 'Link til 1 mere begivenhed den {{date}}',
  };

  const daDK = {
      ...datePickerDaDK,
      ...calendarDaDK,
  };

  const datePickerPlPL = {
      Date: 'Data',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Następny miesiąc',
      'Previous month': 'Poprzedni miesiąc',
      'Choose Date': 'Wybiewrz datę',
  };

  const calendarPlPL = {
      Today: 'Dzisiaj',
      Month: 'Miesiąc',
      Week: 'Tydzień',
      Day: 'Dzień',
      'Select View': 'Wybierz widok',
      events: 'wydarzenia',
      event: 'wydarzenie',
      'No events': 'Brak wydarzeń',
      'Next period': 'Następny okres',
      'Previous period': 'Poprzedni okres',
      to: 'do', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Wydarzenia całodniowe i wielodniowe',
      'Link to {{n}} more events on {{date}}': 'Link do {{n}} kolejnych wydarzeń w dniu {{date}}',
      'Link to 1 more event on {{date}}': 'Link do 1 kolejnego wydarzenia w dniu {{date}}',
  };

  const plPL = {
      ...datePickerPlPL,
      ...calendarPlPL,
  };

  const datePickerEsES = {
      Date: 'Fecha',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Siguiente mes',
      'Previous month': 'Mes anterior',
      'Choose Date': 'Seleccione una fecha',
  };

  const calendarEsES = {
      Today: 'Hoy',
      Month: 'Mes',
      Week: 'Semana',
      Day: 'Día',
      'Select View': 'Seleccione una vista',
      events: 'eventos',
      event: 'evento',
      'No events': 'Sin eventos',
      'Next period': 'Siguiente período',
      'Previous period': 'Período anterior',
      to: 'a', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Día completo y eventos de múltiples días',
      'Link to {{n}} more events on {{date}}': 'Enlace a {{n}} eventos más el {{date}}',
      'Link to 1 more event on {{date}}': 'Enlace a 1 evento más el {{date}}',
  };

  const esES = {
      ...datePickerEsES,
      ...calendarEsES,
  };

  const calendarNlNL = {
      Today: 'Vandaag',
      Month: 'Maand',
      Week: 'Week',
      Day: 'Dag',
      'Select View': 'Kies weergave',
      events: 'gebeurtenissen',
      event: 'gebeurtenis',
      'No events': 'Geen gebeurtenissen',
      'Next period': 'Volgende periode',
      'Previous period': 'Vorige periode',
      to: 'tot', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Evenementen van een hele dag en meerdere dagen',
      'Link to {{n}} more events on {{date}}': 'Link naar {{n}} meer evenementen op {{date}}',
      'Link to 1 more event on {{date}}': 'Link naar 1 meer evenement op {{date}}',
  };

  const datePickerNlNL = {
      Date: 'Datum',
      'MM/DD/YYYY': 'DD-MM-JJJJ',
      'Next month': 'Volgende maand',
      'Previous month': 'Vorige maand',
      'Choose Date': 'Kies datum',
  };

  const nlNL = {
      ...datePickerNlNL,
      ...calendarNlNL,
  };

  const datePickerPtBR = {
      Date: 'Data',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Mês seguinte',
      'Previous month': 'Mês anterior',
      'Choose Date': 'Escolha uma data',
  };

  const calendarPtBR = {
      Today: 'Hoje',
      Month: 'Mês',
      Week: 'Semana',
      Day: 'Dia',
      'Select View': 'Selecione uma visualização',
      events: 'eventos',
      event: 'evento',
      'No events': 'Sem eventos',
      'Next period': 'Período seguinte',
      'Previous period': 'Período anterior',
      to: 'a', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Dia inteiro e eventos de vários dias',
      'Link to {{n}} more events on {{date}}': 'Link para mais {{n}} eventos em {{date}}',
      'Link to 1 more event on {{date}}': 'Link para mais 1 evento em {{date}}',
  };

  const ptBR = {
      ...datePickerPtBR,
      ...calendarPtBR,
  };

  const datePickerSkSK = {
      Date: 'Dátum',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Ďalší mesiac',
      'Previous month': 'Predchádzajúci mesiac',
      'Choose Date': 'Vyberte dátum',
  };

  const calendarSkSK = {
      Today: 'Dnes',
      Month: 'Mesiac',
      Week: 'Týždeň',
      Day: 'Deň',
      'Select View': 'Vyberte zobrazenie',
      events: 'udalosti',
      event: 'udalosť',
      'No events': 'Žiadne udalosti',
      'Next period': 'Ďalšie obdobie',
      'Previous period': 'Predchádzajúce obdobie',
      to: 'do', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Celodenné a viacdňové udalosti',
      'Link to {{n}} more events on {{date}}': 'Odkaz na {{n}} ďalších udalostí dňa {{date}}',
      'Link to 1 more event on {{date}}': 'Odkaz na 1 ďalšiu udalosť dňa {{date}}',
  };

  const skSK = {
      ...datePickerSkSK,
      ...calendarSkSK,
  };

  const datePickerMkMK = {
      Date: 'Датум',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Следен месец',
      'Previous month': 'Претходен месец',
      'Choose Date': 'Избери Датум',
  };

  const calendarMkMK = {
      Today: 'Денес',
      Month: 'Месец',
      Week: 'Недела',
      Day: 'Ден',
      'Select View': 'Избери Преглед',
      events: 'настани',
      event: 'настан',
      'No events': 'Нема настани',
      'Next period': 'Следен период',
      'Previous period': 'Претходен период',
      to: 'до', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Целодневни и повеќедневни настани',
      'Link to {{n}} more events on {{date}}': 'Линк до {{n}} повеќе настани на {{date}}',
      'Link to 1 more event on {{date}}': 'Линк до 1 повеќе настан на {{date}}',
  };

  const mkMK = {
      ...datePickerMkMK,
      ...calendarMkMK,
  };

  const datePickerTrTR = {
      Date: 'Tarih',
      'MM/DD/YYYY': 'GG/AA/YYYY',
      'Next month': 'Sonraki ay',
      'Previous month': 'Önceki ay',
      'Choose Date': 'Tarih Seç',
  };

  const calendarTrTR = {
      Today: 'Bugün',
      Month: 'Aylık',
      Week: 'Haftalık',
      Day: 'Günlük',
      'Select View': 'Görünüm Seç',
      events: 'etkinlikler',
      event: 'etkinlik',
      'No events': 'Etkinlik yok',
      'Next period': 'Sonraki dönem',
      'Previous period': 'Önceki dönem',
      to: 'dan', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Tüm gün ve çoklu gün etkinlikleri',
      'Link to {{n}} more events on {{date}}': '{{date}} tarihinde {{n}} etkinliğe bağlantı',
      'Link to 1 more event on {{date}}': '{{date}} tarihinde 1 etkinliğe bağlantı',
  };

  const trTR = {
      ...datePickerTrTR,
      ...calendarTrTR,
  };

  const datePickerKyKG = {
      Date: 'Датасы',
      'MM/DD/YYYY': 'АА/КК/ЖЖЖЖ',
      'Next month': 'Кийинки ай',
      'Previous month': 'Өткөн ай',
      'Choose Date': 'Күндү тандаңыз',
  };

  const calendarKyKG = {
      Today: 'Бүгүн',
      Month: 'Ай',
      Week: 'Апта',
      Day: 'Күн',
      'Select View': 'Көрүнүштү тандаңыз',
      events: 'Окуялар',
      event: 'Окуя',
      'No events': 'Окуя жок',
      'Next period': 'Кийинки мезгил',
      'Previous period': 'Өткөн мезгил',
      to: 'чейин', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Күн бою жана бир нече күн катары менен болгон окуялар',
      'Link to {{n}} more events on {{date}}': '{{date}} күнүндө {{n}} окуяга байланыш',
      'Link to 1 more event on {{date}}': '{{date}} күнүндө 1 окуяга байланыш',
  };

  const kyKG = {
      ...datePickerKyKG,
      ...calendarKyKG,
  };

  const datePickerIdID = {
      Date: 'Tanggal',
      'MM/DD/YYYY': 'DD.MM.YYYY',
      'Next month': 'Bulan depan',
      'Previous month': 'Bulan sebelumnya',
      'Choose Date': 'Pilih tanggal',
  };

  const calendarIdID = {
      Today: 'Hari Ini',
      Month: 'Bulan',
      Week: 'Minggu',
      Day: 'Hari',
      'Select View': 'Pilih tampilan',
      events: 'Acara',
      event: 'Acara',
      'No events': 'Tidak ada acara',
      'Next period': 'Periode selanjutnya',
      'Previous period': 'Periode sebelumnya',
      to: 'sampai', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Sepanjang hari dan acara beberapa hari ',
      'Link to {{n}} more events on {{date}}': 'Tautan ke {{n}} acara lainnya pada {{date}}',
      'Link to 1 more event on {{date}}': 'Tautan ke 1 acara lainnya pada {{date}}',
  };

  const idID = {
      ...datePickerIdID,
      ...calendarIdID,
  };

  const datePickerCsCZ = {
      Date: 'Datum',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Další měsíc',
      'Previous month': 'Předchozí měsíc',
      'Choose Date': 'Vyberte datum',
  };

  const calendarCsCZ = {
      Today: 'Dnes',
      Month: 'Měsíc',
      Week: 'Týden',
      Day: 'Den',
      'Select View': 'Vyberte zobrazení',
      events: 'události',
      event: 'událost',
      'No events': 'Žádné události',
      'Next period': 'Příští období',
      'Previous period': 'Předchozí období',
      to: 'do', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Celodenní a vícedenní události',
      'Link to {{n}} more events on {{date}}': 'Odkaz na {{n}} dalších událostí dne {{date}}',
      'Link to 1 more event on {{date}}': 'Odkaz na 1 další událost dne {{date}}',
  };

  const csCZ = {
      ...datePickerCsCZ,
      ...calendarCsCZ,
  };

  const datePickerEtEE = {
      Date: 'Kuupäev',
      'MM/DD/YYYY': 'PP.KK.AAAA',
      'Next month': 'Järgmine kuu',
      'Previous month': 'Eelmine kuu',
      'Choose Date': 'Vali kuupäev',
  };

  const calendarEtEE = {
      Today: 'Täna',
      Month: 'Kuu',
      Week: 'Nädal',
      Day: 'Päev',
      'Select View': 'Vali vaade',
      events: 'sündmused',
      event: 'sündmus',
      'No events': 'Pole sündmusi',
      'Next period': 'Järgmine periood',
      'Previous period': 'Eelmine periood',
      to: 'kuni',
      'Full day- and multiple day events': 'Täispäeva- ja mitmepäevasündmused',
      'Link to {{n}} more events on {{date}}': 'Link {{n}} rohkematele sündmustele kuupäeval {{date}}',
      'Link to 1 more event on {{date}}': 'Link ühele lisasündmusele kuupäeval {{date}}',
  };

  const etEE = {
      ...datePickerEtEE,
      ...calendarEtEE,
  };

  const datePickerUkUA = {
      Date: 'Дата',
      'MM/DD/YYYY': 'ММ/ДД/РРРР',
      'Next month': 'Наступний місяць',
      'Previous month': 'Минулий місяць',
      'Choose Date': 'Виберіть дату',
  };

  const calendarUkUA = {
      Today: 'Сьогодні',
      Month: 'Місяць',
      Week: 'Тиждень',
      Day: 'День',
      'Select View': 'Виберіть вигляд',
      events: 'події',
      event: 'подія',
      'No events': 'Немає подій',
      'Next period': 'Наступний період',
      'Previous period': 'Минулий період',
      to: 'по', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Події на цілий день і кілька днів поспіль',
      'Link to {{n}} more events on {{date}}': 'Посилання на {{n}} додаткові події на {{date}}',
      'Link to 1 more event on {{date}}': 'Посилання на 1 додаткову подію на {{date}}',
  };

  const ukUA = {
      ...datePickerUkUA,
      ...calendarUkUA,
  };

  const datePickerSrLatnRS = {
      Date: 'Datum',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Sledeći mesec',
      'Previous month': 'Prethodni mesec',
      'Choose Date': 'Izaberite datum',
  };

  const calendarSrLatnRS = {
      Today: 'Danas',
      Month: 'Mesec',
      Week: 'Nedelja',
      Day: 'Dan',
      'Select View': 'Odaberite pregled',
      events: 'Događaji',
      event: 'Događaj',
      'No events': 'Nema događaja',
      'Next period': 'Naredni period',
      'Previous period': 'Prethodni period',
      to: 'do', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Celodnevni i višednevni događaji',
      'Link to {{n}} more events on {{date}}': 'Link do još {{n}} događaja na {{date}}',
      'Link to 1 more event on {{date}}': 'Link do jednog događaja na {{date}}',
  };

  const srLatnRS = {
      ...datePickerSrLatnRS,
      ...calendarSrLatnRS,
  };

  const datePickerCaES = {
      Date: 'Data',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Següent mes',
      'Previous month': 'Mes anterior',
      'Choose Date': 'Selecciona una data',
  };

  const calendarCaES = {
      Today: 'Avui',
      Month: 'Mes',
      Week: 'Setmana',
      Day: 'Dia',
      'Select View': 'Selecciona una vista',
      events: 'Esdeveniments',
      event: 'Esdeveniment',
      'No events': 'Sense esdeveniments',
      'Next period': 'Següent període',
      'Previous period': 'Període anterior',
      to: 'a', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Esdeveniments de dia complet i de múltiples dies',
      'Link to {{n}} more events on {{date}}': 'Enllaç a {{n}} esdeveniments més el {{date}}',
      'Link to 1 more event on {{date}}': 'Enllaç a 1 esdeveniment més el {{date}}',
  };

  const caES = {
      ...datePickerCaES,
      ...calendarCaES,
  };

  const datePickerSrRS = {
      Date: 'Датум',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Следећи месец',
      'Previous month': 'Претходни месец',
      'Choose Date': 'Изаберите Датум',
  };

  const calendarSrRS = {
      Today: 'Данас',
      Month: 'Месец',
      Week: 'Недеља',
      Day: 'Дан',
      'Select View': 'Изаберите преглед',
      events: 'Догађаји',
      event: 'Догађај',
      'No events': 'Нема догађаја',
      'Next period': 'Следећи период',
      'Previous period': 'Претходни период',
      to: 'да', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Целодневни и вишедневни догађаји',
      'Link to {{n}} more events on {{date}}': 'Линк до још {{n}} догађаја на {{date}}',
      'Link to 1 more event on {{date}}': 'Линк до још 1 догађаја {{date}}',
  };

  const srRS = {
      ...datePickerSrRS,
      ...calendarSrRS,
  };

  const datePickerLtLT = {
      Date: 'Data',
      'MM/DD/YYYY': 'MMMM-MM-DD',
      'Next month': 'Kitas mėnuo',
      'Previous month': 'Ankstesnis mėnuo',
      'Choose Date': 'Pasirinkite datą',
  };

  const calendarLtLT = {
      Today: 'Šiandien',
      Month: 'Mėnuo',
      Week: 'Savaitė',
      Day: 'Diena',
      'Select View': 'Pasirinkite vaizdą',
      events: 'įvykiai',
      event: 'įvykis',
      'No events': 'Įvykių nėra',
      'Next period': 'Kitas laikotarpis',
      'Previous period': 'Ankstesnis laikotarpis',
      to: 'iki', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Visos dienos ir kelių dienų įvykiai',
      'Link to {{n}} more events on {{date}}': 'Nuoroda į dar {{n}} įvykius {{date}}',
      'Link to 1 more event on {{date}}': 'Nuoroda į dar 1 vieną įvykį {{date}}',
  };

  const ltLT = {
      ...datePickerLtLT,
      ...calendarLtLT,
  };

  const datePickerHrHR = {
      Date: 'Datum',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Sljedeći mjesec',
      'Previous month': 'Prethodni mjesec',
      'Choose Date': 'Izaberite datum',
  };

  const calendarHrHR = {
      Today: 'Danas',
      Month: 'Mjesec',
      Week: 'Nedjelja',
      Day: 'Dan',
      'Select View': 'Odaberite pregled',
      events: 'Događaji',
      event: 'Događaj',
      'No events': 'Nema događaja',
      'Next period': 'Sljedeći period',
      'Previous period': 'Prethodni period',
      to: 'do', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Cjelodnevni i višednevni događaji',
      'Link to {{n}} more events on {{date}}': 'Link do još {{n}} događaja na {{date}}',
      'Link to 1 more event on {{date}}': 'Link do još jednog događaja na {{date}}',
  };

  const hrHR = {
      ...datePickerHrHR,
      ...calendarHrHR,
  };

  class InvalidLocaleError extends Error {
      constructor(locale) {
          super(`Invalid locale: ${locale}`);
      }
  }

  const translate = (locale, languages) => (key, translationVariables) => {
      if (!/^[a-z]{2}-[A-Z]{2}$/.test(locale.value) &&
          'sr-Latn-RS' !== locale.value) {
          throw new InvalidLocaleError(locale.value);
      }
      const deHyphenatedLocale = locale.value.replaceAll('-', '');
      const language = languages.value[deHyphenatedLocale];
      if (!language)
          return key;
      let translation = language[key] || key;
      Object.keys(translationVariables || {}).forEach((variable) => {
          const value = String(translationVariables === null || translationVariables === void 0 ? void 0 : translationVariables[variable]);
          if (!value)
              return;
          translation = translation.replace(`{{${variable}}}`, value);
      });
      return translation;
  };

  /* eslint-disable max-lines */
  const translations = {
      deDE,
      enUS,
      itIT,
      enGB,
      svSE,
      zhCN,
      zhTW,
      jaJP,
      ruRU,
      koKR,
      frFR,
      daDK,
      mkMK,
      plPL,
      esES,
      nlNL,
      ptBR,
      skSK,
      trTR,
      kyKG,
      idID,
      csCZ,
      etEE,
      ukUA,
      caES,
      srLatnRS,
      srRS,
      ltLT,
      hrHR,
  };

  const createAppSingleton = (config = {}) => {
      const configInternal = new ConfigBuilder()
          .withFirstDayOfWeek(config.firstDayOfWeek)
          .withLocale(config.locale)
          .withMin(config.min)
          .withMax(config.max)
          .withPlacement(config.placement)
          .withListeners(config.listeners)
          .withStyle(config.style)
          .withTeleportTo(config.teleportTo)
          .withLabel(config.label)
          .withName(config.name)
          .withDisabled(config.disabled)
          .build();
      const timeUnitsImpl = new TimeUnitsBuilder()
          .withConfig(configInternal)
          .build();
      return new DatePickerAppSingletonBuilder()
          .withConfig(configInternal)
          .withDatePickerState(createDatePickerState(configInternal, config.selectedDate))
          .withTimeUnitsImpl(timeUnitsImpl)
          .withTranslate(translate(configInternal.locale, signals.signal(translations)))
          .build();
  };
  const createDatePicker = (config) => {
      const $app = createAppSingleton(config);
      return new DatePickerApp($app);
  };

  function DatePicker({ initialValue, label, onChange, isDarkMode, name, width, disabled, min, max, locale, }) {
      const [datePickerId] = hooks.useState(randomStringId$2);
      const [datePicker] = hooks.useState(() => createDatePicker({
          selectedDate: initialValue || toDateString$2(new Date()),
          teleportTo: document.body,
          label,
          name,
          min,
          max,
          locale,
          listeners: {
              onChange,
              onEscapeKeyDown: ($app) => {
                  window.__sx_escapeKeyDownBlocker__ = true;
                  $app.datePickerState.close();
                  setTimeout(() => {
                      window.__sx_escapeKeyDownBlocker__ = false;
                  }, 10);
              },
          },
          style: {
              dark: isDarkMode,
              fullWidth: width === '100%',
          },
      }));
      hooks.useEffect(() => {
          const datePickerEl = document.getElementById(datePickerId);
          if (datePickerEl) {
              datePicker.render(datePickerEl);
          }
      }, []);
      hooks.useEffect(() => {
          datePicker.disabled = disabled || false;
      }, [disabled]);
      hooks.useEffect(() => {
          if (!initialValue)
              return;
          datePicker.value = initialValue;
      }, [initialValue]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { className: 'sx__date-picker-outer-wrapper', id: datePickerId }) }));
  }

  function Textarea({ initialValue, onChange, label, name, errorMessage, }) {
      const [inputValue, setInputValue] = hooks.useState(initialValue);
      const handleInput = (newValue) => {
          setInputValue(newValue);
          onChange(newValue);
      };
      const BASE_WRAPPER_CLASS = 'sx__textarea-wrapper';
      const [wrapperClasses, setWrapperClasses] = hooks.useState([BASE_WRAPPER_CLASS]);
      hooks.useEffect(() => {
          if (inputValue.length > 0) {
              setWrapperClasses([BASE_WRAPPER_CLASS, 'sx__has-value']);
          }
          else {
              setWrapperClasses([BASE_WRAPPER_CLASS]);
          }
      }, [inputValue]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { className: wrapperClasses.join(' '), children: [jsxRuntime.jsx("textarea", { className: 'sx__textarea-input', value: inputValue, onInput: (e) => handleInput(e.currentTarget.value), id: "last_name", type: "text", name: name }), jsxRuntime.jsx("label", { className: 'sx__textarea-label', htmlFor: name, children: label })] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
  }

  function AppCheckbox({ initialValue, label, onChange, colorPrimary }) {
      const checkboxId = randomStringId$2();
      const [isChecked, setIsChecked] = hooks.useState(initialValue || false);
      const [isReady, setIsReady] = hooks.useState(!colorPrimary);
      const handleOnInput = (event) => {
          setIsChecked(event.target.checked);
          onChange(event.target.checked);
      };
      hooks.useEffect(() => {
          const el = document.getElementById(checkboxId);
          if (!el)
              return;
          if (colorPrimary) {
              el.style.setProperty('--sx-color-primary', colorPrimary);
              setIsReady(true);
          }
      }, []);
      return (jsxRuntime.jsx(preact.Fragment, { children: jsxRuntime.jsx("label", { id: checkboxId, className: "sx__app-checkbox", children: isReady && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("input", { type: "checkbox", checked: isChecked, onInput: handleOnInput }), jsxRuntime.jsx("span", { children: label })] })) }) }));
  }

  const AppContext = preact.createContext({});

  /**
   * Can be used for generating a random id for an entity
   * Should, however, never be used in potentially resource intense loops,
   * since the performance cost of this compared to new Date().getTime() is ca x4 in v8
   * */
  const randomStringId = () => 's' + Math.random().toString(36).substring(2, 11);

  function AppInput() {
      var _a;
      const $app = compat.useContext(AppContext);
      const inputId = randomStringId();
      const wrapperId = randomStringId();
      const [wrapperClasses, setWrapperClasses] = hooks.useState([]);
      compat.useEffect(() => {
          const newClasses = ['sx__time-input-wrapper'];
          if ($app.timePickerState.isOpen.value)
              newClasses.push('sx__time-input--active');
          setWrapperClasses(newClasses);
      }, [$app.timePickerState.isOpen.value]);
      const openPopup = () => {
          if (!$app.config.teleportTo.value) {
              $app.timePickerState.isOpen.value = true;
              return;
          }
          const inputWrapperElement = document.getElementById(wrapperId);
          $app.timePickerState.inputWrapperElement.value =
              inputWrapperElement instanceof HTMLDivElement
                  ? inputWrapperElement
                  : undefined;
          $app.timePickerState.isOpen.value = true;
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { id: wrapperId, className: wrapperClasses.join(' '), children: [jsxRuntime.jsx("label", { htmlFor: inputId, className: "sx__time-input-label", children: (_a = $app.config.label.value) !== null && _a !== void 0 ? _a : 'Time' }), jsxRuntime.jsx("input", { value: $app.timePickerState.currentTimeDisplayedValue.value, readOnly: true, id: inputId, name: $app.config.name.value ? $app.config.name.value : 'time', className: "sx__time-picker-input", type: "text", onFocus: openPopup })] }) }));
  }

  /**
   * Push a task to the end of the current call stack
   * */
  const nextTick = (cb) => {
      setTimeout(() => {
          cb();
      });
  };

  function TimeInput({ initialValue, onChange, inputRef, nextTabIndexRef, validRange, }) {
      const [inputValue, setInputValue] = hooks.useState(initialValue);
      const [tabBlocker, setTabBlocker] = hooks.useState(false);
      const handleInput = (e) => {
          if (!(e.target instanceof HTMLInputElement))
              return;
          setInputValue(e.target.value);
      };
      compat.useEffect(() => {
          var _a;
          onChange(inputValue);
          if (tabBlocker)
              return;
          if (inputValue.length === 2 &&
              nextTabIndexRef &&
              'current' in nextTabIndexRef) {
              (_a = nextTabIndexRef.current) === null || _a === void 0 ? void 0 : _a.focus();
              if (nextTabIndexRef.current instanceof HTMLInputElement) {
                  nextTabIndexRef.current.select();
              }
          }
      }, [inputValue]);
      const handleOnBlur = () => {
          const [min, max] = validRange;
          const value = +inputValue;
          if (value < min || value > max || isNaN(value)) {
              setInputValue(min < 10 ? `0${min}` : String(min));
              return;
          }
          if (inputValue.length === 1) {
              setInputValue(`0${inputValue}`);
          }
      };
      const incrementOrDecrementOnKeyDown = (e) => {
          if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
              e.preventDefault();
              const [min, max] = validRange;
              const value = +inputValue;
              const newValue = e.key === 'ArrowUp' ? value + 1 : value - 1;
              if (newValue < min || newValue > max)
                  return;
              setInputValue(newValue < 10 ? `0${newValue}` : String(newValue));
              setTabBlocker(true);
              nextTick(() => setTabBlocker(false));
          }
      };
      return (jsxRuntime.jsx("input", { ref: inputRef, maxLength: 2, className: "sx__time-input", type: "text", onKeyDown: incrementOrDecrementOnKeyDown, value: inputValue, onInput: handleInput, onBlur: handleOnBlur }));
  }

  const isScrollable$1 = (el) => {
      if (el) {
          const hasScrollableContent = el.scrollHeight > el.clientHeight;
          const overflowYStyle = window.getComputedStyle(el).overflowY;
          const isOverflowHidden = overflowYStyle.indexOf('hidden') !== -1;
          return hasScrollableContent && !isOverflowHidden;
      }
      return true;
  };
  const getScrollableParents$1 = (el, acc = []) => {
      if (!el ||
          el === document.body ||
          el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          acc.push(window);
          return acc;
      }
      if (isScrollable$1(el)) {
          acc.push(el);
      }
      return getScrollableParents$1((el.assignedSlot
          ? el.assignedSlot.parentNode
          : el.parentNode), acc);
  };

  const convert12HourTo24HourTimeString = (hoursValue, minutesValue, $app) => {
      const hoursInt = Number(hoursValue);
      const isAM = $app.timePickerState.isAM.value;
      if (isAM && hoursInt === 12) {
          $app.timePickerState.currentTime.value = `00:${minutesValue}`;
      }
      else if (!isAM && hoursInt < 12) {
          $app.timePickerState.currentTime.value = `${hoursInt + 12}:${minutesValue}`;
      }
      else {
          $app.timePickerState.currentTime.value = `${hoursValue}:${minutesValue}`;
      }
  };

  function AppPopup() {
      const $app = compat.useContext(AppContext);
      const POPUP_CLASS_NAME = 'sx__time-picker-popup';
      const INPUT_WRAPPER_CLASS_NAME = 'sx__time-input-wrapper';
      const hoursRef = compat.useRef(null);
      const minutesRef = compat.useRef(null);
      const OKButtonRef = compat.useRef(null);
      const [classList, setClassList] = hooks.useState([
          POPUP_CLASS_NAME,
          $app.config.placement,
      ]);
      hooks.useEffect(() => {
          setClassList([
              POPUP_CLASS_NAME,
              $app.config.placement,
              $app.config.dark.value ? 'is-dark' : '',
          ]);
      }, [$app.config.dark.value, $app.config.placement.value]);
      const getInitialStart12Hour = (hours) => {
          const hoursInt = Number(hours);
          if (hoursInt === 0)
              return '12';
          if (hoursInt > 12)
              return String(hoursInt - 12);
          return hours;
      };
      const [initialStart, initialEnd] = $app.timePickerState.currentTime.value.split(':');
      const [hoursValue, setHoursValue] = hooks.useState($app.config.is12Hour.value
          ? getInitialStart12Hour(initialStart)
          : initialStart);
      const [minutesValue, setMinutesValue] = hooks.useState(initialEnd);
      const clickOutsideListener = (event) => {
          const target = event.target;
          if (![POPUP_CLASS_NAME, INPUT_WRAPPER_CLASS_NAME].some((className) => target.closest(`.${className}`))) {
              $app.timePickerState.isOpen.value = false;
          }
      };
      const escapeKeyListener = (e) => {
          if (e.key === 'Escape') {
              if (typeof $app.config.onEscapeKeyDown.value === 'function') {
                  $app.config.onEscapeKeyDown.value($app);
              }
              else {
                  $app.timePickerState.isOpen.value = false;
              }
          }
      };
      hooks.useEffect(() => {
          var _a, _b;
          (_a = hoursRef.current) === null || _a === void 0 ? void 0 : _a.focus();
          (_b = hoursRef.current) === null || _b === void 0 ? void 0 : _b.select();
          document.addEventListener('click', clickOutsideListener);
          document.addEventListener('keydown', escapeKeyListener);
          return () => {
              document.removeEventListener('click', clickOutsideListener);
              document.removeEventListener('keydown', escapeKeyListener);
          };
      }, []);
      const handleAccept = () => {
          if ($app.config.is12Hour.value) {
              convert12HourTo24HourTimeString(hoursValue, minutesValue, $app);
          }
          else {
              $app.timePickerState.currentTime.value = `${hoursValue}:${minutesValue}`;
          }
          $app.timePickerState.isOpen.value = false;
      };
      const remSize = Number(getComputedStyle(document.documentElement).fontSize.split('px')[0]);
      const popupHeight = 362;
      const popupWidth = 332;
      const getFixedPositionStyles = () => {
          var _a, _b, _c;
          const inputRect = (_a = $app.timePickerState.inputWrapperElement.value) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
          if (!inputRect)
              return undefined;
          return {
              top: ((_b = $app.config.placement.value) === null || _b === void 0 ? void 0 : _b.includes('bottom'))
                  ? inputRect.height + inputRect.y + 1 // 1px border
                  : inputRect.y - remSize - popupHeight, // subtract remsize to leave room for label text
              left: ((_c = $app.config.placement.value) === null || _c === void 0 ? void 0 : _c.includes('start'))
                  ? inputRect.x
                  : inputRect.x + inputRect.width - popupWidth,
              width: popupWidth,
              position: 'fixed',
          };
      };
      const [fixedPositionStyle, setFixedPositionStyle] = hooks.useState(getFixedPositionStyles());
      hooks.useEffect(() => {
          const inputWrapperEl = $app.timePickerState.inputWrapperElement.value;
          if (!inputWrapperEl)
              return;
          const scrollableParents = getScrollableParents$1(inputWrapperEl);
          scrollableParents.forEach((parent) => parent.addEventListener('scroll', () => setFixedPositionStyle(getFixedPositionStyles())));
          return () => {
              scrollableParents.forEach((parent) => parent.removeEventListener('scroll', () => setFixedPositionStyle(getFixedPositionStyles())));
          };
      }, []);
      return (jsxRuntime.jsxs("div", { className: classList.join(' '), style: $app.config.teleportTo.value ? fixedPositionStyle : undefined, children: [jsxRuntime.jsx("div", { className: "sx__time-picker-popup-label", children: "Select time" }), jsxRuntime.jsxs("div", { className: "sx__time-picker-time-inputs", children: [jsxRuntime.jsx(TimeInput, { initialValue: hoursValue, onChange: (newHours) => setHoursValue(newHours), inputRef: hoursRef, nextTabIndexRef: minutesRef, validRange: $app.config.is12Hour.value ? [1, 12] : [0, 23] }), jsxRuntime.jsx("span", { className: "sx__time-picker-colon", children: ":" }), jsxRuntime.jsx(TimeInput, { initialValue: minutesValue, onChange: (newMinutes) => setMinutesValue(newMinutes), inputRef: minutesRef, validRange: [0, 59], nextTabIndexRef: OKButtonRef }), $app.config.is12Hour.value && (jsxRuntime.jsxs("div", { className: "sx__time-picker-12-hour-switches", children: [jsxRuntime.jsx("button", { type: "button", className: `sx__time-picker-12-hour-switch${$app.timePickerState.isAM.value ? ' is-selected' : ''}`, onClick: () => ($app.timePickerState.isAM.value = true), children: "AM" }), jsxRuntime.jsx("button", { type: "button", className: `sx__time-picker-12-hour-switch${!$app.timePickerState.isAM.value ? ' is-selected' : ''}`, onClick: () => ($app.timePickerState.isAM.value = false), children: "PM" })] }))] }), jsxRuntime.jsxs("div", { class: "sx__time-picker-actions", children: [jsxRuntime.jsx("button", { type: "button", class: "sx__time-picker-action sx__ripple sx__button-cancel", onClick: () => ($app.timePickerState.isOpen.value = false), children: "Cancel" }), jsxRuntime.jsx("button", { ref: OKButtonRef, type: "button", class: "sx__time-picker-action sx__ripple sx__button-accept", onClick: handleAccept, children: "OK" })] })] }));
  }

  function TimePickerWrapper({ $app }) {
      const baseClassList = [
          'sx__time-picker-wrapper',
          $app.config.is12Hour.value ? 'is-12-hour' : '',
      ];
      const [classList, setClassList] = hooks.useState(baseClassList);
      hooks.useEffect(() => {
          setClassList([...baseClassList, $app.config.dark.value ? 'is-dark' : '']);
      }, [$app.config.dark.value]);
      let AppPopupJSX = jsxRuntime.jsx(AppPopup, {});
      if ($app.config.teleportTo.value) {
          AppPopupJSX = compat.createPortal(AppPopupJSX, $app.config.teleportTo.value);
      }
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { className: classList.join(' '), children: jsxRuntime.jsxs(AppContext.Provider, { value: $app, children: [jsxRuntime.jsx(AppInput, {}), $app.timePickerState.isOpen.value && AppPopupJSX] }) }) }));
  }

  class TimePickerApp {
      constructor($app) {
          Object.defineProperty(this, "$app", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: $app
          });
      }
      render(el) {
          preact.render(preact.createElement(TimePickerWrapper, {
              $app: this.$app,
          }), el);
      }
      get value() {
          return this.$app.timePickerState.currentTime.value;
      }
      set value(value) {
          this.$app.timePickerState.currentTime.value = value;
      }
  }

  const getTimePickerState = (config, is12HourClock) => {
      var _a;
      const currentTime = signals.signal((_a = config.initialValue) !== null && _a !== void 0 ? _a : '00:00');
      let wasInitialized = false;
      const handleCurrentTimeChanged = (config, currentTime) => {
          if (!wasInitialized)
              return (wasInitialized = true);
          if (config.onChange) {
              config.onChange(currentTime);
          }
      };
      signals.effect(() => {
          handleCurrentTimeChanged(config, currentTime.value);
      });
      const initialIsAM = parseInt(currentTime.value.split(':')[0]) < 12;
      const isAM = signals.signal(initialIsAM);
      return {
          isOpen: signals.signal(false),
          currentTime,
          currentTimeDisplayedValue: signals.computed(() => {
              const [hours, minutes] = currentTime.value.split(':');
              const parsedHours = parseInt(hours);
              let hoursInt = parsedHours;
              const minutesInt = parseInt(minutes);
              if (is12HourClock) {
                  hoursInt = hoursInt === 0 ? 12 : hoursInt;
                  const hours12 = hoursInt > 12 ? hoursInt - 12 : hoursInt;
                  return `${hours12}:${minutesInt.toString().padStart(2, '0')} ${parsedHours >= 12 ? 'PM' : 'AM'}`;
              }
              return `${hoursInt.toString().padStart(2, '0')}:${minutesInt.toString().padStart(2, '0')}`;
          }),
          inputWrapperElement: signals.signal(undefined),
          isAM,
      };
  };
  const createTimePickerAppContext = (config = {}) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      return ({
          config: {
              onEscapeKeyDown: signals.signal((_a = config.onEscapeKeyDown) !== null && _a !== void 0 ? _a : undefined),
              dark: signals.signal((_b = config.dark) !== null && _b !== void 0 ? _b : false),
              placement: signals.signal((_c = config.placement) !== null && _c !== void 0 ? _c : 'bottom-start'),
              teleportTo: signals.signal((_d = config.teleportTo) !== null && _d !== void 0 ? _d : null),
              label: signals.signal((_e = config.label) !== null && _e !== void 0 ? _e : null),
              is12Hour: signals.signal((_f = config.is12Hour) !== null && _f !== void 0 ? _f : false),
              name: signals.signal((_g = config.name) !== null && _g !== void 0 ? _g : ''),
          },
          timePickerState: getTimePickerState(config, (_h = config.is12Hour) !== null && _h !== void 0 ? _h : false),
      });
  };
  const createTimePicker = (config = {}) => {
      return new TimePickerApp(createTimePickerAppContext(config));
  };

  function TimePicker({ initialValue, label, name, onChange, placement, isDarkMode, is12Hour, }) {
      const [timePickerId] = hooks.useState(randomStringId$2);
      const [timePicker] = hooks.useState(createTimePicker({
          initialValue: initialValue || '00:00',
          teleportTo: document.body,
          label,
          name,
          onChange,
          placement: placement || 'bottom-start',
          dark: isDarkMode,
          is12Hour: is12Hour || false,
          onEscapeKeyDown: ($app) => {
              window.__sx_escapeKeyDownBlocker__ = true;
              $app.timePickerState.isOpen.value = false;
              setTimeout(() => {
                  window.__sx_escapeKeyDownBlocker__ = false;
              }, 10);
          },
      }));
      hooks.useEffect(() => {
          const timePickerElement = document.getElementById(timePickerId);
          if (timePickerElement) {
              timePicker.render(timePickerElement);
          }
      }, []);
      hooks.useEffect(() => {
          if (!initialValue)
              return;
          timePicker.value = initialValue;
      }, [initialValue]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { id: timePickerId }) }));
  }

  const isScrollable = (el) => {
      if (el) {
          const hasScrollableContent = el.scrollHeight > el.clientHeight;
          const overflowYStyle = window.getComputedStyle(el).overflowY;
          const isOverflowHidden = overflowYStyle.indexOf('hidden') !== -1;
          return hasScrollableContent && !isOverflowHidden;
      }
      return true;
  };
  const getScrollableParents = (el, acc = []) => {
      if (!el ||
          el === document.body ||
          el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          acc.push(window);
          return acc;
      }
      if (isScrollable(el)) {
          acc.push(el);
      }
      return getScrollableParents((el.assignedSlot
          ? el.assignedSlot.parentNode
          : el.parentNode), acc);
  };

  function AppCombobox({ items, label, initialSelectedItems, onChange, name, isDarkMode, errorMessage, }) {
      const wrapperId = randomStringId$2();
      const listId = randomStringId$2();
      const inputId = randomStringId$2();
      const [wrapperRect, setWrapperRect] = hooks.useState({
          x: 0,
          y: 0,
          height: 0,
          width: 0,
      });
      const [isOpen, setIsOpen] = hooks.useState(false);
      const [listClasses, setListClasses] = hooks.useState('sx__app-combobox__list');
      const [filteredItems, setFilteredItems] = hooks.useState(items);
      const [selectedItems, setSelectedItems] = hooks.useState(initialSelectedItems || []);
      hooks.useEffect(() => {
          const baseClasses = ['sx__app-combobox__list'];
          if (isDarkMode)
              baseClasses.push('is-dark');
          if (isOpen)
              baseClasses.push('is-open');
          setListClasses(baseClasses.join(' '));
      }, [isOpen, isDarkMode]);
      const setPopupPosition = (wrapperEl) => {
          setWrapperRect({
              x: wrapperEl.getBoundingClientRect().left,
              y: wrapperEl.getBoundingClientRect().top,
              height: wrapperEl.getBoundingClientRect().height,
              width: wrapperEl.getBoundingClientRect().width,
          });
      };
      const toggleOpen = () => {
          if (isOpen) {
              setIsOpen(false);
              return;
          }
          const wrapperEl = document.getElementById(wrapperId);
          const inputEl = document.getElementById(inputId);
          if (!wrapperEl || !inputEl)
              return;
          inputEl.focus();
          setIsOpen(true);
          setPopupPosition(wrapperEl);
          const scrollableParents = getScrollableParents(wrapperEl);
          const boundSetPosition = setPopupPosition.bind(null, wrapperEl);
          const listClickOutsideListener = (event) => {
              const target = event.target;
              if (target instanceof HTMLElement && !target.closest(`#${listId}`)) {
                  setIsOpen(false);
                  document.removeEventListener('click', listClickOutsideListener);
                  scrollableParents.forEach((parentEl) => parentEl.removeEventListener('scroll', boundSetPosition));
              }
          };
          setTimeout(() => {
              scrollableParents.forEach((parentEl) => parentEl.addEventListener('scroll', boundSetPosition));
              document.addEventListener('click', listClickOutsideListener);
          }, 10);
      };
      const handleBackSpace = () => {
          const lastItem = selectedItems[selectedItems.length - 1];
          setSelectedItems(selectedItems.filter((item) => item !== lastItem));
      };
      const handleInput = (e) => {
          const target = e.target;
          if (!(target instanceof HTMLInputElement))
              return;
          const value = target.value;
          if (value.length === 0) {
              setFilteredItems(items.filter((item) => !selectedItems.includes(item)));
              return;
          }
          const filtered = items.filter((item) => {
              return (item.toLowerCase().includes(value.toLowerCase()) &&
                  !selectedItems.includes(item));
          });
          setFilteredItems(filtered);
      };
      const clickOnItem = (item) => {
          setSelectedItems([...selectedItems, item]);
          const inputEl = document.getElementById(inputId);
          if (!(inputEl instanceof HTMLInputElement))
              return;
          inputEl.value = '';
      };
      hooks.useEffect(() => {
          const filtered = items.filter((item) => !selectedItems.includes(item));
          setFilteredItems(filtered);
          onChange(selectedItems);
      }, [selectedItems]);
      // @ts-ignore
      const handleKeyDown = (e) => {
          if (e.key === 'Backspace' && e.target instanceof HTMLInputElement) {
              if (e.target.value.length === 0) {
                  handleBackSpace();
              }
          }
      };
      const removeSelected = (item) => {
          setSelectedItems(selectedItems.filter((i) => i !== item));
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox-wrapper", id: wrapperId, onClick: toggleOpen, children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox__input-wrapper", children: [selectedItems.map((item, index) => (jsxRuntime.jsxs("div", { class: "sx__app-combobox__chip", children: [item, jsxRuntime.jsx("span", { className: "sx__app-combobox__chip-remove", onClick: () => removeSelected(item), style: { width: '16px', height: '16px' }, children: jsxRuntime.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { "stroke-width": "0" }), jsxRuntime.jsx("g", { "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { children: [' ', jsxRuntime.jsx("path", { d: "M19 5L4.99998 19M5.00001 5L19 19", stroke: "#fff", "stroke-width": "2.4", "stroke-linecap": "round", "stroke-linejoin": "round" }), ' '] })] }) })] }, index))), jsxRuntime.jsx("input", { id: inputId, onInput: handleInput, onKeyDown: handleKeyDown, className: "sx__app-combobox-input", type: "text", placeholder: "Search...", name: name }), jsxRuntime.jsx("label", { className: 'sx__app-combobox-label', htmlFor: name, children: label })] }), compat.createPortal(jsxRuntime.jsx("div", { id: listId, class: listClasses, style: {
                                  top: wrapperRect.y + wrapperRect.height + 1,
                                  left: wrapperRect.x,
                                  width: wrapperRect.width,
                              }, children: jsxRuntime.jsx("ul", { children: filteredItems.map((item, index) => (jsxRuntime.jsx("li", { onClick: () => clickOnItem(item), children: item }, index))) }) }), document.body)] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
  }

  const WarningSign = ({ color = '#a88d00' }) => {
      return (jsxRuntime.jsxs("svg", { fill: color, width: 24, height: 24, viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", strokeWidth: "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntime.jsx("g", { id: "SVGRepo_iconCarrier", children: jsxRuntime.jsx("path", { "fill-rule": "evenodd", d: "M23,7.44365081 L23,16.5563492 L16.5563492,23 L7.44365081,23 L1,16.5563492 L1,7.44365081 L7.44365081,1 L16.5563492,1 L23,7.44365081 Z M15.7279221,3 L8.27207794,3 L3,8.27207794 L3,15.7279221 L8.27207794,21 L15.7279221,21 L21,15.7279221 L21,8.27207794 L15.7279221,3 Z M12.0003283,17.9983464 C11.4478622,17.9983464 11,17.5506311 11,16.9983464 C11,16.4460616 11.4478622,15.9983464 12.0003283,15.9983464 C12.5527943,15.9983464 13.0006565,16.4460616 13.0006565,16.9983464 C13.0006565,17.5506311 12.5527943,17.9983464 12.0003283,17.9983464 Z M11.0029544,5.99834639 L13.0036109,5.99834639 L13.0036109,13.9983464 L11.0029544,13.9983464 L11.0029544,5.99834639 Z" }) })] }));
  };

  function AppComboboxSingleValue({ items, label, initialSelectedItem, onChange, name, isDarkMode, errorMessage, }) {
      const wrapperId = randomStringId$2();
      const listId = randomStringId$2();
      const inputId = randomStringId$2();
      const [wrapperRect, setWrapperRect] = hooks.useState({
          x: 0,
          y: 0,
          height: 0,
          width: 0,
      });
      const [isOpen, setIsOpen] = hooks.useState(false);
      const [listClasses, setListClasses] = hooks.useState('sx__app-combobox__list');
      const [filteredItems, setFilteredItems] = hooks.useState(items);
      const [selectedItem, setSelectedItem] = hooks.useState(initialSelectedItem === null || initialSelectedItem === void 0 ? void 0 : initialSelectedItem.value);
      const setPopupPosition = (wrapperEl) => {
          setWrapperRect({
              x: wrapperEl.getBoundingClientRect().left,
              y: wrapperEl.getBoundingClientRect().top,
              height: wrapperEl.getBoundingClientRect().height,
              width: wrapperEl.getBoundingClientRect().width,
          });
      };
      hooks.useEffect(() => {
          const baseClasses = ['sx__app-combobox__list'];
          if (isDarkMode)
              baseClasses.push('is-dark');
          if (isOpen)
              baseClasses.push('is-open');
          setListClasses(baseClasses.join(' '));
      }, [isOpen, isDarkMode]);
      const toggleOpen = () => {
          if (isOpen) {
              setIsOpen(false);
              return;
          }
          const wrapperEl = document.getElementById(wrapperId);
          const inputEl = document.getElementById(inputId);
          if (!wrapperEl || !inputEl)
              return;
          inputEl.focus();
          setIsOpen(true);
          setPopupPosition(wrapperEl);
          const scrollableParents = getScrollableParents(wrapperEl);
          const boundSetPosition = setPopupPosition.bind(null, wrapperEl);
          const listClickOutsideListener = (event) => {
              const target = event.target;
              if (target instanceof HTMLElement && !target.closest(`#${listId}`)) {
                  setIsOpen(false);
                  document.removeEventListener('click', listClickOutsideListener);
                  scrollableParents.forEach((parentEl) => parentEl.removeEventListener('scroll', boundSetPosition));
              }
          };
          setTimeout(() => {
              document.addEventListener('click', listClickOutsideListener);
              scrollableParents.forEach((parentEl) => parentEl.addEventListener('scroll', boundSetPosition));
          });
      };
      // @ts-ignore
      const handleInput = (e) => {
          const target = e.target;
          if (!(target instanceof HTMLInputElement))
              return;
          const value = target.value;
          if (value.length === 0) {
              setFilteredItems(items);
              return;
          }
          const filtered = items.filter((item) => {
              return { ...item }.label.toLowerCase().includes(value.toLowerCase());
          });
          setFilteredItems(filtered);
      };
      const clickOnItem = (item) => {
          var _a;
          setSelectedItem(item);
          const inputEl = document.getElementById(inputId);
          if (!(inputEl instanceof HTMLInputElement))
              return;
          inputEl.value = ((_a = items.find((i) => i.value === item)) === null || _a === void 0 ? void 0 : _a.label) || '';
      };
      const inputRef = hooks.useRef(null);
      hooks.useEffect(() => {
          var _a;
          setFilteredItems(items);
          onChange(selectedItem);
          if (!inputRef.current)
              return;
          inputRef.current.value =
              ((_a = items.find((i) => i.value === selectedItem)) === null || _a === void 0 ? void 0 : _a.label) || '';
      }, [selectedItem]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox-wrapper", id: wrapperId, onClick: toggleOpen, children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox__input-wrapper", children: [jsxRuntime.jsx("input", { ref: inputRef, id: inputId, onInput: handleInput, className: "sx__app-combobox-input", type: "text", placeholder: "Search...", name: name }), jsxRuntime.jsx("label", { className: 'sx__app-combobox-label', htmlFor: name, children: label })] }), compat.createPortal(jsxRuntime.jsx("div", { id: listId, class: listClasses, style: {
                                  top: wrapperRect.y + wrapperRect.height + 1,
                                  left: wrapperRect.x,
                                  width: wrapperRect.width,
                              }, children: jsxRuntime.jsx("ul", { children: filteredItems.map((item, index) => (jsxRuntime.jsx("li", { onClick: () => clickOnItem(item.value), children: item.label }, index))) }) }), document.body)] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
  }

  const ADDED_EVENT_CLASS_NAME = 'sx-is-added-event';

  const InfoIcon = ({ color = '#0077cc' }) => {
      return (jsxRuntime.jsxs("svg", { width: 28, height: 28, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("path", { d: "M12 16.75C11.8019 16.7474 11.6126 16.6676 11.4725 16.5275C11.3324 16.3874 11.2526 16.1981 11.25 16V11C11.25 10.8011 11.329 10.6103 11.4697 10.4697C11.6103 10.329 11.8011 10.25 12 10.25C12.1989 10.25 12.3897 10.329 12.5303 10.4697C12.671 10.6103 12.75 10.8011 12.75 11V16C12.7474 16.1981 12.6676 16.3874 12.5275 16.5275C12.3874 16.6676 12.1981 16.7474 12 16.75Z", fill: color }), jsxRuntime.jsx("path", { d: "M12 9.25C11.8019 9.24741 11.6126 9.16756 11.4725 9.02747C11.3324 8.88737 11.2526 8.69811 11.25 8.5V8C11.25 7.80109 11.329 7.61032 11.4697 7.46967C11.6103 7.32902 11.8011 7.25 12 7.25C12.1989 7.25 12.3897 7.32902 12.5303 7.46967C12.671 7.61032 12.75 7.80109 12.75 8V8.5C12.7474 8.69811 12.6676 8.88737 12.5275 9.02747C12.3874 9.16756 12.1981 9.24741 12 9.25Z", fill: color }), jsxRuntime.jsx("path", { d: "M12 21C10.22 21 8.47991 20.4722 6.99987 19.4832C5.51983 18.4943 4.36628 17.0887 3.68509 15.4442C3.0039 13.7996 2.82567 11.99 3.17294 10.2442C3.5202 8.49836 4.37737 6.89472 5.63604 5.63604C6.89472 4.37737 8.49836 3.5202 10.2442 3.17294C11.99 2.82567 13.7996 3.0039 15.4442 3.68509C17.0887 4.36628 18.4943 5.51983 19.4832 6.99987C20.4722 8.47991 21 10.22 21 12C21 14.387 20.0518 16.6761 18.364 18.364C16.6761 20.0518 14.387 21 12 21ZM12 4.5C10.5166 4.5 9.0666 4.93987 7.83323 5.76398C6.59986 6.58809 5.63856 7.75943 5.07091 9.12988C4.50325 10.5003 4.35473 12.0083 4.64411 13.4632C4.9335 14.918 5.64781 16.2544 6.6967 17.3033C7.7456 18.3522 9.08197 19.0665 10.5368 19.3559C11.9917 19.6453 13.4997 19.4968 14.8701 18.9291C16.2406 18.3614 17.4119 17.4001 18.236 16.1668C19.0601 14.9334 19.5 13.4834 19.5 12C19.5 10.0109 18.7098 8.10323 17.3033 6.6967C15.8968 5.29018 13.9891 4.5 12 4.5Z", fill: color })] })] }));
  };

  function AppSelect({ items, label, initialSelectedItem, onChange, name, isDarkMode, errorMessage, }) {
      const wrapperId = randomStringId$2();
      const listId = randomStringId$2();
      const inputId = randomStringId$2();
      const [wrapperRect, setWrapperRect] = hooks.useState({
          x: 0,
          y: 0,
          height: 0,
          width: 0,
      });
      const [isOpen, setIsOpen] = hooks.useState(false);
      const [listClasses, setListClasses] = hooks.useState('sx__app-select__list');
      const [selectedItem, setSelectedItem] = hooks.useState((initialSelectedItem === null || initialSelectedItem === void 0 ? void 0 : initialSelectedItem.value) || '');
      const setPopupPosition = (wrapperEl) => {
          setWrapperRect({
              x: wrapperEl.getBoundingClientRect().left,
              y: wrapperEl.getBoundingClientRect().top,
              height: wrapperEl.getBoundingClientRect().height,
              width: wrapperEl.getBoundingClientRect().width,
          });
      };
      hooks.useEffect(() => {
          const baseClasses = ['sx__app-select__list'];
          if (isDarkMode)
              baseClasses.push('is-dark');
          if (isOpen)
              baseClasses.push('is-open');
          setListClasses(baseClasses.join(' '));
      }, [isOpen, isDarkMode]);
      const toggleOpen = () => {
          if (isOpen) {
              setIsOpen(false);
              return;
          }
          const wrapperEl = document.getElementById(wrapperId);
          const inputEl = document.getElementById(inputId);
          if (!wrapperEl || !inputEl)
              return;
          inputEl.focus();
          setIsOpen(true);
          setPopupPosition(wrapperEl);
          const scrollableParents = getScrollableParents(wrapperEl);
          const boundSetPosition = setPopupPosition.bind(null, wrapperEl);
          const listClickOutsideListener = (event) => {
              const target = event.target;
              if (target instanceof HTMLElement && !target.closest(`#${listId}`)) {
                  setIsOpen(false);
                  document.removeEventListener('click', listClickOutsideListener);
                  scrollableParents.forEach((parentEl) => parentEl.removeEventListener('scroll', boundSetPosition));
              }
          };
          setTimeout(() => {
              document.addEventListener('click', listClickOutsideListener);
              scrollableParents.forEach((parentEl) => parentEl.addEventListener('scroll', boundSetPosition));
          }, 10);
      };
      const clickOnItem = (item) => {
          var _a;
          setSelectedItem(item);
          const inputEl = document.getElementById(inputId);
          if (!(inputEl instanceof HTMLInputElement))
              return;
          inputEl.value = ((_a = items.find((i) => i.value === item)) === null || _a === void 0 ? void 0 : _a.label) || '';
          setIsOpen(false);
      };
      const inputRef = hooks.useRef(null);
      hooks.useEffect(() => {
          var _a;
          onChange(selectedItem);
          if (!inputRef.current)
              return;
          inputRef.current.value =
              ((_a = items.find((i) => i.value === selectedItem)) === null || _a === void 0 ? void 0 : _a.label) || '';
      }, [selectedItem]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { class: "sx__app-select-wrapper", id: wrapperId, onClick: toggleOpen, children: [jsxRuntime.jsxs("div", { class: "sx__app-select__input-wrapper", children: [jsxRuntime.jsx("input", { ref: inputRef, id: inputId, className: "sx__app-select-input", type: "text", readOnly: true, name: name }), jsxRuntime.jsx("label", { className: 'sx__app-select-label', htmlFor: name, children: label })] }), compat.createPortal(jsxRuntime.jsx("div", { id: listId, class: listClasses, style: {
                                  top: wrapperRect.y + wrapperRect.height + 1,
                                  left: wrapperRect.x,
                                  width: wrapperRect.width,
                              }, children: jsxRuntime.jsx("ul", { children: items.map((item, index) => (jsxRuntime.jsx("li", { onClick: () => clickOnItem(item.value), children: item.label }, index))) }) }), document.body)] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
  }

  const toDateTimeString = (date) => {
      return `${toDateString$2(date)} ${toTimeString$1(date)}`;
  };
  /**
   * Converts a string of format 20240229T235959 to YYYY-MM-DD
   * */
  const dateStringFromICalendarDateTime = (dateTime) => {
      const year = dateTime.slice(0, 4);
      const month = dateTime.slice(4, 6);
      const day = dateTime.slice(6, 8);
      return `${year}-${month}-${day}`;
  };
  /**
   * Converts a string of format 2024-01-01 to 20240101T235959
   * We need to add 23:59:59 to make the date inclusive when selecting an UNTIL date
   * */
  const toICalendarDateTimeWithEndOfDay = (dateTime) => {
      return `${dateTime.replace(/-/g, '')}T235959`;
  };

  const getFrequencies = () => {
      return [
          { label: 'Once', value: '' },
          { label: 'Daily', value: 'DAILY' },
          { label: 'Weekly', value: 'WEEKLY' },
          { label: 'Monthly', value: 'MONTHLY' },
          { label: 'Yearly', value: 'YEARLY' },
      ];
  };
  const getInitialFrequency = (modalPlugin) => {
      var _a;
      const validFrequencies = getFrequencies().map((f) => f.value);
      const rruleParts = modalPlugin.formValues.value.rrule
          ? modalPlugin.formValues.value.rrule.split(';')
          : [];
      const freqPart = rruleParts.find((part) => part.includes('FREQ'));
      const freq = freqPart ? freqPart.split('=')[1] : '';
      if (freq && !validFrequencies.includes(freq)) {
          throw new Error(`Unsupported frequency: ${freq}`);
      }
      return {
          label: ((_a = getFrequencies().find((f) => f.value === freq)) === null || _a === void 0 ? void 0 : _a.label) || '',
          value: freq,
      };
  };
  const getInitialRruleUntil = (modalPlugin) => {
      if (modalPlugin.formValues.value.rrule) {
          const allRruleParts = modalPlugin.formValues.value.rrule.split(';');
          const untilPart = allRruleParts.find((part) => part.includes('UNTIL'));
          return untilPart
              ? dateStringFromICalendarDateTime(untilPart.split('=')[1])
              : '';
      }
      if (modalPlugin.formValues.value.end) {
          return toDateString$2(toJSDate$1(modalPlugin.formValues.value.end));
      }
      return;
  };

  function EventForm({ $app, removeEditAddedEvent }) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31;
      const titleFieldId = randomStringId$2();
      const [wasInitialized, setWasInitialized] = hooks.useState(false);
      const modalPlugin = $app.config.plugins
          .eventModal;
      const dateTimeSeparator = ' ';
      const [isFullDayEvent, setIsFullDayEvent] = hooks.useState(dateStringRegex.test(modalPlugin.formValues.value.start));
      const [startDate, setStartDate] = hooks.useState(modalPlugin.formValues.value.start
          ? toDateString$2(toJSDate$1(modalPlugin.formValues.value.start))
          : '');
      const [startTime, setStartTime] = hooks.useState(modalPlugin.formValues.value.start
          ? toTimeString$1(toJSDate$1(modalPlugin.formValues.value.start))
          : '');
      const [endDate, setEndDate] = hooks.useState(modalPlugin.formValues.value.end
          ? toDateString$2(toJSDate$1(modalPlugin.formValues.value.end))
          : '');
      const [endTime, setEndTime] = hooks.useState(modalPlugin.formValues.value.end
          ? toTimeString$1(toJSDate$1(modalPlugin.formValues.value.end))
          : '');
      const [rruleFreq, setRruleFreq] = hooks.useState(() => getInitialFrequency(modalPlugin).value);
      const [rruleUntil, setRruleUntil] = hooks.useState(() => getInitialRruleUntil(modalPlugin));
      hooks.useEffect(() => {
          modalPlugin.formValues.value.start = isFullDayEvent
              ? startDate
              : startDate + dateTimeSeparator + startTime;
          if (startDate > endDate) {
              setEndDate(startDate);
          }
          if (startTime > endTime && startDate === endDate) {
              setEndTime(startTime);
          }
          if (wasInitialized && modalPlugin.config.onStartUpdate) {
              modalPlugin.config.onStartUpdate(modalPlugin.formValues.value.start);
          }
          setWasInitialized(true);
      }, [startDate, startTime, isFullDayEvent]);
      hooks.useEffect(() => {
          modalPlugin.formValues.value.end = isFullDayEvent
              ? endDate
              : endDate + dateTimeSeparator + endTime;
          if (endDate < startDate) {
              setStartDate(endDate);
          }
          if (endTime < startTime && startDate === endDate) {
              setStartTime(endTime);
          }
          if (rruleUntil && rruleUntil < endDate) {
              setRruleUntil(endDate);
          }
          if (wasInitialized && modalPlugin.config.onEndUpdate) {
              modalPlugin.config.onEndUpdate(modalPlugin.formValues.value.end);
          }
          setWasInitialized(true);
      }, [endDate, endTime, isFullDayEvent]);
      hooks.useEffect(() => {
          Object.values(modalPlugin.formValidationErrors).forEach((error) => {
              error.value = undefined;
          });
      }, []);
      const [shouldValidate, setShouldValidate] = hooks.useState(false);
      const SAVE_BUTTON_BASE_CLASS = 'sx__app-button-filled';
      const [saveButtonClasses, setSaveButtonClasses] = hooks.useState([
          SAVE_BUTTON_BASE_CLASS,
      ]);
      const validate = () => {
          Object.entries({
              ...modalPlugin.config.fields,
              ...modalPlugin.config.customFields,
          }).forEach(([fieldName, field]) => {
              // unwrap custom fields since they are signals
              if ('value' in field)
                  field = field.value;
              if (!('validator' in field) || !field.validator)
                  return;
              const validationResult = field.validator(modalPlugin.formValues.value[fieldName]);
              if (!validationResult.isValid && fieldName) {
                  modalPlugin.formValidationErrors[fieldName].value =
                      validationResult.message;
              }
              else {
                  modalPlugin.formValidationErrors[fieldName].value = undefined;
              }
          });
      };
      const validateIfShouldValidate = () => {
          if (shouldValidate)
              validate();
      };
      const isFormValid = () => {
          return Object.values(modalPlugin.formValidationErrors).every((error) => !error.value);
      };
      const updateExistingEvent = () => {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          const eventId = ((_a = modalPlugin.calendarEvent.value) === null || _a === void 0 ? void 0 : _a.id) || '';
          const eventToUpdate = modalPlugin.eventsService.get(eventId);
          if (!eventToUpdate)
              throw new Error('Did not find event with ID ' + ((_b = modalPlugin.calendarEvent.value) === null || _b === void 0 ? void 0 : _b.id));
          const updatedEvent = {
              ...eventToUpdate,
              ...modalPlugin.formValues.value,
              end: modalPlugin.formValues.value.end || modalPlugin.formValues.value.start,
              id: eventToUpdate.id,
          };
          // for edit_added mode
          if ((_d = (_c = updatedEvent._options) === null || _c === void 0 ? void 0 : _c.additionalClasses) === null || _d === void 0 ? void 0 : _d.includes(ADDED_EVENT_CLASS_NAME)) {
              updatedEvent._options.additionalClasses =
                  updatedEvent._options.additionalClasses.filter((className) => className !== ADDED_EVENT_CLASS_NAME);
          }
          modalPlugin.eventsService.update(updatedEvent);
          modalPlugin.close();
          if (modalPlugin.modalState.value === 'edit_added') {
              (_f = (_e = modalPlugin.config).onAddEvent) === null || _f === void 0 ? void 0 : _f.call(_e, updatedEvent);
          }
          else {
              (_h = (_g = $app.config.callbacks) === null || _g === void 0 ? void 0 : _g.onEventUpdate) === null || _h === void 0 ? void 0 : _h.call(_g, updatedEvent);
          }
      };
      const createNewEvent = () => {
          var _a;
          if (!modalPlugin.config.onAddEvent)
              return;
          const newEvent = {
              id: ((_a = modalPlugin.calendarEvent.value) === null || _a === void 0 ? void 0 : _a.id) || '',
              title: modalPlugin.formValues.value.title,
              description: modalPlugin.formValues.value.description,
              start: modalPlugin.formValues.value.start,
              end: modalPlugin.formValues.value.end,
              people: modalPlugin.formValues.value.people,
              calendarId: modalPlugin.formValues.value.calendarId,
              rrule: modalPlugin.formValues.value.rrule,
              resourceId: modalPlugin.formValues.value.resourceId,
          };
          modalPlugin.eventsService.add(newEvent);
          modalPlugin.close();
          modalPlugin.config.onAddEvent(newEvent);
      };
      const setRrule = () => {
          if (!rruleFreq || !rruleUntil) {
              modalPlugin.formValues.value.rrule = undefined;
              return;
          }
          const rruleParts = [
              'FREQ=' + rruleFreq,
              'UNTIL=' + toICalendarDateTimeWithEndOfDay(rruleUntil),
          ];
          modalPlugin.formValues.value.rrule = rruleParts.join(';');
      };
      const saveEvent = () => {
          setRrule();
          setShouldValidate(true);
          validate();
          if (!isFormValid()) {
              setSaveButtonClasses([SAVE_BUTTON_BASE_CLASS, 'has-shake-animation']);
              setTimeout(() => {
                  setSaveButtonClasses([SAVE_BUTTON_BASE_CLASS]);
              }, 500);
              return;
          }
          if (['edit', 'edit_added'].includes(modalPlugin.modalState.value))
              updateExistingEvent();
          else
              createNewEvent();
      };
      const cancel = () => {
          if (modalPlugin.modalState.value === 'edit')
              return (modalPlugin.modalState.value = 'view');
          if (modalPlugin.modalState.value === 'edit_added')
              removeEditAddedEvent();
          modalPlugin.close();
      };
      const getCalendars = () => {
          return Object.entries($app.config.calendars.value).map(([key, value]) => {
              return { label: value.label || '', value: key };
          });
      };
      const getSelectedCalendarOrUndefined = () => {
          const selectedCalendar = $app.config.calendars.value[modalPlugin.formValues.value.calendarId];
          if (!selectedCalendar)
              return undefined;
          return selectedCalendar
              ? {
                  label: selectedCalendar.label || '',
                  value: modalPlugin.formValues.value.calendarId,
              }
              : undefined;
      };
      const configuredFields = modalPlugin.config.fields;
      const hasConfiguredFields = !!configuredFields;
      const hasConfiguredAllDateTimeFields = hasConfiguredFields &&
          configuredFields.startDate &&
          configuredFields.startTime &&
          configuredFields.endDate &&
          configuredFields.endTime;
      const isAddMode = modalPlugin.modalState.value === 'add';
      const isEditAddedMode = modalPlugin.modalState.value === 'edit_added';
      const showDescription = !hasConfiguredFields || configuredFields.description;
      const showDateTimeFields = isAddMode ||
          isEditAddedMode ||
          !hasConfiguredFields ||
          hasConfiguredAllDateTimeFields;
      const showCalendarField = !hasConfiguredFields ||
          (configuredFields.calendarId &&
              Object.entries(((_a = $app.config) === null || _a === void 0 ? void 0 : _a.calendars) || {}).length > 1);
      const showResourceField = !hasConfiguredFields || configuredFields.resourceId;
      const showRruleFields = !hasConfiguredFields ||
          (configuredFields.rruleFrequency && configuredFields.rruleUntil);
      hooks.useEffect(() => {
          var _a;
          const titleField = document.getElementById(titleFieldId);
          if (titleField) {
              (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.empty();
              setTimeout(() => {
                  titleField.focus();
              }, 10);
          }
      }, []);
      const [isInHiddenCalendar, setIsInHiddenCalendar] = hooks.useState(false);
      const checkIsInHiddenCalendar = () => {
          if (!$app.calendarEvents.filterPredicate.value)
              return;
          const isInHiddenCalendar = [modalPlugin.formValues.value].filter($app.calendarEvents.filterPredicate.value).length === 0;
          setIsInHiddenCalendar(isInHiddenCalendar);
      };
      hooks.useEffect(() => {
          checkIsInHiddenCalendar();
      }, []);
      const resources = 'resourceViewConfig' in $app
          ? $app.resourceViewConfig.resources.value
          : [];
      const getResourceItems = () => {
          return resources.map((resource) => {
              return { label: resource.label || '', value: resource.id };
          });
      };
      const getSelectedResourceOrUndefined = () => {
          const selectedResource = resources.find((resource) => resource.id === modalPlugin.formValues.value.resourceId);
          if (!selectedResource)
              return undefined;
          return {
              label: selectedResource.label || '',
              value: selectedResource.id,
          };
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { className: "sx__event-form", children: [modalPlugin.isEditingRecurringEvent.value && (jsxRuntime.jsxs("div", { className: "sx__event-form-alert sx__event-form-recurrence-warning", children: [jsxRuntime.jsx(WarningSign, {}), "You are editing the first in a series of recurring events."] })), isInHiddenCalendar && (jsxRuntime.jsxs("div", { className: "sx__event-form-alert sx__event-form-info-box", children: [jsxRuntime.jsx(InfoIcon, {}), "This event is in a hidden calendar."] })), jsxRuntime.jsx(TextField, { id: titleFieldId, initialValue: modalPlugin.formValues.value.title || '', onChange: (value) => {
                          var _a, _b, _c;
                          (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.title) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                          modalPlugin.formValues.value.title = value;
                          validateIfShouldValidate();
                      }, label: ((_c = (_b = modalPlugin.config.fields) === null || _b === void 0 ? void 0 : _b.title) === null || _c === void 0 ? void 0 : _c.label) || 'Title', fieldName: ((_e = (_d = modalPlugin.config.fields) === null || _d === void 0 ? void 0 : _d.title) === null || _e === void 0 ? void 0 : _e.name) || 'title', errorMessage: (_f = modalPlugin.formValidationErrors.title) === null || _f === void 0 ? void 0 : _f.value }, modalPlugin.formValues.value), showDateTimeFields && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("div", { className: "sx__event-time-input", children: [jsxRuntime.jsxs("div", { class: "sx__date-time-picker sx__date-time-start", children: [jsxRuntime.jsx(DatePicker, { label: ((_h = (_g = modalPlugin.config.fields) === null || _g === void 0 ? void 0 : _g.startDate) === null || _h === void 0 ? void 0 : _h.label) || 'Start date', name: ((_k = (_j = modalPlugin.config.fields) === null || _j === void 0 ? void 0 : _j.startDate) === null || _k === void 0 ? void 0 : _k.name) || 'start-date', onChange: (newStartDate) => {
                                                  var _a, _b, _c;
                                                  (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.startDate) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newStartDate);
                                                  setStartDate(newStartDate);
                                              }, min: (_l = modalPlugin.config.datePicker) === null || _l === void 0 ? void 0 : _l.min, max: (_m = modalPlugin.config.datePicker) === null || _m === void 0 ? void 0 : _m.max, initialValue: startDate, isDarkMode: $app.calendarState.isDark.value, locale: $app.config.locale.value }), !isFullDayEvent && (jsxRuntime.jsx(TimePicker, { onChange: (newStartTime) => {
                                                  var _a, _b, _c;
                                                  (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.startTime) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newStartTime);
                                                  setStartTime(newStartTime);
                                              }, label: ((_p = (_o = modalPlugin.config.fields) === null || _o === void 0 ? void 0 : _o.startTime) === null || _p === void 0 ? void 0 : _p.label) || '', name: ((_r = (_q = modalPlugin.config.fields) === null || _q === void 0 ? void 0 : _q.startTime) === null || _r === void 0 ? void 0 : _r.name) || 'start-time', initialValue: startTime, placement: $app.calendarState.isCalendarSmall.value
                                                  ? 'bottom-end'
                                                  : 'bottom-start', isDarkMode: $app.calendarState.isDark.value, is12Hour: modalPlugin.config.has12HourTimeFormat || false }))] }), jsxRuntime.jsx("span", { className: 'sx__date-time-until', children: "until" }), jsxRuntime.jsxs("div", { class: "sx__date-time-picker sx__date-time-end", children: [jsxRuntime.jsx(DatePicker, { label: ((_t = (_s = modalPlugin.config.fields) === null || _s === void 0 ? void 0 : _s.endDate) === null || _t === void 0 ? void 0 : _t.label) || 'End date', name: ((_v = (_u = modalPlugin.config.fields) === null || _u === void 0 ? void 0 : _u.endDate) === null || _v === void 0 ? void 0 : _v.name) || 'end-date', onChange: (newEndDate) => {
                                                  var _a, _b, _c;
                                                  (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.endDate) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newEndDate);
                                                  setEndDate(newEndDate);
                                              }, initialValue: endDate, isDarkMode: $app.calendarState.isDark.value, min: (_w = modalPlugin.config.datePicker) === null || _w === void 0 ? void 0 : _w.min, max: (_x = modalPlugin.config.datePicker) === null || _x === void 0 ? void 0 : _x.max, locale: $app.config.locale.value }), !isFullDayEvent && (jsxRuntime.jsx(TimePicker, { onChange: (newEndTime) => {
                                                  var _a, _b, _c;
                                                  (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.endTime) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newEndTime);
                                                  setEndTime(newEndTime);
                                              }, label: ((_z = (_y = modalPlugin.config.fields) === null || _y === void 0 ? void 0 : _y.endTime) === null || _z === void 0 ? void 0 : _z.label) || '', initialValue: endTime, placement: 'bottom-end', isDarkMode: $app.calendarState.isDark.value, name: ((_1 = (_0 = modalPlugin.config.fields) === null || _0 === void 0 ? void 0 : _0.endTime) === null || _1 === void 0 ? void 0 : _1.name) || 'end-time', is12Hour: modalPlugin.config.has12HourTimeFormat || false }))] })] }), jsxRuntime.jsx(AppCheckbox, { label: 'Full-day event', initialValue: isFullDayEvent, onChange: (isChecked) => setIsFullDayEvent(isChecked) })] })), showRruleFields && (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { className: 'sx__rrule-wrapper', children: [jsxRuntime.jsx(AppSelect, { items: getFrequencies(), initialSelectedItem: getInitialFrequency(modalPlugin), label: ((_3 = (_2 = modalPlugin.config.fields) === null || _2 === void 0 ? void 0 : _2.rruleFrequency) === null || _3 === void 0 ? void 0 : _3.label) ||
                                      'Frequency', onChange: (value) => {
                                      var _a, _b, _c;
                                      (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.rruleFrequency) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                                      setRruleFreq(value);
                                  }, name: ((_5 = (_4 = modalPlugin.config.fields) === null || _4 === void 0 ? void 0 : _4.rruleFrequency) === null || _5 === void 0 ? void 0 : _5.name) || 'rrule', isDarkMode: $app.calendarState.isDark.value }), jsxRuntime.jsx(DatePicker, { initialValue: rruleUntil, onChange: (newDate) => {
                                      var _a, _b, _c;
                                      (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.rruleUntil) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newDate);
                                      setRruleUntil(newDate);
                                  }, isDarkMode: $app.calendarState.isDark.value, disabled: !rruleFreq, label: ((_7 = (_6 = modalPlugin.config.fields) === null || _6 === void 0 ? void 0 : _6.rruleUntil) === null || _7 === void 0 ? void 0 : _7.label) || 'Until', width: '100%', name: ((_9 = (_8 = modalPlugin.config.fields) === null || _8 === void 0 ? void 0 : _8.rruleUntil) === null || _9 === void 0 ? void 0 : _9.name) || 'until', min: (_10 = modalPlugin.config.datePicker) === null || _10 === void 0 ? void 0 : _10.min, max: (_11 = modalPlugin.config.datePicker) === null || _11 === void 0 ? void 0 : _11.max, locale: $app.config.locale.value })] }) })), showDescription && (jsxRuntime.jsx(Textarea, { initialValue: modalPlugin.formValues.value.description || '', onChange: (value) => {
                          var _a, _b, _c;
                          (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.description) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                          modalPlugin.formValues.value.description = value;
                          validateIfShouldValidate();
                      }, label: ((_13 = (_12 = modalPlugin.config.fields) === null || _12 === void 0 ? void 0 : _12.description) === null || _13 === void 0 ? void 0 : _13.label) || 'Description', name: ((_15 = (_14 = modalPlugin.config.fields) === null || _14 === void 0 ? void 0 : _14.description) === null || _15 === void 0 ? void 0 : _15.name) || 'description', errorMessage: (_16 = modalPlugin.formValidationErrors.description) === null || _16 === void 0 ? void 0 : _16.value }, modalPlugin.formValues.value + 'description')), modalPlugin.config.availablePeople && (jsxRuntime.jsx(AppCombobox, { items: modalPlugin.config.availablePeople, initialSelectedItems: modalPlugin.formValues.value.people, onChange: (value) => {
                          var _a, _b, _c;
                          (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.people) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                          modalPlugin.formValues.value.people = value;
                          validateIfShouldValidate();
                      }, label: ((_18 = (_17 = modalPlugin.config.fields) === null || _17 === void 0 ? void 0 : _17.people) === null || _18 === void 0 ? void 0 : _18.label) || 'People', name: ((_20 = (_19 = modalPlugin.config.fields) === null || _19 === void 0 ? void 0 : _19.people) === null || _20 === void 0 ? void 0 : _20.name) || 'people', isDarkMode: $app.calendarState.isDark.value, errorMessage: (_21 = modalPlugin.formValidationErrors.people) === null || _21 === void 0 ? void 0 : _21.value }, modalPlugin.formValues.value + 'people')), showCalendarField && (jsxRuntime.jsx(AppComboboxSingleValue, { items: getCalendars(), initialSelectedItem: getSelectedCalendarOrUndefined(), label: ((_23 = (_22 = modalPlugin.config.fields) === null || _22 === void 0 ? void 0 : _22.calendarId) === null || _23 === void 0 ? void 0 : _23.label) || 'Calendar', onChange: (value) => {
                          var _a, _b, _c;
                          (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.calendarId) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                          modalPlugin.formValues.value.calendarId = value;
                          validateIfShouldValidate();
                          checkIsInHiddenCalendar();
                      }, name: ((_25 = (_24 = modalPlugin.config.fields) === null || _24 === void 0 ? void 0 : _24.calendarId) === null || _25 === void 0 ? void 0 : _25.name) || 'calendar', isDarkMode: $app.calendarState.isDark.value, errorMessage: (_26 = modalPlugin.formValidationErrors.calendarId) === null || _26 === void 0 ? void 0 : _26.value }, modalPlugin.formValues.value + 'calendar')), showResourceField && (jsxRuntime.jsx(AppComboboxSingleValue, { items: getResourceItems(), initialSelectedItem: getSelectedResourceOrUndefined(), label: ((_28 = (_27 = modalPlugin.config.fields) === null || _27 === void 0 ? void 0 : _27.resourceId) === null || _28 === void 0 ? void 0 : _28.label) || 'Resource', onChange: (value) => {
                          var _a, _b, _c;
                          (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.resourceId) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                          modalPlugin.formValues.value.resourceId = value;
                          validateIfShouldValidate();
                      }, name: ((_30 = (_29 = modalPlugin.config.fields) === null || _29 === void 0 ? void 0 : _29.resourceId) === null || _30 === void 0 ? void 0 : _30.name) || 'resource', isDarkMode: $app.calendarState.isDark.value, errorMessage: (_31 = modalPlugin.formValidationErrors.resourceId) === null || _31 === void 0 ? void 0 : _31.value }, modalPlugin.formValues.value + 'resource')), modalPlugin.config.customFields && (jsxRuntime.jsx(jsxRuntime.Fragment, { children: Object.entries(modalPlugin.config.customFields).map(([fieldName, field]) => {
                          var _a, _b, _c, _d, _e;
                          return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [field.value.type === 'text' && (jsxRuntime.jsx(TextField, { id: fieldName, initialValue: modalPlugin.formValues.value[fieldName] || '', onChange: (value) => {
                                          var _a, _b;
                                          (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                          modalPlugin.formValues.value[fieldName] = value;
                                          validateIfShouldValidate();
                                      }, label: field.value.label || '', fieldName: fieldName, errorMessage: (_a = modalPlugin.formValidationErrors[fieldName]) === null || _a === void 0 ? void 0 : _a.value }, field.value)), field.value.type == 'select' && (jsxRuntime.jsx(AppSelect, { items: field.value.items || [], label: field.value.label || '', onChange: (value) => {
                                          var _a, _b;
                                          (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                          modalPlugin.formValues.value[fieldName] = value;
                                          validateIfShouldValidate();
                                      }, initialSelectedItem: ((_b = field.value.items) === null || _b === void 0 ? void 0 : _b.find((item) => {
                                          return (item.value ===
                                              modalPlugin.formValues.value[fieldName]);
                                      })) || undefined, name: fieldName }, field.value)), field.value.type === 'textarea' && (jsxRuntime.jsx(Textarea, { initialValue: modalPlugin.formValues.value[fieldName] || '', onChange: (value) => {
                                          var _a, _b;
                                          (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                          modalPlugin.formValues.value[fieldName] = value;
                                          validateIfShouldValidate();
                                      }, label: field.value.label || '', name: fieldName, errorMessage: (_c = modalPlugin.formValidationErrors[fieldName]) === null || _c === void 0 ? void 0 : _c.value }, field.value)), field.value.type === 'combobox' && (jsxRuntime.jsx(AppComboboxSingleValue, { items: field.value.items || [], label: field.value.label || '', onChange: (value) => {
                                          var _a, _b;
                                          (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                          modalPlugin.formValues.value[fieldName] = value;
                                          validateIfShouldValidate();
                                      }, initialSelectedItem: ((_d = field.value.items) === null || _d === void 0 ? void 0 : _d.find((item) => {
                                          return (item.value ===
                                              modalPlugin.formValues.value[fieldName]);
                                      })) || undefined, name: fieldName, errorMessage: (_e = modalPlugin.formValidationErrors[fieldName]) === null || _e === void 0 ? void 0 : _e.value }, field.value))] }));
                      }) })), jsxRuntime.jsxs("div", { className: 'sx__form-actions', children: [jsxRuntime.jsx(AppButton, { onClick: saveEvent, additionalClasses: saveButtonClasses.join(' '), children: "Save" }), jsxRuntime.jsx(AppButton, { onClick: cancel, additionalClasses: 'sx__app-button-outlined', children: "Cancel" })] })] }) }));
  }

  function DeleteActions({ $app }) {
      const modalPlugin = $app.config.plugins
          .eventModal;
      return (jsxRuntime.jsxs("div", { children: [jsxRuntime.jsx("h2", { className: "sx__modal-delete-headline", children: "Are you sure you want to delete this event?" }), jsxRuntime.jsxs("div", { className: "sx__modal-delete-actions", children: [jsxRuntime.jsx(AppButton, { additionalClasses: "sx__app-button-outlined", onClick: () => {
                              modalPlugin.modalState.value = 'view';
                          }, children: "Cancel" }), jsxRuntime.jsx(AppButton, { additionalClasses: "sx__app-button-danger", onClick: () => {
                              var _a, _b;
                              const eventId = modalPlugin.calendarEvent.value.id;
                              modalPlugin.eventsService.remove(eventId);
                              modalPlugin.close();
                              (_b = (_a = modalPlugin.config).onDeleteEvent) === null || _b === void 0 ? void 0 : _b.call(_a, eventId);
                          }, children: "Delete" })] })] }));
  }

  function InteractiveEventModal({ $app, }) {
      const [modalId] = hooks.useState(randomStringId$2());
      const { value: calendarEvent } = $app.config.plugins.eventModal.calendarEvent;
      const modalPlugin = $app.config.plugins
          .eventModal;
      const removeEditAddedEvent = () => {
          if (calendarEvent && modalPlugin.modalState.value === 'edit_added')
              modalPlugin.config.eventsService.remove(calendarEvent.id);
      };
      const clickOutsideListener = createClickOutsideListener($app, modalId, () => removeEditAddedEvent());
      const callSetPosition = () => {
          var _a, _b, _c;
          setPosition((_a = $app.elements.calendarWrapper) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect(), (_b = $app.config.plugins.eventModal) === null || _b === void 0 ? void 0 : _b.calendarEventDOMRect.value, ((_c = $app.elements.calendarWrapper) === null || _c === void 0 ? void 0 : _c.querySelector('.sx__interactive-event-modal')).clientHeight, modalPlugin.config.has12HourTimeFormat ? 595 : undefined);
      };
      const scrollListener = () => {
          var _a, _b;
          $app.config.plugins.eventModal.calendarEventDOMRect.value =
              (_b = (_a = $app.config.plugins.eventModal) === null || _a === void 0 ? void 0 : _a.calendarEventElement.value) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
          callSetPosition();
      };
      const escapeKeyDownListener = (e) => {
          setTimeout(() => {
              if (e.key === 'Escape' &&
                  !window
                      .__sx_escapeKeyDownBlocker__) {
                  modalPlugin.close();
                  removeEditAddedEvent();
              }
          });
      };
      hooks.useEffect(() => {
          var _a;
          callSetPosition();
          modalPlugin.isOpen.value = true;
          document.addEventListener('click', clickOutsideListener, true);
          const scrollableAncestors = getScrollableParents(((_a = $app.config.plugins.eventModal) === null || _a === void 0 ? void 0 : _a.calendarEventElement.value) || null);
          scrollableAncestors.forEach((el) => el.addEventListener('scroll', scrollListener));
          document.addEventListener('keydown', escapeKeyDownListener);
          return () => {
              scrollableAncestors.forEach((el) => el.removeEventListener('scroll', scrollListener));
              document.removeEventListener('click', clickOutsideListener, true);
              document.removeEventListener('keydown', escapeKeyDownListener);
              modalPlugin.calendarEventDOMRect.value = null;
              modalPlugin.calendarEventElement.value = null;
              modalPlugin.isOpen.value = false;
          };
      }, []);
      hooks.useEffect(() => {
          callSetPosition();
      }, [modalPlugin.modalState.value]);
      const startDrag = (e) => {
          const modal = document.getElementById(modalId);
          if (modal) {
              const modalRect = modal.getBoundingClientRect();
              const offsetX = e.clientX - modalRect.left;
              const offsetY = e.clientY - modalRect.top;
              const move = (e) => {
                  modal.style.left = e.clientX - offsetX + 'px';
                  modal.style.top = e.clientY - offsetY + 'px';
              };
              const stop = () => {
                  document.removeEventListener('mousemove', move);
                  document.removeEventListener('mouseup', stop);
              };
              document.addEventListener('mousemove', move);
              document.addEventListener('mouseup', stop);
          }
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { id: modalId, "data-state": modalPlugin.modalState.value, className: `sx__interactive-event-modal${modalPlugin.isOpen.value ? ' is-open' : ''}`, children: [modalPlugin.config.movable && (jsxRuntime.jsx("div", { onMouseDown: startDrag, className: 'sx__interactive-event-modal__move-bar' })), calendarEvent && (jsxRuntime.jsxs(preact.Fragment, { children: [modalPlugin.modalState.value === 'view' && (jsxRuntime.jsx(EventDisplay, { "$app": $app, calendarEvent: calendarEvent })), ['edit', 'add', 'edit_added'].includes(modalPlugin.modalState.value) && (jsxRuntime.jsx(EventForm, { "$app": $app, removeEditAddedEvent: removeEditAddedEvent })), modalPlugin.modalState.value === 'delete' && (jsxRuntime.jsx(DeleteActions, { "$app": $app }))] }))] }) }));
  }

  const SX_INTERNAL_CALENDAR = '__SX-INTERNAL__';

  /* eslint-disable max-lines */
  const validateConfig = (config) => {
      const fields = config.fields;
      if ((fields === null || fields === void 0 ? void 0 : fields.startDate) ||
          (fields === null || fields === void 0 ? void 0 : fields.endDate) ||
          (fields === null || fields === void 0 ? void 0 : fields.startTime) ||
          (fields === null || fields === void 0 ? void 0 : fields.endTime)) {
          if (!fields.startDate ||
              !fields.endDate ||
              !fields.startTime ||
              !fields.endTime) {
              throw new Error('[Schedule-X error] startDate, startTime, endDate, and endTime must all be configured, if one of them is configured');
          }
      }
  };
  const createInteractiveEventModal = (config) => {
      validateConfig(config);
      const calendarEvent = signals.signal(null);
      const calendarEventDOMRect = signals.signal(null);
      const formValues = signals.signal({
          start: toDateTimeString(new Date()),
          end: toDateTimeString(new Date()),
          title: undefined,
          description: undefined,
          location: undefined,
          people: [],
          calendarId: undefined,
      });
      const modalState = signals.signal('view');
      const isEditingRecurringEvent = signals.signal(false);
      let _$app;
      const _setCalendarEventInViewMode = (event, eventTargetDOMRect) => {
          var _a;
          if (config.canOpenModal && !config.canOpenModal(event))
              return;
          const clickedOnEventInEditAddedMode = modalState.value === 'edit_added' && ((_a = calendarEvent.value) === null || _a === void 0 ? void 0 : _a.id);
          if (clickedOnEventInEditAddedMode) {
              config.eventsService.remove(calendarEvent.value.id);
          }
          modalState.value = 'view';
          calendarEvent.value = event;
          calendarEventDOMRect.value = eventTargetDOMRect;
      };
      const calendarEventElement = signals.signal(null);
      const _setCalendarEventInEditAddedMode = (event, eventTargetDOMRect) => {
          var _a;
          const eventElement = (_a = _$app === null || _$app === void 0 ? void 0 : _$app.elements.calendarWrapper) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-event-id="${event.id}"]`);
          if (eventElement instanceof HTMLElement) {
              calendarEventElement.value = eventElement;
          }
          modalState.value = 'edit_added';
          calendarEvent.value = event;
          calendarEventDOMRect.value = eventTargetDOMRect;
      };
      function clickToCreate(start, otherEventProperties = {}) {
          const eventId = otherEventProperties.id || randomStringId$2();
          const observer = new MutationObserver((mutations) => {
              // wait for an element with data-event-id="eventId" to be added to the DOM
              mutations.forEach((mutation) => {
                  const target = mutation.target;
                  const eventElement = target.dataset.eventId === String(eventId)
                      ? target
                      : target.querySelector(`[data-event-id="${eventId}"]`);
                  const eventInternal = _$app === null || _$app === void 0 ? void 0 : _$app.calendarEvents.list.value.find((event) => event.id === eventId);
                  if (eventElement && eventInternal) {
                      observer.disconnect();
                      const rect = eventElement.getBoundingClientRect();
                      _setCalendarEventInEditAddedMode(eventInternal, rect);
                      formValues.value = {
                          start: eventInternal.start,
                          end: eventInternal.end,
                          title: eventInternal.title,
                          description: eventInternal.description,
                          calendarId: eventInternal.calendarId !== SX_INTERNAL_CALENDAR
                              ? eventInternal.calendarId
                              : undefined,
                          people: eventInternal.people,
                      };
                      modalState.value = 'edit_added';
                  }
              });
          });
          if (_$app) {
              observer.observe(_$app.elements.calendarWrapper || document, {
                  childList: true,
                  subtree: true,
              });
          }
          isEditingRecurringEvent.value = false;
          const _start = start;
          const end = /^\w{4}-\w{2}-\w{2}$/.test(_start)
              ? _start
              : addMinutes(_start, 60);
          const newEvent = {
              id: eventId,
              start: _start,
              end: end,
              calendarId: SX_INTERNAL_CALENDAR,
              _options: {
                  additionalClasses: [ADDED_EVENT_CLASS_NAME],
              },
              ...otherEventProperties,
          };
          if (_$app.calendarEvents.filterPredicate.value) {
              const isInHiddenCalendar = [newEvent].filter(_$app.calendarEvents.filterPredicate.value).length === 0;
              if (isInHiddenCalendar)
                  newEvent.calendarId = SX_INTERNAL_CALENDAR;
          }
          config.eventsService.add(newEvent);
      }
      const allFieldsWithValidators = [];
      Object.entries({
          ...config.fields,
      }).forEach(([fieldName, field]) => {
          if ('validator' in field && field.validator) {
              allFieldsWithValidators.push(fieldName);
          }
      });
      Object.entries({
          ...config.customFields,
      }).forEach(([fieldName, field]) => {
          if ('validator' in field.value && field.value.validator) {
              allFieldsWithValidators.push(fieldName);
          }
      });
      return definePlugin('eventModal', {
          config,
          calendarEventElement: calendarEventElement,
          name: 'eventModal',
          beforeRender($app) {
              _$app = $app;
          },
          calendarEvent,
          calendarEventDOMRect,
          ComponentFn: InteractiveEventModal,
          setCalendarEvent: _setCalendarEventInViewMode,
          formValues,
          formValidationErrors: allFieldsWithValidators.reduce((acc, fieldName) => {
              acc[fieldName] = signals.signal(undefined);
              return acc;
          }, {}),
          modalState,
          eventsService: config.eventsService,
          isEditingRecurringEvent,
          openEventCreationModal: (id, start, otherEventProperties = {}) => {
              isEditingRecurringEvent.value = false;
              modalState.value = 'add';
              const _start = start || toDateTimeString(new Date());
              const newEvent = {
                  id: id,
                  start: _start,
                  end: addMinutes(_start, 60),
                  title: '',
                  description: '',
                  people: [],
                  ...otherEventProperties,
              };
              calendarEvent.value = newEvent;
              formValues.value = {
                  start: newEvent.start,
                  end: newEvent.end,
                  title: newEvent.title,
                  description: newEvent.description,
                  people: newEvent.people,
              };
              calendarEventDOMRect.value = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0,
              };
          },
          clickToCreate(start, otherEventProperties = {}) {
              clickToCreate(start, otherEventProperties);
          },
          close: () => {
              calendarEvent.value = null;
              calendarEventDOMRect.value = null;
          },
          isOpen: signals.signal(false),
      });
  };

  exports.createInputField = createInputField;
  exports.createInteractiveEventModal = createInteractiveEventModal;

}));

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@preact/signals'), require('preact/jsx-runtime'), require('preact/hooks'), require('preact'), require('preact/compat')) :
  typeof define === 'function' && define.amd ? define(['exports', '@preact/signals', 'preact/jsx-runtime', 'preact/hooks', 'preact', 'preact/compat'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.SXInteractiveEventModal = {}, global.preactSignals, global.jsxRuntime, global.preactHooks, global.preact, global.preactCompat));
})(this, (function (exports, signals, jsxRuntime, hooks, preact, compat) { 'use strict';

  const createInputField = (field) => {
      const reactiveInputField = signals.signal({
          ...field,
          rerender: () => (reactiveInputField.value = { ...reactiveInputField.value }),
      });
      return reactiveInputField;
  };

  /**
   * Origin of SVG: https://www.svgrepo.com/svg/506771/time
   * License: PD License
   * Author Salah Elimam
   * Author website: https://www.figma.com/@salahelimam
   * */
  function TimeIcon({ strokeColor }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("path", { d: "M12 8V12L15 15", stroke: strokeColor, "stroke-width": "2", "stroke-linecap": "round" }), jsxRuntime.jsx("circle", { cx: "12", cy: "12", r: "9", stroke: strokeColor, "stroke-width": "2" })] })] }) }));
  }

  /**
   * Origin of SVG: https://www.svgrepo.com/svg/506772/user
   * License: PD License
   * Author Salah Elimam
   * Author website: https://www.figma.com/@salahelimam
   * */
  function UserIcon({ strokeColor }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("path", { d: "M15 7C15 8.65685 13.6569 10 12 10C10.3431 10 9 8.65685 9 7C9 5.34315 10.3431 4 12 4C13.6569 4 15 5.34315 15 7Z", stroke: strokeColor, "stroke-width": "2" }), jsxRuntime.jsx("path", { d: "M5 19.5C5 15.9101 7.91015 13 11.5 13H12.5C16.0899 13 19 15.9101 19 19.5V20C19 20.5523 18.5523 21 18 21H6C5.44772 21 5 20.5523 5 20V19.5Z", stroke: strokeColor, "stroke-width": "2" })] })] }) }));
  }

  /**
   * Origin of SVG: https://www.svgrepo.com/svg/506838/list
   * License: PD License
   * Author: Salah Elimam
   * Author website: https://www.figma.com/@salahelimam
   * */
  function DescriptionIcon({ strokeColor }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("rect", { x: "4", y: "4", width: "16", height: "16", rx: "3", stroke: strokeColor, "stroke-width": "2" }), jsxRuntime.jsx("path", { d: "M16 10L8 10", stroke: strokeColor, "stroke-width": "2", "stroke-linecap": "round" }), jsxRuntime.jsx("path", { d: "M16 14L8 14", stroke: strokeColor, "stroke-width": "2", "stroke-linecap": "round" })] })] }) }));
  }

  /**
   * Origin of SVG: https://www.svgrepo.com/svg/489502/location-pin
   * License: PD License
   * Author: Dariush Habibpour
   * Author website: https://redl.ink/dariush/links?ref=svgrepo.com
   * */
  function LocationPinIcon({ strokeColor }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsxs("g", { "clip-path": "url(#clip0_429_11046)", children: [jsxRuntime.jsx("rect", { x: "12", y: "11", width: "0.01", height: "0.01", stroke: strokeColor, "stroke-width": "2", "stroke-linejoin": "round" }), jsxRuntime.jsx("path", { d: "M12 22L17.5 16.5C20.5376 13.4624 20.5376 8.53757 17.5 5.5C14.4624 2.46244 9.53757 2.46244 6.5 5.5C3.46244 8.53757 3.46244 13.4624 6.5 16.5L12 22Z", stroke: strokeColor, "stroke-width": "2", "stroke-linejoin": "round" })] }), jsxRuntime.jsx("defs", { children: jsxRuntime.jsx("clipPath", { id: "clip0_429_11046", children: jsxRuntime.jsx("rect", { width: "24", height: "24", fill: "white" }) }) })] })] }) }));
  }

  const definePlugin = (name, definition) => {
      definition.name = name;
      return definition;
  };

  // regex for strings between 00:00 and 23:59
  const timeStringRegex = /^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
  const dateTimeStringRegex = /^(\d{4})-(\d{2})-(\d{2}) (0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
  const dateStringRegex = /^(\d{4})-(\d{2})-(\d{2})$/;

  const DateFormats$1 = {
      DATE_STRING: /^\d{4}-\d{2}-\d{2}$/,
      TIME_STRING: /^\d{2}:\d{2}$/,
      DATE_TIME_STRING: /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/,
  };

  let InvalidDateTimeError$1 = class InvalidDateTimeError extends Error {
      constructor(dateTimeSpecification) {
          super(`Invalid date time specification: ${dateTimeSpecification}`);
      }
  };

  const toJSDate$1 = (dateTimeSpecification) => {
      if (!DateFormats$1.DATE_TIME_STRING.test(dateTimeSpecification) &&
          !DateFormats$1.DATE_STRING.test(dateTimeSpecification))
          throw new InvalidDateTimeError$1(dateTimeSpecification);
      return new Date(Number(dateTimeSpecification.slice(0, 4)), Number(dateTimeSpecification.slice(5, 7)) - 1, Number(dateTimeSpecification.slice(8, 10)), Number(dateTimeSpecification.slice(11, 13)), // for date strings this will be 0
      Number(dateTimeSpecification.slice(14, 16)) // for date strings this will be 0
      );
  };
  const toIntegers$1 = (dateTimeSpecification) => {
      const hours = dateTimeSpecification.slice(11, 13), minutes = dateTimeSpecification.slice(14, 16);
      return {
          year: Number(dateTimeSpecification.slice(0, 4)),
          month: Number(dateTimeSpecification.slice(5, 7)) - 1,
          date: Number(dateTimeSpecification.slice(8, 10)),
          hours: hours !== '' ? Number(hours) : undefined,
          minutes: minutes !== '' ? Number(minutes) : undefined,
      };
  };

  let NumberRangeError$1 = class NumberRangeError extends Error {
      constructor(min, max) {
          super(`Number must be between ${min} and ${max}.`);
          Object.defineProperty(this, "min", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: min
          });
          Object.defineProperty(this, "max", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: max
          });
      }
  };

  const doubleDigit$1 = (number) => {
      if (number < 0 || number > 99)
          throw new NumberRangeError$1(0, 99);
      return String(number).padStart(2, '0');
  };

  const toDateString$2 = (date) => {
      return `${date.getFullYear()}-${doubleDigit$1(date.getMonth() + 1)}-${doubleDigit$1(date.getDate())}`;
  };
  const toTimeString$1 = (date) => {
      return `${doubleDigit$1(date.getHours())}:${doubleDigit$1(date.getMinutes())}`;
  };
  const toDateTimeString$2 = (date) => {
      return `${toDateString$2(date)} ${toTimeString$1(date)}`;
  };

  class InvalidTimeStringError extends Error {
      constructor(timeString) {
          super(`Invalid time string: ${timeString}`);
      }
  }

  const minuteTimePointMultiplier = 1.6666666666666667; // 100 / 60
  const timePointsFromString = (timeString) => {
      if (!timeStringRegex.test(timeString) && timeString !== '24:00')
          throw new InvalidTimeStringError(timeString);
      const [hoursInt, minutesInt] = timeString
          .split(':')
          .map((time) => parseInt(time, 10));
      let minutePoints = (minutesInt * minuteTimePointMultiplier).toString();
      if (minutePoints.split('.')[0].length < 2)
          minutePoints = `0${minutePoints}`;
      return Number(hoursInt + minutePoints);
  };

  const dateFromDateTime = (dateTime) => {
      return dateTime.slice(0, 10);
  };
  const timeFromDateTime = (dateTime) => {
      return dateTime.slice(11);
  };

  var WeekDay$1;
  (function (WeekDay) {
      WeekDay[WeekDay["SUNDAY"] = 0] = "SUNDAY";
      WeekDay[WeekDay["MONDAY"] = 1] = "MONDAY";
      WeekDay[WeekDay["TUESDAY"] = 2] = "TUESDAY";
      WeekDay[WeekDay["WEDNESDAY"] = 3] = "WEDNESDAY";
      WeekDay[WeekDay["THURSDAY"] = 4] = "THURSDAY";
      WeekDay[WeekDay["FRIDAY"] = 5] = "FRIDAY";
      WeekDay[WeekDay["SATURDAY"] = 6] = "SATURDAY";
  })(WeekDay$1 || (WeekDay$1 = {}));

  WeekDay$1.MONDAY;
  const DEFAULT_EVENT_COLOR_NAME = 'primary';

  class CalendarEventImpl {
      constructor(_config, id, start, end, title, people, location, description, calendarId, _options = undefined, _customContent = {}, _foreignProperties = {}) {
          Object.defineProperty(this, "_config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: _config
          });
          Object.defineProperty(this, "id", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: id
          });
          Object.defineProperty(this, "start", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: start
          });
          Object.defineProperty(this, "end", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: end
          });
          Object.defineProperty(this, "title", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: title
          });
          Object.defineProperty(this, "people", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: people
          });
          Object.defineProperty(this, "location", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: location
          });
          Object.defineProperty(this, "description", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: description
          });
          Object.defineProperty(this, "calendarId", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: calendarId
          });
          Object.defineProperty(this, "_options", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: _options
          });
          Object.defineProperty(this, "_customContent", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: _customContent
          });
          Object.defineProperty(this, "_foreignProperties", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: _foreignProperties
          });
          Object.defineProperty(this, "_previousConcurrentEvents", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "_totalConcurrentEvents", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "_nDaysInGrid", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "_eventFragments", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: {}
          });
      }
      get _isSingleDayTimed() {
          return (dateTimeStringRegex.test(this.start) &&
              dateTimeStringRegex.test(this.end) &&
              dateFromDateTime(this.start) === dateFromDateTime(this.end));
      }
      get _isSingleDayFullDay() {
          return (dateStringRegex.test(this.start) &&
              dateStringRegex.test(this.end) &&
              this.start === this.end);
      }
      get _isMultiDayTimed() {
          return (dateTimeStringRegex.test(this.start) &&
              dateTimeStringRegex.test(this.end) &&
              dateFromDateTime(this.start) !== dateFromDateTime(this.end));
      }
      get _isMultiDayFullDay() {
          return (dateStringRegex.test(this.start) &&
              dateStringRegex.test(this.end) &&
              this.start !== this.end);
      }
      get _isSingleHybridDayTimed() {
          if (!this._config.isHybridDay)
              return false;
          if (!dateTimeStringRegex.test(this.start) ||
              !dateTimeStringRegex.test(this.end))
              return false;
          const startDate = dateFromDateTime(this.start);
          const endDate = dateFromDateTime(this.end);
          const endDateMinusOneDay = toDateString$2(new Date(toJSDate$1(endDate).getTime() - 86400000));
          if (startDate !== endDate && startDate !== endDateMinusOneDay)
              return false;
          const dayBoundaries = this._config.dayBoundaries.value;
          const eventStartTimePoints = timePointsFromString(timeFromDateTime(this.start));
          const eventEndTimePoints = timePointsFromString(timeFromDateTime(this.end));
          return ((eventStartTimePoints >= dayBoundaries.start &&
              (eventEndTimePoints <= dayBoundaries.end ||
                  eventEndTimePoints > eventStartTimePoints)) ||
              (eventStartTimePoints < dayBoundaries.end &&
                  eventEndTimePoints <= dayBoundaries.end));
      }
      get _color() {
          if (this.calendarId &&
              this._config.calendars.value &&
              this.calendarId in this._config.calendars.value) {
              return this._config.calendars.value[this.calendarId].colorName;
          }
          return DEFAULT_EVENT_COLOR_NAME;
      }
      _getForeignProperties() {
          return this._foreignProperties;
      }
      _getExternalEvent() {
          return {
              id: this.id,
              start: this.start,
              end: this.end,
              title: this.title,
              people: this.people,
              location: this.location,
              description: this.description,
              calendarId: this.calendarId,
              _options: this._options,
              ...this._getForeignProperties(),
          };
      }
  }

  class CalendarEventBuilder {
      constructor(_config, id, start, end) {
          Object.defineProperty(this, "_config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: _config
          });
          Object.defineProperty(this, "id", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: id
          });
          Object.defineProperty(this, "start", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: start
          });
          Object.defineProperty(this, "end", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: end
          });
          Object.defineProperty(this, "people", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "location", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "description", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "title", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "calendarId", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "_foreignProperties", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: {}
          });
          Object.defineProperty(this, "_options", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: undefined
          });
          Object.defineProperty(this, "_customContent", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: {}
          });
      }
      build() {
          return new CalendarEventImpl(this._config, this.id, this.start, this.end, this.title, this.people, this.location, this.description, this.calendarId, this._options, this._customContent, this._foreignProperties);
      }
      withTitle(title) {
          this.title = title;
          return this;
      }
      withPeople(people) {
          this.people = people;
          return this;
      }
      withLocation(location) {
          this.location = location;
          return this;
      }
      withDescription(description) {
          this.description = description;
          return this;
      }
      withForeignProperties(foreignProperties) {
          this._foreignProperties = foreignProperties;
          return this;
      }
      withCalendarId(calendarId) {
          this.calendarId = calendarId;
          return this;
      }
      withOptions(options) {
          this._options = options;
          return this;
      }
      withCustomContent(customContent) {
          this._customContent = customContent;
          return this;
      }
  }

  const deepCloneEvent = (calendarEvent, $app) => {
      const calendarEventInternal = new CalendarEventBuilder($app.config, calendarEvent.id, calendarEvent.start, calendarEvent.end)
          .withTitle(calendarEvent.title)
          .withPeople(calendarEvent.people)
          .withCalendarId(calendarEvent.calendarId)
          .withForeignProperties(JSON.parse(JSON.stringify(calendarEvent._getForeignProperties())))
          .withLocation(calendarEvent.location)
          .withDescription(calendarEvent.description)
          .withOptions(calendarEvent._options)
          .withCustomContent(calendarEvent._customContent)
          .build();
      calendarEventInternal._nDaysInGrid = calendarEvent._nDaysInGrid;
      return calendarEventInternal;
  };

  const concatenatePeople = (people) => {
      return people.reduce((acc, person, index) => {
          if (index === 0)
              return person;
          if (index === people.length - 1)
              return `${acc} & ${person}`;
          return `${acc}, ${person}`;
      }, '');
  };

  const dateFn$1 = (dateTimeString, locale) => {
      const { year, month, date } = toIntegers$1(dateTimeString);
      return new Date(year, month, date).toLocaleDateString(locale, {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
      });
  };
  const timeFn = (dateTimeString, locale) => {
      const { year, month, date, hours, minutes } = toIntegers$1(dateTimeString);
      return new Date(year, month, date, hours, minutes).toLocaleTimeString(locale, {
          hour: 'numeric',
          minute: 'numeric',
      });
  };
  const getTimeStamp = (calendarEvent, // to facilitate testing. In reality, we will always have a full CalendarEventInternal
  locale, delimiter = '\u2013') => {
      const eventTime = { start: calendarEvent.start, end: calendarEvent.end };
      if (calendarEvent._isSingleDayFullDay) {
          return dateFn$1(eventTime.start, locale);
      }
      if (calendarEvent._isMultiDayFullDay) {
          return `${dateFn$1(eventTime.start, locale)} ${delimiter} ${dateFn$1(eventTime.end, locale)}`;
      }
      if (calendarEvent._isSingleDayTimed && eventTime.start !== eventTime.end) {
          return `${dateFn$1(eventTime.start, locale)} <span aria-hidden="true">â‹…</span> ${timeFn(eventTime.start, locale)} ${delimiter} ${timeFn(eventTime.end, locale)}`;
      }
      if (calendarEvent._isSingleDayTimed &&
          calendarEvent.start === calendarEvent.end) {
          return `${dateFn$1(eventTime.start, locale)}, ${timeFn(eventTime.start, locale)}`;
      }
      return `${dateFn$1(eventTime.start, locale)}, ${timeFn(eventTime.start, locale)} ${delimiter} ${dateFn$1(eventTime.end, locale)}, ${timeFn(eventTime.end, locale)}`;
  };

  /**
   * Can be used for generating a random id for an entity
   * Should, however, never be used in potentially resource intense loops,
   * since the performance cost of this compared to new Date().getTime() is ca x4 in v8
   * */
  const randomStringId$2 = () => 's' + Math.random().toString(36).substring(2, 11);
  const addMinutes = (to, nMinutes) => {
      const { year, month, date, hours, minutes } = toIntegers$1(to);
      const isDateTimeString = hours !== undefined && minutes !== undefined;
      const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
      jsDate.setMinutes(jsDate.getMinutes() + nMinutes);
      if (isDateTimeString) {
          return toDateTimeString$2(jsDate);
      }
      return toDateString$2(jsDate);
  };

  const createClickOutsideListener = ($app, modalId, withCallback) => {
      return function (e) {
          if (!(e.target instanceof HTMLElement))
              return;
          if (e.target.closest(`#${modalId}`))
              return;
          if (e.target.closest('.sx__interactive-event-modal__header'))
              return;
          if (e.target.closest('.sx__date-picker-popup'))
              return;
          if (e.target.closest('.sx__time-picker-popup'))
              return;
          if (e.target.closest('.sx__modal-delete-actions'))
              return;
          if (e.target.closest('.sx__event-form'))
              return;
          if (e.target.closest('.sx__app-combobox__list'))
              return;
          if (e.target.closest('.sx__app-select__list'))
              return;
          $app.config.plugins.eventModal.close();
          withCallback();
      };
  };

  const setPosition = (appDOMRect, eventDOMRect, modalHeight = 600, modalWidth = 540) => {
      eventDOMRect || (eventDOMRect = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          height: 0,
          width: 0,
          x: 0,
          y: 0,
          toJSON() { },
      });
      const MODAL_WIDTH = modalWidth;
      const INLINE_SPACE_BETWEEN_MODAL_AND_EVENT = 10;
      const WIDTH_NEEDED = MODAL_WIDTH + INLINE_SPACE_BETWEEN_MODAL_AND_EVENT;
      const hasSpaceTop = eventDOMRect.bottom - appDOMRect.top > modalHeight;
      const eventBottomLessThanAppBottom = eventDOMRect.bottom < appDOMRect.bottom;
      const eventTopLessThanAppTop = eventDOMRect.top < appDOMRect.top;
      let top = 0;
      let left = 0;
      let animationStart = '0%';
      if (appDOMRect.bottom - eventDOMRect.top > modalHeight &&
          !eventTopLessThanAppTop) {
          top = eventDOMRect.top;
      }
      else if (hasSpaceTop && eventBottomLessThanAppBottom) {
          top = eventDOMRect.bottom - modalHeight;
      }
      else if (hasSpaceTop && !eventBottomLessThanAppBottom) {
          top = appDOMRect.bottom - modalHeight;
      }
      else {
          top = appDOMRect.top;
      }
      if (appDOMRect.right - eventDOMRect.right > WIDTH_NEEDED) {
          left = eventDOMRect.right + INLINE_SPACE_BETWEEN_MODAL_AND_EVENT;
          animationStart = '-10%';
      }
      else if (eventDOMRect.left - appDOMRect.left > WIDTH_NEEDED) {
          left = eventDOMRect.left - WIDTH_NEEDED;
          animationStart = '10%';
      }
      else {
          left = appDOMRect.left;
      }
      document.documentElement.style.setProperty('--sx-event-modal-animation-start', animationStart);
      document.documentElement.style.setProperty('--sx-event-modal-top', `${top}px`);
      document.documentElement.style.setProperty('--sx-event-modal-left', `${left}px`);
  };

  function EditIcon({ color }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("svg", { className: "sx__modal-edit-icon", xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24", children: jsxRuntime.jsx("path", { fill: color, d: "M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z" }) }) }));
  }

  function TrashIcon({ color }) {
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("svg", { className: "sx__modal-trash-icon", xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24", children: jsxRuntime.jsx("path", { fill: color, d: "M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z" }) }) }));
  }

  const useIconColors = ($app) => {
      const ICON_COLOR_LIGHT_MODE = '#000';
      const ICON_COLOR_DARK_MODE = 'var(--sx-color-neutral-variant)';
      const iconColor = signals.signal($app.calendarState.isDark.value
          ? ICON_COLOR_DARK_MODE
          : ICON_COLOR_LIGHT_MODE);
      signals.effect(() => {
          if ($app.calendarState.isDark.value)
              iconColor.value = ICON_COLOR_DARK_MODE;
          else
              iconColor.value = ICON_COLOR_LIGHT_MODE;
      });
      return iconColor;
  };

  var ViewLevel;
  (function (ViewLevel) {
      ViewLevel["HOURLY"] = "hourly";
      ViewLevel["DAILY"] = "daily";
  })(ViewLevel || (ViewLevel = {}));

  function EventDisplay({ $app, calendarEvent }) {
      const iconColor = useIconColors($app);
      const modalPlugin = $app.config.plugins
          .eventModal;
      const currentViewIsResource = $app.calendarState.view.value === ViewLevel.HOURLY ||
          $app.calendarState.view.value === ViewLevel.DAILY;
      let resourceColorName = undefined;
      if (currentViewIsResource) {
          const resourceDefinition = $app.resourceViewConfig.resources.value.find((r) => r.id === calendarEvent._getForeignProperties().resourceId);
          resourceColorName = (resourceDefinition === null || resourceDefinition === void 0 ? void 0 : resourceDefinition.colorName) || 'primary';
      }
      const eventColorName = resourceColorName || calendarEvent._color;
      const openForm = () => {
          let originalEvent = undefined;
          modalPlugin.isEditingRecurringEvent.value = false;
          if (calendarEvent.isCopy ||
              ('rrule' in calendarEvent._getForeignProperties() &&
                  calendarEvent._getForeignProperties().rrule)) {
              originalEvent = $app.calendarEvents.list.value.find((event) => event.id === calendarEvent.id && !event.isCopy);
              modalPlugin.isEditingRecurringEvent.value = true;
          }
          modalPlugin.formValues.value = deepCloneEvent(originalEvent || calendarEvent, $app)._getExternalEvent();
          // hide modal before showing it again. This will make the transition smoother when repositioning the modal
          modalPlugin.isOpen.value = false;
          modalPlugin.modalState.value = 'edit';
          setTimeout(() => {
              modalPlugin.isOpen.value = true;
          }, 100);
      };
      const openDeleteActions = () => {
          modalPlugin.modalState.value = 'delete';
      };
      const additionalFields = $app.config._customComponentFns.interactiveModalAdditionalFields;
      const additionalFieldsId = hooks.useState(additionalFields ? randomStringId$2() : undefined)[0];
      hooks.useEffect(() => {
          if (additionalFields) {
              additionalFields(document.querySelector(`[data-ccid="${additionalFieldsId}"]`), {
                  calendarEvent,
              });
          }
      }, []);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsxs("header", { className: "sx__interactive-event-modal__header", children: [jsxRuntime.jsx("button", { className: "sx__modal-action-button", onClick: openForm, children: jsxRuntime.jsx(EditIcon, { color: 'rgb(128, 128, 128)' }) }), jsxRuntime.jsx("button", { className: "sx__modal-action-button", onClick: openDeleteActions, children: jsxRuntime.jsx(TrashIcon, { color: 'rgb(128, 128, 128)' }) })] }), jsxRuntime.jsxs("div", { className: "sx__has-icon sx__event-modal__title", children: [jsxRuntime.jsx("div", { style: {
                                  backgroundColor: `var(--sx-color-${eventColorName}-container)`,
                              }, "data-color": eventColorName, className: "sx__interactive-event-modal__color-icon sx__event-icon" }), calendarEvent.title] }), jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__time", children: [jsxRuntime.jsx(TimeIcon, { strokeColor: iconColor.value }), jsxRuntime.jsx("div", { dangerouslySetInnerHTML: {
                                  __html: getTimeStamp(calendarEvent, $app.config.locale.value),
                              } })] }), Array.isArray(calendarEvent.people) &&
                      calendarEvent.people.length > 0 && (jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__people", children: [jsxRuntime.jsx(UserIcon, { strokeColor: iconColor.value }), concatenatePeople(calendarEvent.people)] })), calendarEvent.location && (jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__location", children: [jsxRuntime.jsx(LocationPinIcon, { strokeColor: iconColor.value }), calendarEvent.location] })), calendarEvent.description && (jsxRuntime.jsxs("div", { className: "sx__has-icon sx__interactive-event-modal__description", children: [jsxRuntime.jsx(DescriptionIcon, { strokeColor: iconColor.value }), calendarEvent.description] })), additionalFields && (jsxRuntime.jsx("div", { "data-ccid": additionalFieldsId, className: "sx__interactive-event-modal__additional-fields" }))] }) }));
  }

  function TextField({ initialValue, onChange, label, fieldName, id, errorMessage, }) {
      const [inputValue, setInputValue] = hooks.useState(initialValue);
      const handleInput = (newValue) => {
          setInputValue(newValue);
          onChange(newValue);
      };
      const BASE_WRAPPER_CLASS = 'sx__text-field-wrapper';
      const [wrapperClasses, setWrapperClasses] = hooks.useState([BASE_WRAPPER_CLASS]);
      hooks.useEffect(() => {
          if (inputValue.length > 0) {
              if (!wrapperClasses.includes('sx__has-value')) {
                  setWrapperClasses([BASE_WRAPPER_CLASS, 'sx__has-value']);
              }
          }
          else {
              if (wrapperClasses.includes('sx__has-value')) {
                  setWrapperClasses([BASE_WRAPPER_CLASS]);
              }
          }
      }, [inputValue]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { className: wrapperClasses.join(' '), children: [jsxRuntime.jsx("input", { id: id, className: 'sx__text-field-input', value: inputValue, onInput: (e) => handleInput(e.currentTarget.value), name: fieldName, type: "text" }), jsxRuntime.jsx("label", { className: 'sx__text-field-label', htmlFor: fieldName, children: label })] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
  }

  function AppButton({ onClick, children, additionalClasses, }) {
      return (jsxRuntime.jsx("button", { className: 'sx__app-button' + (additionalClasses ? ` ${additionalClasses}` : ''), onClick: onClick, children: children }));
  }

  const AppContext$1 = preact.createContext({});

  const DateFormats = {
      DATE_STRING: /^\d{4}-\d{2}-\d{2}$/,
      TIME_STRING: /^\d{2}:\d{2}$/,
      DATE_TIME_STRING: /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/,
  };

  class InvalidDateTimeError extends Error {
      constructor(dateTimeSpecification) {
          super(`Invalid date time specification: ${dateTimeSpecification}`);
      }
  }

  const toJSDate = (dateTimeSpecification) => {
      if (!DateFormats.DATE_TIME_STRING.test(dateTimeSpecification) &&
          !DateFormats.DATE_STRING.test(dateTimeSpecification))
          throw new InvalidDateTimeError(dateTimeSpecification);
      return new Date(Number(dateTimeSpecification.slice(0, 4)), Number(dateTimeSpecification.slice(5, 7)) - 1, Number(dateTimeSpecification.slice(8, 10)), Number(dateTimeSpecification.slice(11, 13)), // for date strings this will be 0
      Number(dateTimeSpecification.slice(14, 16)) // for date strings this will be 0
      );
  };
  const toIntegers = (dateTimeSpecification) => {
      const hours = dateTimeSpecification.slice(11, 13), minutes = dateTimeSpecification.slice(14, 16);
      return {
          year: Number(dateTimeSpecification.slice(0, 4)),
          month: Number(dateTimeSpecification.slice(5, 7)) - 1,
          date: Number(dateTimeSpecification.slice(8, 10)),
          hours: hours !== '' ? Number(hours) : undefined,
          minutes: minutes !== '' ? Number(minutes) : undefined,
      };
  };

  const toLocalizedMonth = (date, locale) => {
      return date.toLocaleString(locale, { month: 'long' });
  };
  const toLocalizedDateString = (date, locale) => {
      return date.toLocaleString(locale, {
          month: 'numeric',
          day: 'numeric',
          year: 'numeric',
      });
  };
  const getOneLetterDayNames = (week, locale) => {
      return week.map((date) => {
          return date.toLocaleString(locale, { weekday: 'short' }).charAt(0);
      });
  };
  const getDayNameShort = (date, locale) => date.toLocaleString(locale, { weekday: 'short' });
  const getDayNamesShort = (week, locale) => {
      return week.map((date) => getDayNameShort(date, locale));
  };
  const getOneLetterOrShortDayNames = (week, locale) => {
      if (['zh-cn', 'zh-tw', 'ca-es'].includes(locale.toLowerCase())) {
          return getDayNamesShort(week, locale);
      }
      return getOneLetterDayNames(week, locale);
  };

  var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='utf-8'%3f%3e%3c!-- Uploaded to: SVG Repo%2c www.svgrepo.com%2c Generator: SVG Repo Mixer Tools --%3e%3csvg width='800px' height='800px' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M6 9L12 15L18 9' stroke='%23DED8E1' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e";

  /**
   * Can be used for generating a random id for an entity
   * Should, however, never be used in potentially resource intense loops,
   * since the performance cost of this compared to new Date().getTime() is ca x4 in v8
   * */
  const randomStringId$1 = () => 's' + Math.random().toString(36).substring(2, 11);

  const isKeyEnterOrSpace = (keyboardEvent) => keyboardEvent.key === 'Enter' || keyboardEvent.key === ' ';

  function AppInput$1() {
      const datePickerInputId = randomStringId$1();
      const datePickerLabelId = randomStringId$1();
      const inputWrapperId = randomStringId$1();
      const $app = hooks.useContext(AppContext$1);
      const getLocalizedDate = (dateString) => {
          if (dateString === '')
              return $app.translate('MM/DD/YYYY');
          return toLocalizedDateString(toJSDate(dateString), $app.config.locale.value);
      };
      hooks.useEffect(() => {
          $app.datePickerState.inputDisplayedValue.value = getLocalizedDate($app.datePickerState.selectedDate.value);
      }, [$app.datePickerState.selectedDate.value, $app.config.locale.value]);
      const [wrapperClasses, setWrapperClasses] = hooks.useState([]);
      const setInputElement = () => {
          const inputWrapperEl = document.getElementById(inputWrapperId);
          $app.datePickerState.inputWrapperElement.value =
              inputWrapperEl instanceof HTMLDivElement ? inputWrapperEl : undefined;
      };
      hooks.useEffect(() => {
          if ($app.config.teleportTo)
              setInputElement();
          const newClasses = ['sx__date-input-wrapper'];
          if ($app.datePickerState.isOpen.value)
              newClasses.push('sx__date-input--active');
          setWrapperClasses(newClasses);
      }, [$app.datePickerState.isOpen.value]);
      const handleKeyUp = (event) => {
          if (event.key === 'Enter')
              handleInputValue(event);
      };
      const handleInputValue = (event) => {
          event.stopPropagation(); // prevent date picker from closing
          try {
              $app.datePickerState.inputDisplayedValue.value = event.target.value;
              $app.datePickerState.close();
          }
          catch (e) {
              // nothing to do
          }
      };
      hooks.useEffect(() => {
          const inputElement = document.getElementById(datePickerInputId);
          if (inputElement === null)
              return;
          inputElement.addEventListener('change', handleInputValue); // Preact onChange triggers on every input
          return () => inputElement.removeEventListener('change', handleInputValue);
      });
      const handleClick = (event) => {
          handleInputValue(event);
          $app.datePickerState.open();
      };
      const handleButtonKeyDown = (keyboardEvent) => {
          if (isKeyEnterOrSpace(keyboardEvent)) {
              keyboardEvent.preventDefault();
              $app.datePickerState.open();
              setTimeout(() => {
                  const element = document.querySelector('[data-focus="true"]');
                  if (element instanceof HTMLElement)
                      element.focus();
              }, 50);
          }
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { className: wrapperClasses.join(' '), id: inputWrapperId, children: [jsxRuntime.jsx("label", { for: datePickerInputId, id: datePickerLabelId, className: "sx__date-input-label", children: $app.config.label || $app.translate('Date') }), jsxRuntime.jsx("input", { id: datePickerInputId, tabIndex: $app.datePickerState.isDisabled.value ? -1 : 0, name: $app.config.name || 'date', "aria-describedby": datePickerLabelId, value: $app.datePickerState.inputDisplayedValue.value, "data-testid": "date-picker-input", className: "sx__date-input", onClick: handleClick, onKeyUp: handleKeyUp, type: "text" }), jsxRuntime.jsx("button", { type: "button", tabIndex: $app.datePickerState.isDisabled.value ? -1 : 0, "aria-label": $app.translate('Choose Date'), onKeyDown: handleButtonKeyDown, onClick: () => $app.datePickerState.open(), className: "sx__date-input-chevron-wrapper", children: jsxRuntime.jsx("img", { className: "sx__date-input-chevron", src: img, alt: "" }) })] }) }));
  }

  var DatePickerView;
  (function (DatePickerView) {
      DatePickerView["MONTH_DAYS"] = "month-days";
      DatePickerView["YEARS"] = "years";
  })(DatePickerView || (DatePickerView = {}));

  const YEARS_VIEW = 'years-view';
  const MONTH_VIEW = 'months-view';
  const DATE_PICKER_WEEK = 'date-picker-week';

  class NumberRangeError extends Error {
      constructor(min, max) {
          super(`Number must be between ${min} and ${max}.`);
          Object.defineProperty(this, "min", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: min
          });
          Object.defineProperty(this, "max", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: max
          });
      }
  }

  const doubleDigit = (number) => {
      if (number < 0 || number > 99)
          throw new NumberRangeError(0, 99);
      return String(number).padStart(2, '0');
  };

  const toDateString$1 = (date) => {
      return `${date.getFullYear()}-${doubleDigit(date.getMonth() + 1)}-${doubleDigit(date.getDate())}`;
  };
  const toTimeString = (date) => {
      return `${doubleDigit(date.getHours())}:${doubleDigit(date.getMinutes())}`;
  };
  const toDateTimeString$1 = (date) => {
      return `${toDateString$1(date)} ${toTimeString(date)}`;
  };

  const addMonths = (to, nMonths) => {
      const { year, month, date, hours, minutes } = toIntegers(to);
      const isDateTimeString = hours !== undefined && minutes !== undefined;
      const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
      let expectedMonth = (jsDate.getMonth() + nMonths) % 12;
      if (expectedMonth < 0)
          expectedMonth += 12;
      jsDate.setMonth(jsDate.getMonth() + nMonths);
      // handle date overflow and underflow
      if (jsDate.getMonth() > expectedMonth) {
          jsDate.setDate(0);
      }
      else if (jsDate.getMonth() < expectedMonth) {
          jsDate.setMonth(jsDate.getMonth() + 1);
          jsDate.setDate(0);
      }
      if (isDateTimeString) {
          return toDateTimeString$1(jsDate);
      }
      return toDateString$1(jsDate);
  };
  const addDays = (to, nDays) => {
      const { year, month, date, hours, minutes } = toIntegers(to);
      const isDateTimeString = hours !== undefined && minutes !== undefined;
      const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
      jsDate.setDate(jsDate.getDate() + nDays);
      if (isDateTimeString) {
          return toDateTimeString$1(jsDate);
      }
      return toDateString$1(jsDate);
  };

  const setDateOfMonth = (dateString, date) => {
      dateString = dateString.slice(0, 8) + doubleDigit(date) + dateString.slice(10);
      return dateString;
  };
  const getFirstDayOPreviousMonth = (dateString) => {
      dateString = addMonths(dateString, -1);
      return setDateOfMonth(dateString, 1);
  };
  const getFirstDayOfNextMonth = (dateString) => {
      dateString = addMonths(dateString, 1);
      return setDateOfMonth(dateString, 1);
  };

  function Chevron({ direction, onClick, buttonText, disabled = false, }) {
      const handleKeyDown = (keyboardEvent) => {
          if (isKeyEnterOrSpace(keyboardEvent))
              onClick();
      };
      return (jsxRuntime.jsx("button", { type: "button", disabled: disabled, className: "sx__chevron-wrapper sx__ripple", onMouseUp: onClick, onKeyDown: handleKeyDown, tabIndex: 0, children: jsxRuntime.jsx("i", { className: `sx__chevron sx__chevron--${direction}`, children: buttonText }) }));
  }

  function MonthViewHeader({ setYearsView }) {
      const $app = hooks.useContext(AppContext$1);
      const dateStringToLocalizedMonthName = (selectedDate) => {
          const selectedDateJS = toJSDate(selectedDate);
          return toLocalizedMonth(selectedDateJS, $app.config.locale.value);
      };
      const getYearFrom = (datePickerDate) => {
          return toIntegers(datePickerDate).year;
      };
      const [selectedDateMonthName, setSelectedDateMonthName] = hooks.useState(dateStringToLocalizedMonthName($app.datePickerState.datePickerDate.value));
      const [datePickerYear, setDatePickerYear] = hooks.useState(getYearFrom($app.datePickerState.datePickerDate.value));
      const setPreviousMonth = () => {
          $app.datePickerState.datePickerDate.value = getFirstDayOPreviousMonth($app.datePickerState.datePickerDate.value);
      };
      const setNextMonth = () => {
          $app.datePickerState.datePickerDate.value = getFirstDayOfNextMonth($app.datePickerState.datePickerDate.value);
      };
      hooks.useEffect(() => {
          setSelectedDateMonthName(dateStringToLocalizedMonthName($app.datePickerState.datePickerDate.value));
          setDatePickerYear(getYearFrom($app.datePickerState.datePickerDate.value));
      }, [$app.datePickerState.datePickerDate.value]);
      const handleOpenYearsView = (e) => {
          e.stopPropagation();
          setYearsView();
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("header", { className: "sx__date-picker__month-view-header", children: [jsxRuntime.jsx(Chevron, { direction: 'previous', onClick: () => setPreviousMonth(), buttonText: $app.translate('Previous month') }), jsxRuntime.jsx("button", { type: "button", className: "sx__date-picker__month-view-header__month-year", onClick: (event) => handleOpenYearsView(event), children: selectedDateMonthName + ' ' + datePickerYear }), jsxRuntime.jsx(Chevron, { direction: 'next', onClick: () => setNextMonth(), buttonText: $app.translate('Next month') })] }) }));
  }

  function DayNames() {
      const $app = hooks.useContext(AppContext$1);
      const aWeek = $app.timeUnitsImpl.getWeekFor(toJSDate($app.datePickerState.datePickerDate.value));
      const dayNames = getOneLetterOrShortDayNames(aWeek, $app.config.locale.value);
      return (jsxRuntime.jsx("div", { className: "sx__date-picker__day-names", children: dayNames.map((dayName) => (jsxRuntime.jsx("span", { "data-testid": "day-name", className: "sx__date-picker__day-name", children: dayName }))) }));
  }

  const isToday = (date) => {
      const today = new Date();
      return (date.getDate() === today.getDate() &&
          date.getMonth() === today.getMonth() &&
          date.getFullYear() === today.getFullYear());
  };
  const isSameMonth = (date1, date2) => {
      return (date1.getMonth() === date2.getMonth() &&
          date1.getFullYear() === date2.getFullYear());
  };

  var WeekDay;
  (function (WeekDay) {
      WeekDay[WeekDay["SUNDAY"] = 0] = "SUNDAY";
      WeekDay[WeekDay["MONDAY"] = 1] = "MONDAY";
      WeekDay[WeekDay["TUESDAY"] = 2] = "TUESDAY";
      WeekDay[WeekDay["WEDNESDAY"] = 3] = "WEDNESDAY";
      WeekDay[WeekDay["THURSDAY"] = 4] = "THURSDAY";
      WeekDay[WeekDay["FRIDAY"] = 5] = "FRIDAY";
      WeekDay[WeekDay["SATURDAY"] = 6] = "SATURDAY";
  })(WeekDay || (WeekDay = {}));

  const DEFAULT_LOCALE = 'en-US';
  const DEFAULT_FIRST_DAY_OF_WEEK = WeekDay.MONDAY;

  const dateFn = (dateTimeString, locale) => {
      const { year, month, date } = toIntegers(dateTimeString);
      return new Date(year, month, date).toLocaleDateString(locale, {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
      });
  };
  const getLocalizedDate = dateFn;

  function MonthViewWeek({ week }) {
      const $app = hooks.useContext(AppContext$1);
      const weekDays = week.map((day) => {
          const classes = ['sx__date-picker__day'];
          if (isToday(day))
              classes.push('sx__date-picker__day--today');
          if (toDateString$1(day) === $app.datePickerState.selectedDate.value)
              classes.push('sx__date-picker__day--selected');
          if (!isSameMonth(day, toJSDate($app.datePickerState.datePickerDate.value)))
              classes.push('is-leading-or-trailing');
          return {
              day,
              classes,
          };
      });
      const isDateSelectable = (date) => {
          const dateString = toDateString$1(date);
          return dateString >= $app.config.min && dateString <= $app.config.max;
      };
      const selectDate = (date) => {
          $app.datePickerState.selectedDate.value = toDateString$1(date);
          $app.datePickerState.close();
      };
      const hasFocus = (weekDay) => toDateString$1(weekDay.day) === $app.datePickerState.datePickerDate.value;
      const handleKeyDown = (event) => {
          if (event.key === 'Enter') {
              $app.datePickerState.selectedDate.value =
                  $app.datePickerState.datePickerDate.value;
              $app.datePickerState.close();
              return;
          }
          const keyMapDaysToAdd = new Map([
              ['ArrowDown', 7],
              ['ArrowUp', -7],
              ['ArrowLeft', -1],
              ['ArrowRight', 1],
          ]);
          $app.datePickerState.datePickerDate.value = addDays($app.datePickerState.datePickerDate.value, keyMapDaysToAdd.get(event.key) || 0);
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { "data-testid": DATE_PICKER_WEEK, className: "sx__date-picker__week", children: weekDays.map((weekDay) => (jsxRuntime.jsx("button", { type: "button", tabIndex: hasFocus(weekDay) ? 0 : -1, disabled: !isDateSelectable(weekDay.day), "aria-label": getLocalizedDate($app.datePickerState.datePickerDate.value, $app.config.locale.value), className: weekDay.classes.join(' '), "data-focus": hasFocus(weekDay) ? 'true' : undefined, onClick: () => selectDate(weekDay.day), onKeyDown: handleKeyDown, children: weekDay.day.getDate() }))) }) }));
  }

  function MonthView({ seatYearsView }) {
      const elementId = randomStringId$1();
      const $app = hooks.useContext(AppContext$1);
      const [month, setMonth] = hooks.useState([]);
      const renderMonth = () => {
          const newDatePickerDate = toJSDate($app.datePickerState.datePickerDate.value);
          setMonth($app.timeUnitsImpl.getMonthWithTrailingAndLeadingDays(newDatePickerDate.getFullYear(), newDatePickerDate.getMonth()));
      };
      hooks.useEffect(() => {
          renderMonth();
      }, [$app.datePickerState.datePickerDate.value]);
      hooks.useEffect(() => {
          const observer = new MutationObserver((mutations) => {
              mutations.forEach((mutation) => {
                  const mutatedElement = mutation.target;
                  if (mutatedElement.dataset.focus === 'true')
                      mutatedElement.focus();
              });
          });
          const monthViewElement = document.getElementById(elementId);
          observer.observe(monthViewElement, {
              childList: true,
              subtree: true,
              attributes: true,
          });
          return () => observer.disconnect();
      }, []);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { id: elementId, "data-testid": MONTH_VIEW, className: "sx__date-picker__month-view", children: [jsxRuntime.jsx(MonthViewHeader, { setYearsView: seatYearsView }), jsxRuntime.jsx(DayNames, {}), month.map((week) => (jsxRuntime.jsx(MonthViewWeek, { week: week })))] }) }));
  }

  function YearsViewAccordion({ year, setYearAndMonth, isExpanded, expand, }) {
      const $app = hooks.useContext(AppContext$1);
      const yearWithDates = $app.timeUnitsImpl.getMonthsFor(year);
      const handleClickOnMonth = (event, month) => {
          event.stopPropagation();
          setYearAndMonth(year, month.getMonth());
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("li", { className: isExpanded ? 'sx__is-expanded' : '', children: [jsxRuntime.jsx("button", { type: "button", className: "sx__date-picker__years-accordion__expand-button sx__ripple--wide", onClick: () => expand(year), children: year }), isExpanded && (jsxRuntime.jsx("div", { className: "sx__date-picker__years-view-accordion__panel", children: yearWithDates.map((month) => (jsxRuntime.jsx("button", { type: "button", className: "sx__date-picker__years-view-accordion__month", onClick: (event) => handleClickOnMonth(event, month), children: toLocalizedMonth(month, $app.config.locale.value) }))) }))] }) }));
  }

  function YearsView({ setMonthView }) {
      const $app = hooks.useContext(AppContext$1);
      const minYear = toJSDate($app.config.min).getFullYear();
      const maxYear = toJSDate($app.config.max).getFullYear();
      const years = Array.from({ length: maxYear - minYear + 1 }, (_, i) => minYear + i);
      const { year: selectedYear } = toIntegers($app.datePickerState.selectedDate.value);
      const [expandedYear, setExpandedYear] = hooks.useState(selectedYear);
      const setNewDatePickerDate = (year, month) => {
          $app.datePickerState.datePickerDate.value = toDateString$1(new Date(year, month, 1));
          setMonthView();
      };
      hooks.useEffect(() => {
          var _a;
          const initiallyExpandedYear = (_a = document
              .querySelector('.sx__date-picker__years-view')) === null || _a === void 0 ? void 0 : _a.querySelector('.sx__is-expanded');
          if (!initiallyExpandedYear)
              return;
          initiallyExpandedYear.scrollIntoView({
              block: 'center',
          });
      }, []);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("ul", { className: "sx__date-picker__years-view", "data-testid": YEARS_VIEW, children: years.map((year) => (jsxRuntime.jsx(YearsViewAccordion, { year: year, setYearAndMonth: (year, month) => setNewDatePickerDate(year, month), isExpanded: expandedYear === year, expand: (year) => setExpandedYear(year) }))) }) }));
  }

  const isScrollable$2 = (el) => {
      if (el) {
          const hasScrollableContent = el.scrollHeight > el.clientHeight;
          const overflowYStyle = window.getComputedStyle(el).overflowY;
          const isOverflowHidden = overflowYStyle.indexOf('hidden') !== -1;
          return hasScrollableContent && !isOverflowHidden;
      }
      return true;
  };
  const getScrollableParents$2 = (el, acc = []) => {
      if (!el ||
          el === document.body ||
          el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          acc.push(window);
          return acc;
      }
      if (isScrollable$2(el)) {
          acc.push(el);
      }
      return getScrollableParents$2((el.assignedSlot
          ? el.assignedSlot.parentNode
          : el.parentNode), acc);
  };

  const POPUP_CLASS_NAME = 'sx__date-picker-popup';
  function AppPopup$1() {
      const $app = hooks.useContext(AppContext$1);
      const [datePickerView, setDatePickerView] = hooks.useState(DatePickerView.MONTH_DAYS);
      const basePopupClasses = [POPUP_CLASS_NAME, $app.config.placement];
      const [classList, setClassList] = hooks.useState(basePopupClasses);
      hooks.useEffect(() => {
          setClassList([
              ...basePopupClasses,
              $app.datePickerState.isDark.value ? 'is-dark' : '',
              $app.config.teleportTo ? 'is-teleported' : '',
          ]);
      }, [$app.datePickerState.isDark.value]);
      const clickOutsideListener = (event) => {
          const target = event.target;
          if (!target.closest(`.${POPUP_CLASS_NAME}`))
              $app.datePickerState.close();
      };
      const escapeKeyListener = (e) => {
          if (e.key === 'Escape') {
              if ($app.config.listeners.onEscapeKeyDown)
                  $app.config.listeners.onEscapeKeyDown($app);
              else
                  $app.datePickerState.close();
          }
      };
      hooks.useEffect(() => {
          document.addEventListener('click', clickOutsideListener);
          document.addEventListener('keydown', escapeKeyListener);
          return () => {
              document.removeEventListener('click', clickOutsideListener);
              document.removeEventListener('keydown', escapeKeyListener);
          };
      }, []);
      const remSize = Number(getComputedStyle(document.documentElement).fontSize.split('px')[0]);
      const popupHeight = 362;
      const popupWidth = 332;
      const getFixedPositionStyles = () => {
          const inputWrapperEl = $app.datePickerState.inputWrapperElement.value;
          const inputRect = inputWrapperEl === null || inputWrapperEl === void 0 ? void 0 : inputWrapperEl.getBoundingClientRect();
          if (inputWrapperEl === undefined || !(inputRect instanceof DOMRect))
              return undefined;
          return {
              top: $app.config.placement.includes('bottom')
                  ? inputRect.height + inputRect.y + 1 // 1px border
                  : inputRect.y - remSize - popupHeight, // subtract remsize to leave room for label text
              left: $app.config.placement.includes('start')
                  ? inputRect.x
                  : inputRect.x + inputRect.width - popupWidth,
              width: popupWidth,
              position: 'fixed',
          };
      };
      const [fixedPositionStyle, setFixedPositionStyle] = hooks.useState(getFixedPositionStyles());
      hooks.useEffect(() => {
          const inputWrapper = $app.datePickerState.inputWrapperElement.value;
          if (inputWrapper === undefined)
              return;
          const scrollableParents = getScrollableParents$2(inputWrapper);
          const scrollListener = () => setFixedPositionStyle(getFixedPositionStyles());
          scrollableParents.forEach((parent) => parent.addEventListener('scroll', scrollListener));
          return () => scrollableParents.forEach((parent) => parent.removeEventListener('scroll', scrollListener));
      }, []);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { style: $app.config.teleportTo ? fixedPositionStyle : undefined, "data-testid": "date-picker-popup", className: classList.join(' '), children: datePickerView === DatePickerView.MONTH_DAYS ? (jsxRuntime.jsx(MonthView, { seatYearsView: () => setDatePickerView(DatePickerView.YEARS) })) : (jsxRuntime.jsx(YearsView, { setMonthView: () => setDatePickerView(DatePickerView.MONTH_DAYS) })) }) }));
  }

  function AppWrapper({ $app }) {
      const initialClassList = ['sx__date-picker-wrapper'];
      const [classList, setClassList] = hooks.useState(initialClassList);
      hooks.useEffect(() => {
          var _a;
          const list = [...initialClassList];
          if ($app.datePickerState.isDark.value)
              list.push('is-dark');
          if ((_a = $app.config.style) === null || _a === void 0 ? void 0 : _a.fullWidth)
              list.push('has-full-width');
          if ($app.datePickerState.isDisabled.value)
              list.push('is-disabled');
          setClassList(list);
      }, [$app.datePickerState.isDark.value, $app.datePickerState.isDisabled.value]);
      let appPopupJSX = jsxRuntime.jsx(AppPopup$1, {});
      if ($app.config.teleportTo)
          appPopupJSX = compat.createPortal(appPopupJSX, $app.config.teleportTo);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { className: classList.join(' '), children: jsxRuntime.jsxs(AppContext$1.Provider, { value: $app, children: [jsxRuntime.jsx(AppInput$1, {}), $app.datePickerState.isOpen.value && appPopupJSX] }) }) }));
  }

  class DatePickerApp {
      constructor($app) {
          Object.defineProperty(this, "$app", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: $app
          });
      }
      render(el) {
          preact.render(preact.createElement(AppWrapper, {
              $app: this.$app,
          }), el);
      }
      get value() {
          return this.$app.datePickerState.selectedDate.value;
      }
      set value(value) {
          this.$app.datePickerState.selectedDate.value = value;
      }
      get disabled() {
          return this.$app.datePickerState.isDisabled.value;
      }
      set disabled(value) {
          this.$app.datePickerState.isDisabled.value = value;
      }
      setTheme(theme) {
          this.$app.datePickerState.isDark.value = theme === 'dark';
      }
      getTheme() {
          return this.$app.datePickerState.isDark.value ? 'dark' : 'light';
      }
  }

  var Month;
  (function (Month) {
      Month[Month["JANUARY"] = 0] = "JANUARY";
      Month[Month["FEBRUARY"] = 1] = "FEBRUARY";
      Month[Month["MARCH"] = 2] = "MARCH";
      Month[Month["APRIL"] = 3] = "APRIL";
      Month[Month["MAY"] = 4] = "MAY";
      Month[Month["JUNE"] = 5] = "JUNE";
      Month[Month["JULY"] = 6] = "JULY";
      Month[Month["AUGUST"] = 7] = "AUGUST";
      Month[Month["SEPTEMBER"] = 8] = "SEPTEMBER";
      Month[Month["OCTOBER"] = 9] = "OCTOBER";
      Month[Month["NOVEMBER"] = 10] = "NOVEMBER";
      Month[Month["DECEMBER"] = 11] = "DECEMBER";
  })(Month || (Month = {}));

  class NoYearZeroError extends Error {
      constructor() {
          super('Year zero does not exist in the Gregorian calendar.');
      }
  }

  class ExtendedDateImpl extends Date {
      constructor(yearArg, monthArg, dateArg) {
          super(yearArg, monthArg, dateArg);
          if (yearArg === 0)
              throw new NoYearZeroError();
          this.setFullYear(yearArg); // Overwrite the behavior of JS-Date, whose constructor does not allow years 0-99
      }
      get year() {
          return this.getFullYear();
      }
      get month() {
          return this.getMonth();
      }
      get date() {
          return this.getDate();
      }
  }

  class TimeUnitsImpl {
      constructor(config) {
          Object.defineProperty(this, "config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: config
          });
      }
      get firstDayOfWeek() {
          return this.config.firstDayOfWeek.value;
      }
      set firstDayOfWeek(firstDayOfWeek) {
          this.config.firstDayOfWeek.value = firstDayOfWeek;
      }
      getMonthWithTrailingAndLeadingDays(year, month) {
          if (year === 0)
              throw new NoYearZeroError();
          const firstDateOfMonth = new Date(year, month, 1);
          const monthWithDates = [this.getWeekFor(firstDateOfMonth)];
          let isInMonth = true;
          let first = monthWithDates[0][0]; // first day of first week of month
          while (isInMonth) {
              const newFirstDayOfWeek = new Date(first.getFullYear(), first.getMonth(), first.getDate() + 7);
              if (newFirstDayOfWeek.getMonth() === month) {
                  monthWithDates.push(this.getWeekFor(newFirstDayOfWeek));
                  first = newFirstDayOfWeek;
              }
              else {
                  isInMonth = false;
              }
          }
          return monthWithDates;
      }
      getWeekFor(date) {
          const week = [this.getFirstDateOfWeek(date)];
          while (week.length < 7) {
              const lastDateOfWeek = week[week.length - 1];
              const nextDateOfWeek = new Date(lastDateOfWeek);
              nextDateOfWeek.setDate(lastDateOfWeek.getDate() + 1);
              week.push(nextDateOfWeek);
          }
          return week;
      }
      getMonthsFor(year) {
          return Object.values(Month)
              .filter((month) => !isNaN(Number(month)))
              .map((month) => new ExtendedDateImpl(year, Number(month), 1));
      }
      getFirstDateOfWeek(date) {
          const dateIsNthDayOfWeek = date.getDay() - this.firstDayOfWeek;
          const firstDateOfWeek = date;
          if (dateIsNthDayOfWeek === 0) {
              return firstDateOfWeek;
          }
          else if (dateIsNthDayOfWeek > 0) {
              firstDateOfWeek.setDate(date.getDate() - dateIsNthDayOfWeek);
          }
          else {
              firstDateOfWeek.setDate(date.getDate() - (7 + dateIsNthDayOfWeek));
          }
          return firstDateOfWeek;
      }
  }

  class TimeUnitsBuilder {
      constructor() {
          Object.defineProperty(this, "config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
      }
      build() {
          return new TimeUnitsImpl(this.config);
      }
      withConfig(config) {
          this.config = config;
          return this;
      }
  }

  var DateFormatDelimiter;
  (function (DateFormatDelimiter) {
      DateFormatDelimiter["SLASH"] = "/";
      DateFormatDelimiter["DASH"] = "-";
      DateFormatDelimiter["PERIOD"] = ".";
  })(DateFormatDelimiter || (DateFormatDelimiter = {}));
  var DateFormatOrder;
  (function (DateFormatOrder) {
      DateFormatOrder["DMY"] = "DMY";
      DateFormatOrder["MDY"] = "MDY";
      DateFormatOrder["YMD"] = "YMD";
  })(DateFormatOrder || (DateFormatOrder = {}));

  const formatRules = {
      slashMDY: {
          delimiter: DateFormatDelimiter.SLASH,
          order: DateFormatOrder.MDY,
      },
      slashDMY: {
          delimiter: DateFormatDelimiter.SLASH,
          order: DateFormatOrder.DMY,
      },
      slashYMD: {
          delimiter: DateFormatDelimiter.SLASH,
          order: DateFormatOrder.YMD,
      },
      periodDMY: {
          delimiter: DateFormatDelimiter.PERIOD,
          order: DateFormatOrder.DMY,
      },
      dashYMD: {
          delimiter: DateFormatDelimiter.DASH,
          order: DateFormatOrder.YMD,
      },
  };
  const dateFormatLocalizedRules = new Map([
      ['en-US', formatRules.slashMDY],
      ['en-GB', formatRules.slashDMY],
      ['zh-CN', formatRules.slashYMD],
      ['de-DE', formatRules.periodDMY],
      ['sv-SE', formatRules.dashYMD],
  ]);

  class LocaleNotSupportedError extends Error {
      constructor(locale) {
          super(`Locale not supported: ${locale}`);
      }
  }

  class InvalidDateFormatError extends Error {
      constructor(dateFormat, locale) {
          super(`Invalid date format: ${dateFormat} for locale: ${locale}`);
      }
  }

  const _getMatchesOrThrow = (format, matcher, locale) => {
      const matches = format.match(matcher);
      if (!matches)
          throw new InvalidDateFormatError(format, locale);
      return matches;
  };
  const toDateString = (format, locale) => {
      const internationalFormat = /^\d{4}-\d{2}-\d{2}$/;
      if (internationalFormat.test(format))
          return format; // allow international format regardless of locale
      const localeDateFormatRule = dateFormatLocalizedRules.get(locale);
      if (!localeDateFormatRule)
          throw new LocaleNotSupportedError(locale);
      const { order, delimiter } = localeDateFormatRule;
      const pattern224Slashed = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/;
      const pattern224Dotted = /^(\d{1,2})\.(\d{1,2})\.(\d{4})$/;
      const pattern442Slashed = /^(\d{4})\/(\d{1,2})\/(\d{1,2})$/;
      if (order === DateFormatOrder.DMY && delimiter === DateFormatDelimiter.SLASH) {
          const matches = _getMatchesOrThrow(format, pattern224Slashed, locale);
          const [, day, month, year] = matches;
          return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
      }
      if (order === DateFormatOrder.MDY && delimiter === DateFormatDelimiter.SLASH) {
          const matches = _getMatchesOrThrow(format, pattern224Slashed, locale);
          const [, month, day, year] = matches;
          return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
      }
      if (order === DateFormatOrder.YMD && delimiter === DateFormatDelimiter.SLASH) {
          const matches = _getMatchesOrThrow(format, pattern442Slashed, locale);
          const [, year, month, day] = matches;
          return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
      }
      if (order === DateFormatOrder.DMY && delimiter === DateFormatDelimiter.PERIOD) {
          const matches = _getMatchesOrThrow(format, pattern224Dotted, locale);
          const [, day, month, year] = matches;
          return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
      }
      throw new InvalidDateFormatError(format, locale);
  };

  const createDatePickerState = (config, selectedDateParam) => {
      var _a;
      const currentDayDateString = toDateString$1(new Date());
      const initialSelectedDate = typeof selectedDateParam === 'string'
          ? selectedDateParam
          : currentDayDateString;
      const isOpen = signals.signal(false);
      const isDisabled = signals.signal(config.disabled || false);
      const datePickerView = signals.signal(DatePickerView.MONTH_DAYS);
      const selectedDate = signals.signal(initialSelectedDate);
      const datePickerDate = signals.signal(initialSelectedDate || currentDayDateString);
      const isDark = signals.signal(((_a = config.style) === null || _a === void 0 ? void 0 : _a.dark) || false);
      const inputDisplayedValue = signals.signal(selectedDateParam || '');
      const lastValidDisplayedValue = signals.signal(selectedDateParam || '');
      signals.effect(() => {
          try {
              const newValue = toDateString(inputDisplayedValue.value, config.locale.value);
              if (newValue < config.min || newValue > config.max) {
                  inputDisplayedValue.value = lastValidDisplayedValue.value;
                  return;
              }
              selectedDate.value = newValue;
              datePickerDate.value = newValue;
              lastValidDisplayedValue.value = inputDisplayedValue.value;
          }
          catch (e) {
              // nothing to do
          }
      });
      let wasInitialized = false;
      const handleOnChange = (selectedDate) => {
          if (!wasInitialized)
              return (wasInitialized = true);
          config.listeners.onChange(selectedDate);
      };
      signals.effect(() => {
          var _a;
          if ((_a = config.listeners) === null || _a === void 0 ? void 0 : _a.onChange)
              handleOnChange(selectedDate.value);
      });
      return {
          inputWrapperElement: signals.signal(undefined),
          isOpen,
          isDisabled,
          datePickerView,
          selectedDate,
          datePickerDate,
          inputDisplayedValue,
          isDark,
          open: () => (isOpen.value = true),
          close: () => (isOpen.value = false),
          toggle: () => (isOpen.value = !isOpen.value),
          setView: (view) => (datePickerView.value = view),
      };
  };

  class DatePickerAppSingletonImpl {
      constructor(datePickerState, config, timeUnitsImpl, translate) {
          Object.defineProperty(this, "datePickerState", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: datePickerState
          });
          Object.defineProperty(this, "config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: config
          });
          Object.defineProperty(this, "timeUnitsImpl", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: timeUnitsImpl
          });
          Object.defineProperty(this, "translate", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: translate
          });
      }
  }

  class DatePickerAppSingletonBuilder {
      constructor() {
          Object.defineProperty(this, "datePickerState", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "config", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "timeUnitsImpl", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "translate", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
      }
      build() {
          return new DatePickerAppSingletonImpl(this.datePickerState, this.config, this.timeUnitsImpl, this.translate);
      }
      withDatePickerState(datePickerState) {
          this.datePickerState = datePickerState;
          return this;
      }
      withConfig(config) {
          this.config = config;
          return this;
      }
      withTimeUnitsImpl(timeUnitsImpl) {
          this.timeUnitsImpl = timeUnitsImpl;
          return this;
      }
      withTranslate(translate) {
          this.translate = translate;
          return this;
      }
  }

  var Placement;
  (function (Placement) {
      Placement["TOP_START"] = "top-start";
      Placement["TOP_END"] = "top-end";
      Placement["BOTTOM_START"] = "bottom-start";
      Placement["BOTTOM_END"] = "bottom-end";
  })(Placement || (Placement = {}));

  class ConfigImpl {
      constructor(locale = DEFAULT_LOCALE, firstDayOfWeek = DEFAULT_FIRST_DAY_OF_WEEK, min = toDateString$1(new Date(1970, 0, 1)), max = toDateString$1(new Date(new Date().getFullYear() + 50, 11, 31)), placement = Placement.BOTTOM_START, listeners = {}, style = {}, teleportTo, label, name, disabled) {
          Object.defineProperty(this, "min", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: min
          });
          Object.defineProperty(this, "max", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: max
          });
          Object.defineProperty(this, "placement", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: placement
          });
          Object.defineProperty(this, "listeners", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: listeners
          });
          Object.defineProperty(this, "style", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: style
          });
          Object.defineProperty(this, "teleportTo", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: teleportTo
          });
          Object.defineProperty(this, "label", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: label
          });
          Object.defineProperty(this, "name", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: name
          });
          Object.defineProperty(this, "disabled", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: disabled
          });
          Object.defineProperty(this, "locale", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "firstDayOfWeek", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          this.locale = signals.signal(locale);
          this.firstDayOfWeek = signals.signal(firstDayOfWeek);
      }
  }

  class ConfigBuilder {
      constructor() {
          Object.defineProperty(this, "locale", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "firstDayOfWeek", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "min", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "max", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "placement", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "listeners", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "style", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "teleportTo", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "label", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "name", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
          Object.defineProperty(this, "disabled", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: void 0
          });
      }
      build() {
          return new ConfigImpl(this.locale, this.firstDayOfWeek, this.min, this.max, this.placement, this.listeners, this.style, this.teleportTo, this.label, this.name, this.disabled);
      }
      withLocale(locale) {
          this.locale = locale;
          return this;
      }
      withFirstDayOfWeek(firstDayOfWeek) {
          this.firstDayOfWeek = firstDayOfWeek;
          return this;
      }
      withMin(min) {
          this.min = min;
          return this;
      }
      withMax(max) {
          this.max = max;
          return this;
      }
      withPlacement(placement) {
          this.placement = placement;
          return this;
      }
      withListeners(listeners) {
          this.listeners = listeners;
          return this;
      }
      withStyle(style) {
          this.style = style;
          return this;
      }
      withTeleportTo(teleportTo) {
          this.teleportTo = teleportTo;
          return this;
      }
      withLabel(label) {
          this.label = label;
          return this;
      }
      withName(name) {
          this.name = name;
          return this;
      }
      withDisabled(disabled) {
          this.disabled = disabled;
          return this;
      }
  }

  const datePickerDeDE = {
      Date: 'Datum',
      'MM/DD/YYYY': 'TT.MM.JJJJ',
      'Next month': 'NÃ¤chster Monat',
      'Previous month': 'Vorheriger Monat',
      'Choose Date': 'Datum auswÃ¤hlen',
  };

  const calendarDeDE = {
      Today: 'Heute',
      Month: 'Monat',
      Week: 'Woche',
      Day: 'Tag',
      'Select View': 'Ansicht auswÃ¤hlen',
      events: 'Ereignisse',
      event: 'Ereignis',
      'No events': 'Keine Ereignisse',
      'Next period': 'NÃ¤chster Zeitraum',
      'Previous period': 'Vorheriger Zeitraum',
      to: 'bis', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'GanztÃ¤gige und mehrtÃ¤gige Ereignisse',
      'Link to {{n}} more events on {{date}}': 'Link zu {{n}} weiteren Ereignissen am {{date}}',
      'Link to 1 more event on {{date}}': 'Link zu 1 weiteren Ereignis am {{date}}',
  };

  const deDE = {
      ...datePickerDeDE,
      ...calendarDeDE,
  };

  const datePickerEnUS = {
      Date: 'Date',
      'MM/DD/YYYY': 'MM/DD/YYYY',
      'Next month': 'Next month',
      'Previous month': 'Previous month',
      'Choose Date': 'Choose Date',
  };

  const calendarEnUS = {
      Today: 'Today',
      Month: 'Month',
      Week: 'Week',
      Day: 'Day',
      'Select View': 'Select View',
      events: 'events',
      event: 'event',
      'No events': 'No events',
      'Next period': 'Next period',
      'Previous period': 'Previous period',
      to: 'to', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Full day- and multiple day events',
      'Link to {{n}} more events on {{date}}': 'Link to {{n}} more events on {{date}}',
      'Link to 1 more event on {{date}}': 'Link to 1 more event on {{date}}',
  };

  const enUS = {
      ...datePickerEnUS,
      ...calendarEnUS,
  };

  const datePickerItIT = {
      Date: 'Data',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Mese successivo',
      'Previous month': 'Mese precedente',
      'Choose Date': 'Scegli la data',
  };

  const calendarItIT = {
      Today: 'Oggi',
      Month: 'Mese',
      Week: 'Settimana',
      Day: 'Giorno',
      'Select View': 'Seleziona la vista',
      events: 'eventi',
      event: 'evento',
      'No events': 'Nessun evento',
      'Next period': 'Periodo successivo',
      'Previous period': 'Periodo precedente',
      to: 'a', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Eventi della giornata e plurigiornalieri',
      'Link to {{n}} more events on {{date}}': 'Link a {{n}} eventi in piÃ¹ il {{date}}',
      'Link to 1 more event on {{date}}': 'Link a 1 evento in piÃ¹ il {{date}}',
  };

  const itIT = {
      ...datePickerItIT,
      ...calendarItIT,
  };

  const datePickerEnGB = {
      Date: 'Date',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Next month',
      'Previous month': 'Previous month',
      'Choose Date': 'Choose Date',
  };

  const calendarEnGB = {
      Today: 'Today',
      Month: 'Month',
      Week: 'Week',
      Day: 'Day',
      'Select View': 'Select View',
      events: 'events',
      event: 'event',
      'No events': 'No events',
      'Next period': 'Next period',
      'Previous period': 'Previous period',
      to: 'to', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Full day- and multiple day events',
      'Link to {{n}} more events on {{date}}': 'Link to {{n}} more events on {{date}}',
      'Link to 1 more event on {{date}}': 'Link to 1 more event on {{date}}',
  };

  const enGB = {
      ...datePickerEnGB,
      ...calendarEnGB,
  };

  const datePickerSvSE = {
      Date: 'Datum',
      'MM/DD/YYYY': 'Ã…Ã…Ã…Ã…-MM-DD',
      'Next month': 'NÃ¤sta mÃ¥nad',
      'Previous month': 'FÃ¶regÃ¥ende mÃ¥nad',
      'Choose Date': 'VÃ¤lj datum',
  };

  const calendarSvSE = {
      Today: 'Idag',
      Month: 'MÃ¥nad',
      Week: 'Vecka',
      Day: 'Dag',
      'Select View': 'VÃ¤lj vy',
      events: 'hÃ¤ndelser',
      event: 'hÃ¤ndelse',
      'No events': 'Inga hÃ¤ndelser',
      'Next period': 'NÃ¤sta period',
      'Previous period': 'FÃ¶regÃ¥ende period',
      to: 'till', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Heldags- och flerdagshÃ¤ndelser',
      'Link to {{n}} more events on {{date}}': 'LÃ¤nk till {{n}} fler hÃ¤ndelser den {{date}}',
      'Link to 1 more event on {{date}}': 'LÃ¤nk till 1 hÃ¤ndelse till den {{date}}',
  };

  const svSE = {
      ...datePickerSvSE,
      ...calendarSvSE,
  };

  const datePickerZhCN = {
      Date: 'æ—¥æœŸ',
      'MM/DD/YYYY': 'å¹´/æœˆ/æ—¥',
      'Next month': 'ä¸‹ä¸ªæœˆ',
      'Previous month': 'ä¸Šä¸ªæœˆ',
      'Choose Date': 'é€‰æ‹©æ—¥æœŸ',
  };

  const calendarZhCN = {
      Today: 'ä»Šå¤©',
      Month: 'æœˆ',
      Week: 'å‘¨',
      Day: 'æ—¥',
      'Select View': 'é€‰æ‹©è§†å›¾',
      events: 'åœºæ´»åŠ¨',
      event: 'æ´»åŠ¨',
      'No events': 'æ²¡æœ‰æ´»åŠ¨',
      'Next period': 'ä¸‹ä¸€æ®µæ—¶é—´',
      'Previous period': 'ä¸Šä¸€æ®µæ—¶é—´',
      to: 'è‡³', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'å…¨å¤©å’Œå¤šå¤©æ´»åŠ¨',
      'Link to {{n}} more events on {{date}}': 'é“¾æŽ¥åˆ°{{date}}ä¸Šçš„{{n}}ä¸ªæ›´å¤šæ´»åŠ¨',
      'Link to 1 more event on {{date}}': 'é“¾æŽ¥åˆ°{{date}}ä¸Šçš„1ä¸ªæ›´å¤šæ´»åŠ¨',
  };

  const zhCN = {
      ...datePickerZhCN,
      ...calendarZhCN,
  };

  const datePickerZhTW = {
      Date: 'æ—¥æœŸ',
      'MM/DD/YYYY': 'å¹´/æœˆ/æ—¥',
      'Next month': 'ä¸‹å€‹æœˆ',
      'Previous month': 'ä¸Šå€‹æœˆ',
      'Choose Date': 'é¸æ“‡æ—¥æœŸ',
  };

  const calendarZhTW = {
      Today: 'ä»Šå¤©',
      Month: 'æœˆ',
      Week: 'å‘¨',
      Day: 'æ—¥',
      'Select View': 'é¸æ“‡æª¢è¦–æ¨¡å¼',
      events: 'å ´æ´»å‹•',
      event: 'æ´»å‹•',
      'No events': 'æ²’æœ‰æ´»å‹•',
      'Next period': 'ä¸‹ä¸€æ®µæ™‚é–“',
      'Previous period': 'ä¸Šä¸€æ®µæ™‚é–“',
      to: 'åˆ°', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'å…¨å¤©å’Œå¤šå¤©æ´»å‹•',
      'Link to {{n}} more events on {{date}}': 'é€£æŽ¥åˆ°{{date}}ä¸Šçš„{{n}}å€‹æ›´å¤šæ´»å‹•',
      'Link to 1 more event on {{date}}': 'é€£æŽ¥åˆ°{{date}}ä¸Šçš„1å€‹æ›´å¤šæ´»å‹•',
  };

  const zhTW = {
      ...datePickerZhTW,
      ...calendarZhTW,
  };

  const datePickerJaJP = {
      Date: 'æ—¥ä»˜',
      'MM/DD/YYYY': 'å¹´/æœˆ/æ—¥',
      'Next month': 'æ¬¡ã®æœˆ',
      'Previous month': 'å‰ã®æœˆ',
      'Choose Date': 'æ—¥ä»˜ã‚’é¸æŠž',
  };

  const calendarJaJP = {
      Today: 'ä»Šæ—¥',
      Month: 'æœˆ',
      Week: 'é€±',
      Day: 'æ—¥',
      'Select View': 'ãƒ“ãƒ¥ãƒ¼ã‚’é¸æŠž',
      events: 'ã‚¤ãƒ™ãƒ³ãƒˆ',
      event: 'ã‚¤ãƒ™ãƒ³ãƒˆ',
      'No events': 'ã‚¤ãƒ™ãƒ³ãƒˆãªã—',
      'Next period': 'æ¬¡ã®æœŸé–“',
      'Previous period': 'å‰ã®æœŸé–“',
      to: 'ã‹ã‚‰', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'çµ‚æ—¥ãŠã‚ˆã³è¤‡æ•°æ—¥ã‚¤ãƒ™ãƒ³ãƒˆ',
      'Link to {{n}} more events on {{date}}': '{{date}} ã«{{n}}ä»¶ã®ã‚¤ãƒ™ãƒ³ãƒˆã¸ã®ãƒªãƒ³ã‚¯',
      'Link to 1 more event on {{date}}': '{{date}} ã«1ä»¶ã®ã‚¤ãƒ™ãƒ³ãƒˆã¸ã®ãƒªãƒ³ã‚¯',
  };

  const jaJP = {
      ...datePickerJaJP,
      ...calendarJaJP,
  };

  const datePickerRuRU = {
      Date: 'Ð”Ð°Ñ‚Ð°',
      'MM/DD/YYYY': 'ÐœÐœ/Ð”Ð”/Ð“Ð“Ð“Ð“',
      'Next month': 'Ð¡Ð»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¹ Ð¼ÐµÑÑÑ†',
      'Previous month': 'ÐŸÑ€Ð¾ÑˆÐ»Ñ‹Ð¹ Ð¼ÐµÑÑÑ†',
      'Choose Date': 'Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð´Ð°Ñ‚Ñƒ',
  };

  const calendarRuRU = {
      Today: 'Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ',
      Month: 'ÐœÐµÑÑÑ†',
      Week: 'ÐÐµÐ´ÐµÐ»Ñ',
      Day: 'Ð”ÐµÐ½ÑŒ',
      'Select View': 'Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð²Ð¸Ð´',
      events: 'ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ',
      event: 'ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ðµ',
      'No events': 'ÐÐµÑ‚ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹',
      'Next period': 'Ð¡Ð»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´',
      'Previous period': 'ÐŸÑ€Ð¾ÑˆÐ»Ñ‹Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´',
      to: 'Ð¿Ð¾', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ñ Ð½Ð° Ñ†ÐµÐ»Ñ‹Ð¹ Ð´ÐµÐ½ÑŒ Ð¸ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð´Ð½ÐµÐ¹ Ð¿Ð¾Ð´Ñ€ÑÐ´',
      'Link to {{n}} more events on {{date}}': 'Ð¡ÑÑ‹Ð»ÐºÐ° Ð½Ð° {{n}} Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹ Ð½Ð° {{date}}',
      'Link to 1 more event on {{date}}': 'Ð¡ÑÑ‹Ð»ÐºÐ° Ð½Ð° 1 Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ðµ Ð½Ð° {{date}}',
  };

  const ruRU = {
      ...datePickerRuRU,
      ...calendarRuRU,
  };

  const datePickerKoKR = {
      Date: 'ì¼ìž',
      'MM/DD/YYYY': 'ë…„/ì›”/ì¼',
      'Next month': 'ë‹¤ìŒ ë‹¬',
      'Previous month': 'ì´ì „ ë‹¬',
      'Choose Date': 'ë‚ ì§œ ì„ íƒ',
  };

  const calendarKoKR = {
      Today: 'ì˜¤ëŠ˜',
      Month: 'ì›”',
      Week: 'ì£¼',
      Day: 'ì¼',
      'Select View': 'ë³´ê¸° ì„ íƒ',
      events: 'ì¼ì •ë“¤',
      event: 'ì¼ì •',
      'No events': 'ì¼ì • ì—†ìŒ',
      'Next period': 'ë‹¤ìŒ',
      'Previous period': 'ì´ì „',
      to: 'ë¶€í„°', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'ì¢…ì¼ ë° ë³µìˆ˜ì¼ ì¼ì •',
      'Link to {{n}} more events on {{date}}': '{{date}}ì— {{n}}ê°œ ì´ìƒì˜ ì´ë²¤íŠ¸ë¡œ ì´ë™',
      'Link to 1 more event on {{date}}': '{{date}}ì— 1ê°œ ì´ìƒì˜ ì´ë²¤íŠ¸ë¡œ ì´ë™',
  };

  const koKR = {
      ...datePickerKoKR,
      ...calendarKoKR,
  };

  const datePickerFrFR = {
      Date: 'Date',
      'MM/DD/YYYY': 'JJ/MM/AAAA',
      'Next month': 'Mois suivant',
      'Previous month': 'Mois prÃ©cÃ©dent',
      'Choose Date': 'Choisir une date',
  };

  const calendarFrFR = {
      Today: "Aujourd'hui",
      Month: 'Mois',
      Week: 'Semaine',
      Day: 'Jour',
      'Select View': 'Choisir la vue',
      events: 'Ã©vÃ©nements',
      event: 'Ã©vÃ©nement',
      'No events': 'Aucun Ã©vÃ©nement',
      'Next period': 'PÃ©riode suivante',
      'Previous period': 'PÃ©riode prÃ©cÃ©dente',
      to: 'Ã ', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': "Ã‰vÃ©nements d'une ou plusieurs journÃ©es",
      'Link to {{n}} more events on {{date}}': 'Lien vers {{n}} autres Ã©vÃ©nements le {{date}}',
      'Link to 1 more event on {{date}}': 'Lien vers 1 autre Ã©vÃ©nement le {{date}}',
  };

  const frFR = {
      ...datePickerFrFR,
      ...calendarFrFR,
  };

  const datePickerDaDK = {
      Date: 'Dato',
      'MM/DD/YYYY': 'Ã…Ã…Ã…Ã…-MM-DD',
      'Next month': 'NÃ¦ste mÃ¥ned',
      'Previous month': 'ForegÃ¥ende mÃ¥ned',
      'Choose Date': 'VÃ¦lg dato',
  };

  const calendarDaDK = {
      Today: 'I dag',
      Month: 'MÃ¥ned',
      Week: 'Uge',
      Day: 'Dag',
      'Select View': 'VÃ¦lg visning',
      events: 'begivenheder',
      event: 'begivenhed',
      'No events': 'Ingen begivenheder',
      'Next period': 'NÃ¦ste periode',
      'Previous period': 'ForgÃ¥ende periode',
      to: 'til', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Heldagsbegivenheder og flerdagsbegivenheder',
      'Link to {{n}} more events on {{date}}': 'Link til {{n}} flere begivenheder den {{date}}',
      'Link to 1 more event on {{date}}': 'Link til 1 mere begivenhed den {{date}}',
  };

  const daDK = {
      ...datePickerDaDK,
      ...calendarDaDK,
  };

  const datePickerPlPL = {
      Date: 'Data',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'NastÄ™pny miesiÄ…c',
      'Previous month': 'Poprzedni miesiÄ…c',
      'Choose Date': 'Wybiewrz datÄ™',
  };

  const calendarPlPL = {
      Today: 'Dzisiaj',
      Month: 'MiesiÄ…c',
      Week: 'TydzieÅ„',
      Day: 'DzieÅ„',
      'Select View': 'Wybierz widok',
      events: 'wydarzenia',
      event: 'wydarzenie',
      'No events': 'Brak wydarzeÅ„',
      'Next period': 'NastÄ™pny okres',
      'Previous period': 'Poprzedni okres',
      to: 'do', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Wydarzenia caÅ‚odniowe i wielodniowe',
      'Link to {{n}} more events on {{date}}': 'Link do {{n}} kolejnych wydarzeÅ„ w dniu {{date}}',
      'Link to 1 more event on {{date}}': 'Link do 1 kolejnego wydarzenia w dniu {{date}}',
  };

  const plPL = {
      ...datePickerPlPL,
      ...calendarPlPL,
  };

  const datePickerEsES = {
      Date: 'Fecha',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Siguiente mes',
      'Previous month': 'Mes anterior',
      'Choose Date': 'Seleccione una fecha',
  };

  const calendarEsES = {
      Today: 'Hoy',
      Month: 'Mes',
      Week: 'Semana',
      Day: 'DÃ­a',
      'Select View': 'Seleccione una vista',
      events: 'eventos',
      event: 'evento',
      'No events': 'Sin eventos',
      'Next period': 'Siguiente perÃ­odo',
      'Previous period': 'PerÃ­odo anterior',
      to: 'a', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'DÃ­a completo y eventos de mÃºltiples dÃ­as',
      'Link to {{n}} more events on {{date}}': 'Enlace a {{n}} eventos mÃ¡s el {{date}}',
      'Link to 1 more event on {{date}}': 'Enlace a 1 evento mÃ¡s el {{date}}',
  };

  const esES = {
      ...datePickerEsES,
      ...calendarEsES,
  };

  const calendarNlNL = {
      Today: 'Vandaag',
      Month: 'Maand',
      Week: 'Week',
      Day: 'Dag',
      'Select View': 'Kies weergave',
      events: 'gebeurtenissen',
      event: 'gebeurtenis',
      'No events': 'Geen gebeurtenissen',
      'Next period': 'Volgende periode',
      'Previous period': 'Vorige periode',
      to: 'tot', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Evenementen van een hele dag en meerdere dagen',
      'Link to {{n}} more events on {{date}}': 'Link naar {{n}} meer evenementen op {{date}}',
      'Link to 1 more event on {{date}}': 'Link naar 1 meer evenement op {{date}}',
  };

  const datePickerNlNL = {
      Date: 'Datum',
      'MM/DD/YYYY': 'DD-MM-JJJJ',
      'Next month': 'Volgende maand',
      'Previous month': 'Vorige maand',
      'Choose Date': 'Kies datum',
  };

  const nlNL = {
      ...datePickerNlNL,
      ...calendarNlNL,
  };

  const datePickerPtBR = {
      Date: 'Data',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'MÃªs seguinte',
      'Previous month': 'MÃªs anterior',
      'Choose Date': 'Escolha uma data',
  };

  const calendarPtBR = {
      Today: 'Hoje',
      Month: 'MÃªs',
      Week: 'Semana',
      Day: 'Dia',
      'Select View': 'Selecione uma visualizaÃ§Ã£o',
      events: 'eventos',
      event: 'evento',
      'No events': 'Sem eventos',
      'Next period': 'PerÃ­odo seguinte',
      'Previous period': 'PerÃ­odo anterior',
      to: 'a', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Dia inteiro e eventos de vÃ¡rios dias',
      'Link to {{n}} more events on {{date}}': 'Link para mais {{n}} eventos em {{date}}',
      'Link to 1 more event on {{date}}': 'Link para mais 1 evento em {{date}}',
  };

  const ptBR = {
      ...datePickerPtBR,
      ...calendarPtBR,
  };

  const datePickerSkSK = {
      Date: 'DÃ¡tum',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'ÄŽalÅ¡Ã­ mesiac',
      'Previous month': 'PredchÃ¡dzajÃºci mesiac',
      'Choose Date': 'Vyberte dÃ¡tum',
  };

  const calendarSkSK = {
      Today: 'Dnes',
      Month: 'Mesiac',
      Week: 'TÃ½Å¾deÅˆ',
      Day: 'DeÅˆ',
      'Select View': 'Vyberte zobrazenie',
      events: 'udalosti',
      event: 'udalosÅ¥',
      'No events': 'Å½iadne udalosti',
      'Next period': 'ÄŽalÅ¡ie obdobie',
      'Previous period': 'PredchÃ¡dzajÃºce obdobie',
      to: 'do', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'CelodennÃ© a viacdÅˆovÃ© udalosti',
      'Link to {{n}} more events on {{date}}': 'Odkaz na {{n}} ÄalÅ¡Ã­ch udalostÃ­ dÅˆa {{date}}',
      'Link to 1 more event on {{date}}': 'Odkaz na 1 ÄalÅ¡iu udalosÅ¥ dÅˆa {{date}}',
  };

  const skSK = {
      ...datePickerSkSK,
      ...calendarSkSK,
  };

  const datePickerMkMK = {
      Date: 'Ð”Ð°Ñ‚ÑƒÐ¼',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Ð¡Ð»ÐµÐ´ÐµÐ½ Ð¼ÐµÑÐµÑ†',
      'Previous month': 'ÐŸÑ€ÐµÑ‚Ñ…Ð¾Ð´ÐµÐ½ Ð¼ÐµÑÐµÑ†',
      'Choose Date': 'Ð˜Ð·Ð±ÐµÑ€Ð¸ Ð”Ð°Ñ‚ÑƒÐ¼',
  };

  const calendarMkMK = {
      Today: 'Ð”ÐµÐ½ÐµÑ',
      Month: 'ÐœÐµÑÐµÑ†',
      Week: 'ÐÐµÐ´ÐµÐ»Ð°',
      Day: 'Ð”ÐµÐ½',
      'Select View': 'Ð˜Ð·Ð±ÐµÑ€Ð¸ ÐŸÑ€ÐµÐ³Ð»ÐµÐ´',
      events: 'Ð½Ð°ÑÑ‚Ð°Ð½Ð¸',
      event: 'Ð½Ð°ÑÑ‚Ð°Ð½',
      'No events': 'ÐÐµÐ¼Ð° Ð½Ð°ÑÑ‚Ð°Ð½Ð¸',
      'Next period': 'Ð¡Ð»ÐµÐ´ÐµÐ½ Ð¿ÐµÑ€Ð¸Ð¾Ð´',
      'Previous period': 'ÐŸÑ€ÐµÑ‚Ñ…Ð¾Ð´ÐµÐ½ Ð¿ÐµÑ€Ð¸Ð¾Ð´',
      to: 'Ð´Ð¾', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Ð¦ÐµÐ»Ð¾Ð´Ð½ÐµÐ²Ð½Ð¸ Ð¸ Ð¿Ð¾Ð²ÐµÑœÐµÐ´Ð½ÐµÐ²Ð½Ð¸ Ð½Ð°ÑÑ‚Ð°Ð½Ð¸',
      'Link to {{n}} more events on {{date}}': 'Ð›Ð¸Ð½Ðº Ð´Ð¾ {{n}} Ð¿Ð¾Ð²ÐµÑœÐµ Ð½Ð°ÑÑ‚Ð°Ð½Ð¸ Ð½Ð° {{date}}',
      'Link to 1 more event on {{date}}': 'Ð›Ð¸Ð½Ðº Ð´Ð¾ 1 Ð¿Ð¾Ð²ÐµÑœÐµ Ð½Ð°ÑÑ‚Ð°Ð½ Ð½Ð° {{date}}',
  };

  const mkMK = {
      ...datePickerMkMK,
      ...calendarMkMK,
  };

  const datePickerTrTR = {
      Date: 'Tarih',
      'MM/DD/YYYY': 'GG/AA/YYYY',
      'Next month': 'Sonraki ay',
      'Previous month': 'Ã–nceki ay',
      'Choose Date': 'Tarih SeÃ§',
  };

  const calendarTrTR = {
      Today: 'BugÃ¼n',
      Month: 'AylÄ±k',
      Week: 'HaftalÄ±k',
      Day: 'GÃ¼nlÃ¼k',
      'Select View': 'GÃ¶rÃ¼nÃ¼m SeÃ§',
      events: 'etkinlikler',
      event: 'etkinlik',
      'No events': 'Etkinlik yok',
      'Next period': 'Sonraki dÃ¶nem',
      'Previous period': 'Ã–nceki dÃ¶nem',
      to: 'dan', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'TÃ¼m gÃ¼n ve Ã§oklu gÃ¼n etkinlikleri',
      'Link to {{n}} more events on {{date}}': '{{date}} tarihinde {{n}} etkinliÄŸe baÄŸlantÄ±',
      'Link to 1 more event on {{date}}': '{{date}} tarihinde 1 etkinliÄŸe baÄŸlantÄ±',
  };

  const trTR = {
      ...datePickerTrTR,
      ...calendarTrTR,
  };

  const datePickerKyKG = {
      Date: 'Ð”Ð°Ñ‚Ð°ÑÑ‹',
      'MM/DD/YYYY': 'ÐÐ/ÐšÐš/Ð–Ð–Ð–Ð–',
      'Next month': 'ÐšÐ¸Ð¹Ð¸Ð½ÐºÐ¸ Ð°Ð¹',
      'Previous month': 'Ó¨Ñ‚ÐºÓ©Ð½ Ð°Ð¹',
      'Choose Date': 'ÐšÒ¯Ð½Ð´Ò¯ Ñ‚Ð°Ð½Ð´Ð°Ò£Ñ‹Ð·',
  };

  const calendarKyKG = {
      Today: 'Ð‘Ò¯Ð³Ò¯Ð½',
      Month: 'ÐÐ¹',
      Week: 'ÐÐ¿Ñ‚Ð°',
      Day: 'ÐšÒ¯Ð½',
      'Select View': 'ÐšÓ©Ñ€Ò¯Ð½Ò¯ÑˆÑ‚Ò¯ Ñ‚Ð°Ð½Ð´Ð°Ò£Ñ‹Ð·',
      events: 'ÐžÐºÑƒÑÐ»Ð°Ñ€',
      event: 'ÐžÐºÑƒÑ',
      'No events': 'ÐžÐºÑƒÑ Ð¶Ð¾Ðº',
      'Next period': 'ÐšÐ¸Ð¹Ð¸Ð½ÐºÐ¸ Ð¼ÐµÐ·Ð³Ð¸Ð»',
      'Previous period': 'Ó¨Ñ‚ÐºÓ©Ð½ Ð¼ÐµÐ·Ð³Ð¸Ð»',
      to: 'Ñ‡ÐµÐ¹Ð¸Ð½', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'ÐšÒ¯Ð½ Ð±Ð¾ÑŽ Ð¶Ð°Ð½Ð° Ð±Ð¸Ñ€ Ð½ÐµÑ‡Ðµ ÐºÒ¯Ð½ ÐºÐ°Ñ‚Ð°Ñ€Ñ‹ Ð¼ÐµÐ½ÐµÐ½ Ð±Ð¾Ð»Ð³Ð¾Ð½ Ð¾ÐºÑƒÑÐ»Ð°Ñ€',
      'Link to {{n}} more events on {{date}}': '{{date}} ÐºÒ¯Ð½Ò¯Ð½Ð´Ó© {{n}} Ð¾ÐºÑƒÑÐ³Ð° Ð±Ð°Ð¹Ð»Ð°Ð½Ñ‹Ñˆ',
      'Link to 1 more event on {{date}}': '{{date}} ÐºÒ¯Ð½Ò¯Ð½Ð´Ó© 1 Ð¾ÐºÑƒÑÐ³Ð° Ð±Ð°Ð¹Ð»Ð°Ð½Ñ‹Ñˆ',
  };

  const kyKG = {
      ...datePickerKyKG,
      ...calendarKyKG,
  };

  const datePickerIdID = {
      Date: 'Tanggal',
      'MM/DD/YYYY': 'DD.MM.YYYY',
      'Next month': 'Bulan depan',
      'Previous month': 'Bulan sebelumnya',
      'Choose Date': 'Pilih tanggal',
  };

  const calendarIdID = {
      Today: 'Hari Ini',
      Month: 'Bulan',
      Week: 'Minggu',
      Day: 'Hari',
      'Select View': 'Pilih tampilan',
      events: 'Acara',
      event: 'Acara',
      'No events': 'Tidak ada acara',
      'Next period': 'Periode selanjutnya',
      'Previous period': 'Periode sebelumnya',
      to: 'sampai', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Sepanjang hari dan acara beberapa hari ',
      'Link to {{n}} more events on {{date}}': 'Tautan ke {{n}} acara lainnya pada {{date}}',
      'Link to 1 more event on {{date}}': 'Tautan ke 1 acara lainnya pada {{date}}',
  };

  const idID = {
      ...datePickerIdID,
      ...calendarIdID,
  };

  const datePickerCsCZ = {
      Date: 'Datum',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'DalÅ¡Ã­ mÄ›sÃ­c',
      'Previous month': 'PÅ™edchozÃ­ mÄ›sÃ­c',
      'Choose Date': 'Vyberte datum',
  };

  const calendarCsCZ = {
      Today: 'Dnes',
      Month: 'MÄ›sÃ­c',
      Week: 'TÃ½den',
      Day: 'Den',
      'Select View': 'Vyberte zobrazenÃ­',
      events: 'udÃ¡losti',
      event: 'udÃ¡lost',
      'No events': 'Å½Ã¡dnÃ© udÃ¡losti',
      'Next period': 'PÅ™Ã­Å¡tÃ­ obdobÃ­',
      'Previous period': 'PÅ™edchozÃ­ obdobÃ­',
      to: 'do', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'CelodennÃ­ a vÃ­cedennÃ­ udÃ¡losti',
      'Link to {{n}} more events on {{date}}': 'Odkaz na {{n}} dalÅ¡Ã­ch udÃ¡lostÃ­ dne {{date}}',
      'Link to 1 more event on {{date}}': 'Odkaz na 1 dalÅ¡Ã­ udÃ¡lost dne {{date}}',
  };

  const csCZ = {
      ...datePickerCsCZ,
      ...calendarCsCZ,
  };

  const datePickerEtEE = {
      Date: 'KuupÃ¤ev',
      'MM/DD/YYYY': 'PP.KK.AAAA',
      'Next month': 'JÃ¤rgmine kuu',
      'Previous month': 'Eelmine kuu',
      'Choose Date': 'Vali kuupÃ¤ev',
  };

  const calendarEtEE = {
      Today: 'TÃ¤na',
      Month: 'Kuu',
      Week: 'NÃ¤dal',
      Day: 'PÃ¤ev',
      'Select View': 'Vali vaade',
      events: 'sÃ¼ndmused',
      event: 'sÃ¼ndmus',
      'No events': 'Pole sÃ¼ndmusi',
      'Next period': 'JÃ¤rgmine periood',
      'Previous period': 'Eelmine periood',
      to: 'kuni',
      'Full day- and multiple day events': 'TÃ¤ispÃ¤eva- ja mitmepÃ¤evasÃ¼ndmused',
      'Link to {{n}} more events on {{date}}': 'Link {{n}} rohkematele sÃ¼ndmustele kuupÃ¤eval {{date}}',
      'Link to 1 more event on {{date}}': 'Link Ã¼hele lisasÃ¼ndmusele kuupÃ¤eval {{date}}',
  };

  const etEE = {
      ...datePickerEtEE,
      ...calendarEtEE,
  };

  const datePickerUkUA = {
      Date: 'Ð”Ð°Ñ‚Ð°',
      'MM/DD/YYYY': 'ÐœÐœ/Ð”Ð”/Ð Ð Ð Ð ',
      'Next month': 'ÐÐ°ÑÑ‚ÑƒÐ¿Ð½Ð¸Ð¹ Ð¼Ñ–ÑÑÑ†ÑŒ',
      'Previous month': 'ÐœÐ¸Ð½ÑƒÐ»Ð¸Ð¹ Ð¼Ñ–ÑÑÑ†ÑŒ',
      'Choose Date': 'Ð’Ð¸Ð±ÐµÑ€Ñ–Ñ‚ÑŒ Ð´Ð°Ñ‚Ñƒ',
  };

  const calendarUkUA = {
      Today: 'Ð¡ÑŒÐ¾Ð³Ð¾Ð´Ð½Ñ–',
      Month: 'ÐœÑ–ÑÑÑ†ÑŒ',
      Week: 'Ð¢Ð¸Ð¶Ð´ÐµÐ½ÑŒ',
      Day: 'Ð”ÐµÐ½ÑŒ',
      'Select View': 'Ð’Ð¸Ð±ÐµÑ€Ñ–Ñ‚ÑŒ Ð²Ð¸Ð³Ð»ÑÐ´',
      events: 'Ð¿Ð¾Ð´Ñ–Ñ—',
      event: 'Ð¿Ð¾Ð´Ñ–Ñ',
      'No events': 'ÐÐµÐ¼Ð°Ñ” Ð¿Ð¾Ð´Ñ–Ð¹',
      'Next period': 'ÐÐ°ÑÑ‚ÑƒÐ¿Ð½Ð¸Ð¹ Ð¿ÐµÑ€Ñ–Ð¾Ð´',
      'Previous period': 'ÐœÐ¸Ð½ÑƒÐ»Ð¸Ð¹ Ð¿ÐµÑ€Ñ–Ð¾Ð´',
      to: 'Ð¿Ð¾', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'ÐŸÐ¾Ð´Ñ–Ñ— Ð½Ð° Ñ†Ñ–Ð»Ð¸Ð¹ Ð´ÐµÐ½ÑŒ Ñ– ÐºÑ–Ð»ÑŒÐºÐ° Ð´Ð½Ñ–Ð² Ð¿Ð¾ÑÐ¿Ñ–Ð»ÑŒ',
      'Link to {{n}} more events on {{date}}': 'ÐŸÐ¾ÑÐ¸Ð»Ð°Ð½Ð½Ñ Ð½Ð° {{n}} Ð´Ð¾Ð´Ð°Ñ‚ÐºÐ¾Ð²Ñ– Ð¿Ð¾Ð´Ñ–Ñ— Ð½Ð° {{date}}',
      'Link to 1 more event on {{date}}': 'ÐŸÐ¾ÑÐ¸Ð»Ð°Ð½Ð½Ñ Ð½Ð° 1 Ð´Ð¾Ð´Ð°Ñ‚ÐºÐ¾Ð²Ñƒ Ð¿Ð¾Ð´Ñ–ÑŽ Ð½Ð° {{date}}',
  };

  const ukUA = {
      ...datePickerUkUA,
      ...calendarUkUA,
  };

  const datePickerSrLatnRS = {
      Date: 'Datum',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'SledeÄ‡i mesec',
      'Previous month': 'Prethodni mesec',
      'Choose Date': 'Izaberite datum',
  };

  const calendarSrLatnRS = {
      Today: 'Danas',
      Month: 'Mesec',
      Week: 'Nedelja',
      Day: 'Dan',
      'Select View': 'Odaberite pregled',
      events: 'DogaÄ‘aji',
      event: 'DogaÄ‘aj',
      'No events': 'Nema dogaÄ‘aja',
      'Next period': 'Naredni period',
      'Previous period': 'Prethodni period',
      to: 'do', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Celodnevni i viÅ¡ednevni dogaÄ‘aji',
      'Link to {{n}} more events on {{date}}': 'Link do joÅ¡ {{n}} dogaÄ‘aja na {{date}}',
      'Link to 1 more event on {{date}}': 'Link do jednog dogaÄ‘aja na {{date}}',
  };

  const srLatnRS = {
      ...datePickerSrLatnRS,
      ...calendarSrLatnRS,
  };

  const datePickerCaES = {
      Date: 'Data',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'SegÃ¼ent mes',
      'Previous month': 'Mes anterior',
      'Choose Date': 'Selecciona una data',
  };

  const calendarCaES = {
      Today: 'Avui',
      Month: 'Mes',
      Week: 'Setmana',
      Day: 'Dia',
      'Select View': 'Selecciona una vista',
      events: 'Esdeveniments',
      event: 'Esdeveniment',
      'No events': 'Sense esdeveniments',
      'Next period': 'SegÃ¼ent perÃ­ode',
      'Previous period': 'PerÃ­ode anterior',
      to: 'a', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Esdeveniments de dia complet i de mÃºltiples dies',
      'Link to {{n}} more events on {{date}}': 'EnllaÃ§ a {{n}} esdeveniments mÃ©s el {{date}}',
      'Link to 1 more event on {{date}}': 'EnllaÃ§ a 1 esdeveniment mÃ©s el {{date}}',
  };

  const caES = {
      ...datePickerCaES,
      ...calendarCaES,
  };

  const datePickerSrRS = {
      Date: 'Ð”Ð°Ñ‚ÑƒÐ¼',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'Ð¡Ð»ÐµÐ´ÐµÑ›Ð¸ Ð¼ÐµÑÐµÑ†',
      'Previous month': 'ÐŸÑ€ÐµÑ‚Ñ…Ð¾Ð´Ð½Ð¸ Ð¼ÐµÑÐµÑ†',
      'Choose Date': 'Ð˜Ð·Ð°Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð”Ð°Ñ‚ÑƒÐ¼',
  };

  const calendarSrRS = {
      Today: 'Ð”Ð°Ð½Ð°Ñ',
      Month: 'ÐœÐµÑÐµÑ†',
      Week: 'ÐÐµÐ´ÐµÑ™Ð°',
      Day: 'Ð”Ð°Ð½',
      'Select View': 'Ð˜Ð·Ð°Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ñ€ÐµÐ³Ð»ÐµÐ´',
      events: 'Ð”Ð¾Ð³Ð°Ñ’Ð°Ñ˜Ð¸',
      event: 'Ð”Ð¾Ð³Ð°Ñ’Ð°Ñ˜',
      'No events': 'ÐÐµÐ¼Ð° Ð´Ð¾Ð³Ð°Ñ’Ð°Ñ˜Ð°',
      'Next period': 'Ð¡Ð»ÐµÐ´ÐµÑ›Ð¸ Ð¿ÐµÑ€Ð¸Ð¾Ð´',
      'Previous period': 'ÐŸÑ€ÐµÑ‚Ñ…Ð¾Ð´Ð½Ð¸ Ð¿ÐµÑ€Ð¸Ð¾Ð´',
      to: 'Ð´Ð°', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Ð¦ÐµÐ»Ð¾Ð´Ð½ÐµÐ²Ð½Ð¸ Ð¸ Ð²Ð¸ÑˆÐµÐ´Ð½ÐµÐ²Ð½Ð¸ Ð´Ð¾Ð³Ð°Ñ’Ð°Ñ˜Ð¸',
      'Link to {{n}} more events on {{date}}': 'Ð›Ð¸Ð½Ðº Ð´Ð¾ Ñ˜Ð¾Ñˆ {{n}} Ð´Ð¾Ð³Ð°Ñ’Ð°Ñ˜Ð° Ð½Ð° {{date}}',
      'Link to 1 more event on {{date}}': 'Ð›Ð¸Ð½Ðº Ð´Ð¾ Ñ˜Ð¾Ñˆ 1 Ð´Ð¾Ð³Ð°Ñ’Ð°Ñ˜Ð° {{date}}',
  };

  const srRS = {
      ...datePickerSrRS,
      ...calendarSrRS,
  };

  const datePickerLtLT = {
      Date: 'Data',
      'MM/DD/YYYY': 'MMMM-MM-DD',
      'Next month': 'Kitas mÄ—nuo',
      'Previous month': 'Ankstesnis mÄ—nuo',
      'Choose Date': 'Pasirinkite datÄ…',
  };

  const calendarLtLT = {
      Today: 'Å iandien',
      Month: 'MÄ—nuo',
      Week: 'SavaitÄ—',
      Day: 'Diena',
      'Select View': 'Pasirinkite vaizdÄ…',
      events: 'Ä¯vykiai',
      event: 'Ä¯vykis',
      'No events': 'Ä®vykiÅ³ nÄ—ra',
      'Next period': 'Kitas laikotarpis',
      'Previous period': 'Ankstesnis laikotarpis',
      to: 'iki', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Visos dienos ir keliÅ³ dienÅ³ Ä¯vykiai',
      'Link to {{n}} more events on {{date}}': 'Nuoroda Ä¯ dar {{n}} Ä¯vykius {{date}}',
      'Link to 1 more event on {{date}}': 'Nuoroda Ä¯ dar 1 vienÄ… Ä¯vykÄ¯ {{date}}',
  };

  const ltLT = {
      ...datePickerLtLT,
      ...calendarLtLT,
  };

  const datePickerHrHR = {
      Date: 'Datum',
      'MM/DD/YYYY': 'DD/MM/YYYY',
      'Next month': 'SljedeÄ‡i mjesec',
      'Previous month': 'Prethodni mjesec',
      'Choose Date': 'Izaberite datum',
  };

  const calendarHrHR = {
      Today: 'Danas',
      Month: 'Mjesec',
      Week: 'Nedjelja',
      Day: 'Dan',
      'Select View': 'Odaberite pregled',
      events: 'DogaÄ‘aji',
      event: 'DogaÄ‘aj',
      'No events': 'Nema dogaÄ‘aja',
      'Next period': 'SljedeÄ‡i period',
      'Previous period': 'Prethodni period',
      to: 'do', // as in 2/1/2020 to 2/2/2020
      'Full day- and multiple day events': 'Cjelodnevni i viÅ¡ednevni dogaÄ‘aji',
      'Link to {{n}} more events on {{date}}': 'Link do joÅ¡ {{n}} dogaÄ‘aja na {{date}}',
      'Link to 1 more event on {{date}}': 'Link do joÅ¡ jednog dogaÄ‘aja na {{date}}',
  };

  const hrHR = {
      ...datePickerHrHR,
      ...calendarHrHR,
  };

  class InvalidLocaleError extends Error {
      constructor(locale) {
          super(`Invalid locale: ${locale}`);
      }
  }

  const translate = (locale, languages) => (key, translationVariables) => {
      if (!/^[a-z]{2}-[A-Z]{2}$/.test(locale.value) &&
          'sr-Latn-RS' !== locale.value) {
          throw new InvalidLocaleError(locale.value);
      }
      const deHyphenatedLocale = locale.value.replaceAll('-', '');
      const language = languages.value[deHyphenatedLocale];
      if (!language)
          return key;
      let translation = language[key] || key;
      Object.keys(translationVariables || {}).forEach((variable) => {
          const value = String(translationVariables === null || translationVariables === void 0 ? void 0 : translationVariables[variable]);
          if (!value)
              return;
          translation = translation.replace(`{{${variable}}}`, value);
      });
      return translation;
  };

  /* eslint-disable max-lines */
  const translations = {
      deDE,
      enUS,
      itIT,
      enGB,
      svSE,
      zhCN,
      zhTW,
      jaJP,
      ruRU,
      koKR,
      frFR,
      daDK,
      mkMK,
      plPL,
      esES,
      nlNL,
      ptBR,
      skSK,
      trTR,
      kyKG,
      idID,
      csCZ,
      etEE,
      ukUA,
      caES,
      srLatnRS,
      srRS,
      ltLT,
      hrHR,
  };

  const createAppSingleton = (config = {}) => {
      const configInternal = new ConfigBuilder()
          .withFirstDayOfWeek(config.firstDayOfWeek)
          .withLocale(config.locale)
          .withMin(config.min)
          .withMax(config.max)
          .withPlacement(config.placement)
          .withListeners(config.listeners)
          .withStyle(config.style)
          .withTeleportTo(config.teleportTo)
          .withLabel(config.label)
          .withName(config.name)
          .withDisabled(config.disabled)
          .build();
      const timeUnitsImpl = new TimeUnitsBuilder()
          .withConfig(configInternal)
          .build();
      return new DatePickerAppSingletonBuilder()
          .withConfig(configInternal)
          .withDatePickerState(createDatePickerState(configInternal, config.selectedDate))
          .withTimeUnitsImpl(timeUnitsImpl)
          .withTranslate(translate(configInternal.locale, signals.signal(translations)))
          .build();
  };
  const createDatePicker = (config) => {
      const $app = createAppSingleton(config);
      return new DatePickerApp($app);
  };

  function DatePicker({ initialValue, label, onChange, isDarkMode, name, width, disabled, min, max, locale, }) {
      const [datePickerId] = hooks.useState(randomStringId$2);
      const [datePicker] = hooks.useState(() => createDatePicker({
          selectedDate: initialValue || toDateString$2(new Date()),
          teleportTo: document.body,
          label,
          name,
          min,
          max,
          locale,
          listeners: {
              onChange,
              onEscapeKeyDown: ($app) => {
                  window.__sx_escapeKeyDownBlocker__ = true;
                  $app.datePickerState.close();
                  setTimeout(() => {
                      window.__sx_escapeKeyDownBlocker__ = false;
                  }, 10);
              },
          },
          style: {
              dark: isDarkMode,
              fullWidth: width === '100%',
          },
      }));
      hooks.useEffect(() => {
          const datePickerEl = document.getElementById(datePickerId);
          if (datePickerEl) {
              datePicker.render(datePickerEl);
          }
      }, []);
      hooks.useEffect(() => {
          datePicker.disabled = disabled || false;
      }, [disabled]);
      hooks.useEffect(() => {
          if (!initialValue)
              return;
          datePicker.value = initialValue;
      }, [initialValue]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { className: 'sx__date-picker-outer-wrapper', id: datePickerId }) }));
  }

  function Textarea({ initialValue, onChange, label, name, errorMessage, }) {
      const [inputValue, setInputValue] = hooks.useState(initialValue);
      const handleInput = (newValue) => {
          setInputValue(newValue);
          onChange(newValue);
      };
      const BASE_WRAPPER_CLASS = 'sx__textarea-wrapper';
      const [wrapperClasses, setWrapperClasses] = hooks.useState([BASE_WRAPPER_CLASS]);
      hooks.useEffect(() => {
          if (inputValue.length > 0) {
              setWrapperClasses([BASE_WRAPPER_CLASS, 'sx__has-value']);
          }
          else {
              setWrapperClasses([BASE_WRAPPER_CLASS]);
          }
      }, [inputValue]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { className: wrapperClasses.join(' '), children: [jsxRuntime.jsx("textarea", { className: 'sx__textarea-input', value: inputValue, onInput: (e) => handleInput(e.currentTarget.value), id: "last_name", type: "text", name: name }), jsxRuntime.jsx("label", { className: 'sx__textarea-label', htmlFor: name, children: label })] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
  }

  function AppCheckbox({ initialValue, label, onChange, colorPrimary }) {
      const checkboxId = randomStringId$2();
      const [isChecked, setIsChecked] = hooks.useState(initialValue || false);
      const [isReady, setIsReady] = hooks.useState(!colorPrimary);
      const handleOnInput = (event) => {
          setIsChecked(event.target.checked);
          onChange(event.target.checked);
      };
      hooks.useEffect(() => {
          const el = document.getElementById(checkboxId);
          if (!el)
              return;
          if (colorPrimary) {
              el.style.setProperty('--sx-color-primary', colorPrimary);
              setIsReady(true);
          }
      }, []);
      return (jsxRuntime.jsx(preact.Fragment, { children: jsxRuntime.jsx("label", { id: checkboxId, className: "sx__app-checkbox", children: isReady && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("input", { type: "checkbox", checked: isChecked, onInput: handleOnInput }), jsxRuntime.jsx("span", { children: label })] })) }) }));
  }

  const AppContext = preact.createContext({});

  /**
   * Can be used for generating a random id for an entity
   * Should, however, never be used in potentially resource intense loops,
   * since the performance cost of this compared to new Date().getTime() is ca x4 in v8
   * */
  const randomStringId = () => 's' + Math.random().toString(36).substring(2, 11);

  function AppInput() {
      var _a;
      const $app = compat.useContext(AppContext);
      const inputId = randomStringId();
      const wrapperId = randomStringId();
      const [wrapperClasses, setWrapperClasses] = hooks.useState([]);
      compat.useEffect(() => {
          const newClasses = ['sx__time-input-wrapper'];
          if ($app.timePickerState.isOpen.value)
              newClasses.push('sx__time-input--active');
          setWrapperClasses(newClasses);
      }, [$app.timePickerState.isOpen.value]);
      const openPopup = () => {
          if (!$app.config.teleportTo.value) {
              $app.timePickerState.isOpen.value = true;
              return;
          }
          const inputWrapperElement = document.getElementById(wrapperId);
          $app.timePickerState.inputWrapperElement.value =
              inputWrapperElement instanceof HTMLDivElement
                  ? inputWrapperElement
                  : undefined;
          $app.timePickerState.isOpen.value = true;
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { id: wrapperId, className: wrapperClasses.join(' '), children: [jsxRuntime.jsx("label", { htmlFor: inputId, className: "sx__time-input-label", children: (_a = $app.config.label.value) !== null && _a !== void 0 ? _a : 'Time' }), jsxRuntime.jsx("input", { value: $app.timePickerState.currentTimeDisplayedValue.value, readOnly: true, id: inputId, name: $app.config.name.value ? $app.config.name.value : 'time', className: "sx__time-picker-input", type: "text", onFocus: openPopup })] }) }));
  }

  /**
   * Push a task to the end of the current call stack
   * */
  const nextTick = (cb) => {
      setTimeout(() => {
          cb();
      });
  };

  function TimeInput({ initialValue, onChange, inputRef, nextTabIndexRef, validRange, }) {
      const [inputValue, setInputValue] = hooks.useState(initialValue);
      const [tabBlocker, setTabBlocker] = hooks.useState(false);
      const handleInput = (e) => {
          if (!(e.target instanceof HTMLInputElement))
              return;
          setInputValue(e.target.value);
      };
      compat.useEffect(() => {
          var _a;
          onChange(inputValue);
          if (tabBlocker)
              return;
          if (inputValue.length === 2 &&
              nextTabIndexRef &&
              'current' in nextTabIndexRef) {
              (_a = nextTabIndexRef.current) === null || _a === void 0 ? void 0 : _a.focus();
              if (nextTabIndexRef.current instanceof HTMLInputElement) {
                  nextTabIndexRef.current.select();
              }
          }
      }, [inputValue]);
      const handleOnBlur = () => {
          const [min, max] = validRange;
          const value = +inputValue;
          if (value < min || value > max || isNaN(value)) {
              setInputValue(min < 10 ? `0${min}` : String(min));
              return;
          }
          if (inputValue.length === 1) {
              setInputValue(`0${inputValue}`);
          }
      };
      const incrementOrDecrementOnKeyDown = (e) => {
          if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
              e.preventDefault();
              const [min, max] = validRange;
              const value = +inputValue;
              const newValue = e.key === 'ArrowUp' ? value + 1 : value - 1;
              if (newValue < min || newValue > max)
                  return;
              setInputValue(newValue < 10 ? `0${newValue}` : String(newValue));
              setTabBlocker(true);
              nextTick(() => setTabBlocker(false));
          }
      };
      return (jsxRuntime.jsx("input", { ref: inputRef, maxLength: 2, className: "sx__time-input", type: "text", onKeyDown: incrementOrDecrementOnKeyDown, value: inputValue, onInput: handleInput, onBlur: handleOnBlur }));
  }

  const isScrollable$1 = (el) => {
      if (el) {
          const hasScrollableContent = el.scrollHeight > el.clientHeight;
          const overflowYStyle = window.getComputedStyle(el).overflowY;
          const isOverflowHidden = overflowYStyle.indexOf('hidden') !== -1;
          return hasScrollableContent && !isOverflowHidden;
      }
      return true;
  };
  const getScrollableParents$1 = (el, acc = []) => {
      if (!el ||
          el === document.body ||
          el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          acc.push(window);
          return acc;
      }
      if (isScrollable$1(el)) {
          acc.push(el);
      }
      return getScrollableParents$1((el.assignedSlot
          ? el.assignedSlot.parentNode
          : el.parentNode), acc);
  };

  const convert12HourTo24HourTimeString = (hoursValue, minutesValue, $app) => {
      const hoursInt = Number(hoursValue);
      const isAM = $app.timePickerState.isAM.value;
      if (isAM && hoursInt === 12) {
          $app.timePickerState.currentTime.value = `00:${minutesValue}`;
      }
      else if (!isAM && hoursInt < 12) {
          $app.timePickerState.currentTime.value = `${hoursInt + 12}:${minutesValue}`;
      }
      else {
          $app.timePickerState.currentTime.value = `${hoursValue}:${minutesValue}`;
      }
  };

  function AppPopup() {
      const $app = compat.useContext(AppContext);
      const POPUP_CLASS_NAME = 'sx__time-picker-popup';
      const INPUT_WRAPPER_CLASS_NAME = 'sx__time-input-wrapper';
      const hoursRef = compat.useRef(null);
      const minutesRef = compat.useRef(null);
      const OKButtonRef = compat.useRef(null);
      const [classList, setClassList] = hooks.useState([
          POPUP_CLASS_NAME,
          $app.config.placement,
      ]);
      hooks.useEffect(() => {
          setClassList([
              POPUP_CLASS_NAME,
              $app.config.placement,
              $app.config.dark.value ? 'is-dark' : '',
          ]);
      }, [$app.config.dark.value, $app.config.placement.value]);
      const getInitialStart12Hour = (hours) => {
          const hoursInt = Number(hours);
          if (hoursInt === 0)
              return '12';
          if (hoursInt > 12)
              return String(hoursInt - 12);
          return hours;
      };
      const [initialStart, initialEnd] = $app.timePickerState.currentTime.value.split(':');
      const [hoursValue, setHoursValue] = hooks.useState($app.config.is12Hour.value
          ? getInitialStart12Hour(initialStart)
          : initialStart);
      const [minutesValue, setMinutesValue] = hooks.useState(initialEnd);
      const clickOutsideListener = (event) => {
          const target = event.target;
          if (![POPUP_CLASS_NAME, INPUT_WRAPPER_CLASS_NAME].some((className) => target.closest(`.${className}`))) {
              $app.timePickerState.isOpen.value = false;
          }
      };
      const escapeKeyListener = (e) => {
          if (e.key === 'Escape') {
              if (typeof $app.config.onEscapeKeyDown.value === 'function') {
                  $app.config.onEscapeKeyDown.value($app);
              }
              else {
                  $app.timePickerState.isOpen.value = false;
              }
          }
      };
      hooks.useEffect(() => {
          var _a, _b;
          (_a = hoursRef.current) === null || _a === void 0 ? void 0 : _a.focus();
          (_b = hoursRef.current) === null || _b === void 0 ? void 0 : _b.select();
          document.addEventListener('click', clickOutsideListener);
          document.addEventListener('keydown', escapeKeyListener);
          return () => {
              document.removeEventListener('click', clickOutsideListener);
              document.removeEventListener('keydown', escapeKeyListener);
          };
      }, []);
      const handleAccept = () => {
          if ($app.config.is12Hour.value) {
              convert12HourTo24HourTimeString(hoursValue, minutesValue, $app);
          }
          else {
              $app.timePickerState.currentTime.value = `${hoursValue}:${minutesValue}`;
          }
          $app.timePickerState.isOpen.value = false;
      };
      const remSize = Number(getComputedStyle(document.documentElement).fontSize.split('px')[0]);
      const popupHeight = 362;
      const popupWidth = 332;
      const getFixedPositionStyles = () => {
          var _a, _b, _c;
          const inputRect = (_a = $app.timePickerState.inputWrapperElement.value) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
          if (!inputRect)
              return undefined;
          return {
              top: ((_b = $app.config.placement.value) === null || _b === void 0 ? void 0 : _b.includes('bottom'))
                  ? inputRect.height + inputRect.y + 1 // 1px border
                  : inputRect.y - remSize - popupHeight, // subtract remsize to leave room for label text
              left: ((_c = $app.config.placement.value) === null || _c === void 0 ? void 0 : _c.includes('start'))
                  ? inputRect.x
                  : inputRect.x + inputRect.width - popupWidth,
              width: popupWidth,
              position: 'fixed',
          };
      };
      const [fixedPositionStyle, setFixedPositionStyle] = hooks.useState(getFixedPositionStyles());
      hooks.useEffect(() => {
          const inputWrapperEl = $app.timePickerState.inputWrapperElement.value;
          if (!inputWrapperEl)
              return;
          const scrollableParents = getScrollableParents$1(inputWrapperEl);
          scrollableParents.forEach((parent) => parent.addEventListener('scroll', () => setFixedPositionStyle(getFixedPositionStyles())));
          return () => {
              scrollableParents.forEach((parent) => parent.removeEventListener('scroll', () => setFixedPositionStyle(getFixedPositionStyles())));
          };
      }, []);
      return (jsxRuntime.jsxs("div", { className: classList.join(' '), style: $app.config.teleportTo.value ? fixedPositionStyle : undefined, children: [jsxRuntime.jsx("div", { className: "sx__time-picker-popup-label", children: "Select time" }), jsxRuntime.jsxs("div", { className: "sx__time-picker-time-inputs", children: [jsxRuntime.jsx(TimeInput, { initialValue: hoursValue, onChange: (newHours) => setHoursValue(newHours), inputRef: hoursRef, nextTabIndexRef: minutesRef, validRange: $app.config.is12Hour.value ? [1, 12] : [0, 23] }), jsxRuntime.jsx("span", { className: "sx__time-picker-colon", children: ":" }), jsxRuntime.jsx(TimeInput, { initialValue: minutesValue, onChange: (newMinutes) => setMinutesValue(newMinutes), inputRef: minutesRef, validRange: [0, 59], nextTabIndexRef: OKButtonRef }), $app.config.is12Hour.value && (jsxRuntime.jsxs("div", { className: "sx__time-picker-12-hour-switches", children: [jsxRuntime.jsx("button", { type: "button", className: `sx__time-picker-12-hour-switch${$app.timePickerState.isAM.value ? ' is-selected' : ''}`, onClick: () => ($app.timePickerState.isAM.value = true), children: "AM" }), jsxRuntime.jsx("button", { type: "button", className: `sx__time-picker-12-hour-switch${!$app.timePickerState.isAM.value ? ' is-selected' : ''}`, onClick: () => ($app.timePickerState.isAM.value = false), children: "PM" })] }))] }), jsxRuntime.jsxs("div", { class: "sx__time-picker-actions", children: [jsxRuntime.jsx("button", { type: "button", class: "sx__time-picker-action sx__ripple sx__button-cancel", onClick: () => ($app.timePickerState.isOpen.value = false), children: "Cancel" }), jsxRuntime.jsx("button", { ref: OKButtonRef, type: "button", class: "sx__time-picker-action sx__ripple sx__button-accept", onClick: handleAccept, children: "OK" })] })] }));
  }

  function TimePickerWrapper({ $app }) {
      const baseClassList = [
          'sx__time-picker-wrapper',
          $app.config.is12Hour.value ? 'is-12-hour' : '',
      ];
      const [classList, setClassList] = hooks.useState(baseClassList);
      hooks.useEffect(() => {
          setClassList([...baseClassList, $app.config.dark.value ? 'is-dark' : '']);
      }, [$app.config.dark.value]);
      let AppPopupJSX = jsxRuntime.jsx(AppPopup, {});
      if ($app.config.teleportTo.value) {
          AppPopupJSX = compat.createPortal(AppPopupJSX, $app.config.teleportTo.value);
      }
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { className: classList.join(' '), children: jsxRuntime.jsxs(AppContext.Provider, { value: $app, children: [jsxRuntime.jsx(AppInput, {}), $app.timePickerState.isOpen.value && AppPopupJSX] }) }) }));
  }

  class TimePickerApp {
      constructor($app) {
          Object.defineProperty(this, "$app", {
              enumerable: true,
              configurable: true,
              writable: true,
              value: $app
          });
      }
      render(el) {
          preact.render(preact.createElement(TimePickerWrapper, {
              $app: this.$app,
          }), el);
      }
      get value() {
          return this.$app.timePickerState.currentTime.value;
      }
      set value(value) {
          this.$app.timePickerState.currentTime.value = value;
      }
  }

  const getTimePickerState = (config, is12HourClock) => {
      var _a;
      const currentTime = signals.signal((_a = config.initialValue) !== null && _a !== void 0 ? _a : '00:00');
      let wasInitialized = false;
      const handleCurrentTimeChanged = (config, currentTime) => {
          if (!wasInitialized)
              return (wasInitialized = true);
          if (config.onChange) {
              config.onChange(currentTime);
          }
      };
      signals.effect(() => {
          handleCurrentTimeChanged(config, currentTime.value);
      });
      const initialIsAM = parseInt(currentTime.value.split(':')[0]) < 12;
      const isAM = signals.signal(initialIsAM);
      return {
          isOpen: signals.signal(false),
          currentTime,
          currentTimeDisplayedValue: signals.computed(() => {
              const [hours, minutes] = currentTime.value.split(':');
              const parsedHours = parseInt(hours);
              let hoursInt = parsedHours;
              const minutesInt = parseInt(minutes);
              if (is12HourClock) {
                  hoursInt = hoursInt === 0 ? 12 : hoursInt;
                  const hours12 = hoursInt > 12 ? hoursInt - 12 : hoursInt;
                  return `${hours12}:${minutesInt.toString().padStart(2, '0')} ${parsedHours >= 12 ? 'PM' : 'AM'}`;
              }
              return `${hoursInt.toString().padStart(2, '0')}:${minutesInt.toString().padStart(2, '0')}`;
          }),
          inputWrapperElement: signals.signal(undefined),
          isAM,
      };
  };
  const createTimePickerAppContext = (config = {}) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      return ({
          config: {
              onEscapeKeyDown: signals.signal((_a = config.onEscapeKeyDown) !== null && _a !== void 0 ? _a : undefined),
              dark: signals.signal((_b = config.dark) !== null && _b !== void 0 ? _b : false),
              placement: signals.signal((_c = config.placement) !== null && _c !== void 0 ? _c : 'bottom-start'),
              teleportTo: signals.signal((_d = config.teleportTo) !== null && _d !== void 0 ? _d : null),
              label: signals.signal((_e = config.label) !== null && _e !== void 0 ? _e : null),
              is12Hour: signals.signal((_f = config.is12Hour) !== null && _f !== void 0 ? _f : false),
              name: signals.signal((_g = config.name) !== null && _g !== void 0 ? _g : ''),
          },
          timePickerState: getTimePickerState(config, (_h = config.is12Hour) !== null && _h !== void 0 ? _h : false),
      });
  };
  const createTimePicker = (config = {}) => {
      return new TimePickerApp(createTimePickerAppContext(config));
  };

  function TimePicker({ initialValue, label, name, onChange, placement, isDarkMode, is12Hour, }) {
      const [timePickerId] = hooks.useState(randomStringId$2);
      const [timePicker] = hooks.useState(createTimePicker({
          initialValue: initialValue || '00:00',
          teleportTo: document.body,
          label,
          name,
          onChange,
          placement: placement || 'bottom-start',
          dark: isDarkMode,
          is12Hour: is12Hour || false,
          onEscapeKeyDown: ($app) => {
              window.__sx_escapeKeyDownBlocker__ = true;
              $app.timePickerState.isOpen.value = false;
              setTimeout(() => {
                  window.__sx_escapeKeyDownBlocker__ = false;
              }, 10);
          },
      }));
      hooks.useEffect(() => {
          const timePickerElement = document.getElementById(timePickerId);
          if (timePickerElement) {
              timePicker.render(timePickerElement);
          }
      }, []);
      hooks.useEffect(() => {
          if (!initialValue)
              return;
          timePicker.value = initialValue;
      }, [initialValue]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx("div", { id: timePickerId }) }));
  }

  const isScrollable = (el) => {
      if (el) {
          const hasScrollableContent = el.scrollHeight > el.clientHeight;
          const overflowYStyle = window.getComputedStyle(el).overflowY;
          const isOverflowHidden = overflowYStyle.indexOf('hidden') !== -1;
          return hasScrollableContent && !isOverflowHidden;
      }
      return true;
  };
  const getScrollableParents = (el, acc = []) => {
      if (!el ||
          el === document.body ||
          el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          acc.push(window);
          return acc;
      }
      if (isScrollable(el)) {
          acc.push(el);
      }
      return getScrollableParents((el.assignedSlot
          ? el.assignedSlot.parentNode
          : el.parentNode), acc);
  };

  function AppCombobox({ items, label, initialSelectedItems, onChange, name, isDarkMode, errorMessage, }) {
      const wrapperId = randomStringId$2();
      const listId = randomStringId$2();
      const inputId = randomStringId$2();
      const [wrapperRect, setWrapperRect] = hooks.useState({
          x: 0,
          y: 0,
          height: 0,
          width: 0,
      });
      const [isOpen, setIsOpen] = hooks.useState(false);
      const [listClasses, setListClasses] = hooks.useState('sx__app-combobox__list');
      const [filteredItems, setFilteredItems] = hooks.useState(items);
      const [selectedItems, setSelectedItems] = hooks.useState(initialSelectedItems || []);
      hooks.useEffect(() => {
          const baseClasses = ['sx__app-combobox__list'];
          if (isDarkMode)
              baseClasses.push('is-dark');
          if (isOpen)
              baseClasses.push('is-open');
          setListClasses(baseClasses.join(' '));
      }, [isOpen, isDarkMode]);
      const setPopupPosition = (wrapperEl) => {
          setWrapperRect({
              x: wrapperEl.getBoundingClientRect().left,
              y: wrapperEl.getBoundingClientRect().top,
              height: wrapperEl.getBoundingClientRect().height,
              width: wrapperEl.getBoundingClientRect().width,
          });
      };
      const toggleOpen = () => {
          if (isOpen) {
              setIsOpen(false);
              return;
          }
          const wrapperEl = document.getElementById(wrapperId);
          const inputEl = document.getElementById(inputId);
          if (!wrapperEl || !inputEl)
              return;
          inputEl.focus();
          setIsOpen(true);
          setPopupPosition(wrapperEl);
          const scrollableParents = getScrollableParents(wrapperEl);
          const boundSetPosition = setPopupPosition.bind(null, wrapperEl);
          const listClickOutsideListener = (event) => {
              const target = event.target;
              if (target instanceof HTMLElement && !target.closest(`#${listId}`)) {
                  setIsOpen(false);
                  document.removeEventListener('click', listClickOutsideListener);
                  scrollableParents.forEach((parentEl) => parentEl.removeEventListener('scroll', boundSetPosition));
              }
          };
          setTimeout(() => {
              scrollableParents.forEach((parentEl) => parentEl.addEventListener('scroll', boundSetPosition));
              document.addEventListener('click', listClickOutsideListener);
          }, 10);
      };
      const handleBackSpace = () => {
          const lastItem = selectedItems[selectedItems.length - 1];
          setSelectedItems(selectedItems.filter((item) => item !== lastItem));
      };
      const handleInput = (e) => {
          const target = e.target;
          if (!(target instanceof HTMLInputElement))
              return;
          const value = target.value;
          if (value.length === 0) {
              setFilteredItems(items.filter((item) => !selectedItems.includes(item)));
              return;
          }
          const filtered = items.filter((item) => {
              return (item.toLowerCase().includes(value.toLowerCase()) &&
                  !selectedItems.includes(item));
          });
          setFilteredItems(filtered);
      };
      const clickOnItem = (item) => {
          setSelectedItems([...selectedItems, item]);
          const inputEl = document.getElementById(inputId);
          if (!(inputEl instanceof HTMLInputElement))
              return;
          inputEl.value = '';
      };
      hooks.useEffect(() => {
          const filtered = items.filter((item) => !selectedItems.includes(item));
          setFilteredItems(filtered);
          onChange(selectedItems);
      }, [selectedItems]);
      // @ts-ignore
      const handleKeyDown = (e) => {
          if (e.key === 'Backspace' && e.target instanceof HTMLInputElement) {
              if (e.target.value.length === 0) {
                  handleBackSpace();
              }
          }
      };
      const removeSelected = (item) => {
          setSelectedItems(selectedItems.filter((i) => i !== item));
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox-wrapper", id: wrapperId, onClick: toggleOpen, children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox__input-wrapper", children: [selectedItems.map((item, index) => (jsxRuntime.jsxs("div", { class: "sx__app-combobox__chip", children: [item, jsxRuntime.jsx("span", { className: "sx__app-combobox__chip-remove", onClick: () => removeSelected(item), style: { width: '16px', height: '16px' }, children: jsxRuntime.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { "stroke-width": "0" }), jsxRuntime.jsx("g", { "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { children: [' ', jsxRuntime.jsx("path", { d: "M19 5L4.99998 19M5.00001 5L19 19", stroke: "#fff", "stroke-width": "2.4", "stroke-linecap": "round", "stroke-linejoin": "round" }), ' '] })] }) })] }, index))), jsxRuntime.jsx("input", { id: inputId, onInput: handleInput, onKeyDown: handleKeyDown, className: "sx__app-combobox-input", type: "text", placeholder: "Search...", name: name }), jsxRuntime.jsx("label", { className: 'sx__app-combobox-label', htmlFor: name, children: label })] }), compat.createPortal(jsxRuntime.jsx("div", { id: listId, class: listClasses, style: {
                                  top: wrapperRect.y + wrapperRect.height + 1,
                                  left: wrapperRect.x,
                                  width: wrapperRect.width,
                              }, children: jsxRuntime.jsx("ul", { children: filteredItems.map((item, index) => (jsxRuntime.jsx("li", { onClick: () => clickOnItem(item), children: item }, index))) }) }), document.body)] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
  }

  const WarningSign = ({ color = '#a88d00' }) => {
      return (jsxRuntime.jsxs("svg", { fill: color, width: 24, height: 24, viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", strokeWidth: "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntime.jsx("g", { id: "SVGRepo_iconCarrier", children: jsxRuntime.jsx("path", { "fill-rule": "evenodd", d: "M23,7.44365081 L23,16.5563492 L16.5563492,23 L7.44365081,23 L1,16.5563492 L1,7.44365081 L7.44365081,1 L16.5563492,1 L23,7.44365081 Z M15.7279221,3 L8.27207794,3 L3,8.27207794 L3,15.7279221 L8.27207794,21 L15.7279221,21 L21,15.7279221 L21,8.27207794 L15.7279221,3 Z M12.0003283,17.9983464 C11.4478622,17.9983464 11,17.5506311 11,16.9983464 C11,16.4460616 11.4478622,15.9983464 12.0003283,15.9983464 C12.5527943,15.9983464 13.0006565,16.4460616 13.0006565,16.9983464 C13.0006565,17.5506311 12.5527943,17.9983464 12.0003283,17.9983464 Z M11.0029544,5.99834639 L13.0036109,5.99834639 L13.0036109,13.9983464 L11.0029544,13.9983464 L11.0029544,5.99834639 Z" }) })] }));
  };

  function AppComboboxSingleValue({ items, label, initialSelectedItem, onChange, name, isDarkMode, errorMessage, }) {
      const wrapperId = randomStringId$2();
      const listId = randomStringId$2();
      const inputId = randomStringId$2();
      const [wrapperRect, setWrapperRect] = hooks.useState({
          x: 0,
          y: 0,
          height: 0,
          width: 0,
      });
      const [isOpen, setIsOpen] = hooks.useState(false);
      const [listClasses, setListClasses] = hooks.useState('sx__app-combobox__list');
      const [filteredItems, setFilteredItems] = hooks.useState(items);
      const [selectedItem, setSelectedItem] = hooks.useState(initialSelectedItem === null || initialSelectedItem === void 0 ? void 0 : initialSelectedItem.value);
      const setPopupPosition = (wrapperEl) => {
          setWrapperRect({
              x: wrapperEl.getBoundingClientRect().left,
              y: wrapperEl.getBoundingClientRect().top,
              height: wrapperEl.getBoundingClientRect().height,
              width: wrapperEl.getBoundingClientRect().width,
          });
      };
      hooks.useEffect(() => {
          const baseClasses = ['sx__app-combobox__list'];
          if (isDarkMode)
              baseClasses.push('is-dark');
          if (isOpen)
              baseClasses.push('is-open');
          setListClasses(baseClasses.join(' '));
      }, [isOpen, isDarkMode]);
      const toggleOpen = () => {
          if (isOpen) {
              setIsOpen(false);
              return;
          }
          const wrapperEl = document.getElementById(wrapperId);
          const inputEl = document.getElementById(inputId);
          if (!wrapperEl || !inputEl)
              return;
          inputEl.focus();
          setIsOpen(true);
          setPopupPosition(wrapperEl);
          const scrollableParents = getScrollableParents(wrapperEl);
          const boundSetPosition = setPopupPosition.bind(null, wrapperEl);
          const listClickOutsideListener = (event) => {
              const target = event.target;
              if (target instanceof HTMLElement && !target.closest(`#${listId}`)) {
                  setIsOpen(false);
                  document.removeEventListener('click', listClickOutsideListener);
                  scrollableParents.forEach((parentEl) => parentEl.removeEventListener('scroll', boundSetPosition));
              }
          };
          setTimeout(() => {
              document.addEventListener('click', listClickOutsideListener);
              scrollableParents.forEach((parentEl) => parentEl.addEventListener('scroll', boundSetPosition));
          });
      };
      // @ts-ignore
      const handleInput = (e) => {
          const target = e.target;
          if (!(target instanceof HTMLInputElement))
              return;
          const value = target.value;
          if (value.length === 0) {
              setFilteredItems(items);
              return;
          }
          const filtered = items.filter((item) => {
              return { ...item }.label.toLowerCase().includes(value.toLowerCase());
          });
          setFilteredItems(filtered);
      };
      const clickOnItem = (item) => {
          var _a;
          setSelectedItem(item);
          const inputEl = document.getElementById(inputId);
          if (!(inputEl instanceof HTMLInputElement))
              return;
          inputEl.value = ((_a = items.find((i) => i.value === item)) === null || _a === void 0 ? void 0 : _a.label) || '';
      };
      const inputRef = hooks.useRef(null);
      hooks.useEffect(() => {
          var _a;
          setFilteredItems(items);
          onChange(selectedItem);
          if (!inputRef.current)
              return;
          inputRef.current.value =
              ((_a = items.find((i) => i.value === selectedItem)) === null || _a === void 0 ? void 0 : _a.label) || '';
      }, [selectedItem]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox-wrapper", id: wrapperId, onClick: toggleOpen, children: [jsxRuntime.jsxs("div", { class: "sx__app-combobox__input-wrapper", children: [jsxRuntime.jsx("input", { ref: inputRef, id: inputId, onInput: handleInput, className: "sx__app-combobox-input", type: "text", placeholder: "Search...", name: name }), jsxRuntime.jsx("label", { className: 'sx__app-combobox-label', htmlFor: name, children: label })] }), compat.createPortal(jsxRuntime.jsx("div", { id: listId, class: listClasses, style: {
                                  top: wrapperRect.y + wrapperRect.height + 1,
                                  left: wrapperRect.x,
                                  width: wrapperRect.width,
                              }, children: jsxRuntime.jsx("ul", { children: filteredItems.map((item, index) => (jsxRuntime.jsx("li", { onClick: () => clickOnItem(item.value), children: item.label }, index))) }) }), document.body)] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
  }

  const ADDED_EVENT_CLASS_NAME = 'sx-is-added-event';

  const InfoIcon = ({ color = '#0077cc' }) => {
      return (jsxRuntime.jsxs("svg", { width: 28, height: 28, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), jsxRuntime.jsx("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), jsxRuntime.jsxs("g", { id: "SVGRepo_iconCarrier", children: [jsxRuntime.jsx("path", { d: "M12 16.75C11.8019 16.7474 11.6126 16.6676 11.4725 16.5275C11.3324 16.3874 11.2526 16.1981 11.25 16V11C11.25 10.8011 11.329 10.6103 11.4697 10.4697C11.6103 10.329 11.8011 10.25 12 10.25C12.1989 10.25 12.3897 10.329 12.5303 10.4697C12.671 10.6103 12.75 10.8011 12.75 11V16C12.7474 16.1981 12.6676 16.3874 12.5275 16.5275C12.3874 16.6676 12.1981 16.7474 12 16.75Z", fill: color }), jsxRuntime.jsx("path", { d: "M12 9.25C11.8019 9.24741 11.6126 9.16756 11.4725 9.02747C11.3324 8.88737 11.2526 8.69811 11.25 8.5V8C11.25 7.80109 11.329 7.61032 11.4697 7.46967C11.6103 7.32902 11.8011 7.25 12 7.25C12.1989 7.25 12.3897 7.32902 12.5303 7.46967C12.671 7.61032 12.75 7.80109 12.75 8V8.5C12.7474 8.69811 12.6676 8.88737 12.5275 9.02747C12.3874 9.16756 12.1981 9.24741 12 9.25Z", fill: color }), jsxRuntime.jsx("path", { d: "M12 21C10.22 21 8.47991 20.4722 6.99987 19.4832C5.51983 18.4943 4.36628 17.0887 3.68509 15.4442C3.0039 13.7996 2.82567 11.99 3.17294 10.2442C3.5202 8.49836 4.37737 6.89472 5.63604 5.63604C6.89472 4.37737 8.49836 3.5202 10.2442 3.17294C11.99 2.82567 13.7996 3.0039 15.4442 3.68509C17.0887 4.36628 18.4943 5.51983 19.4832 6.99987C20.4722 8.47991 21 10.22 21 12C21 14.387 20.0518 16.6761 18.364 18.364C16.6761 20.0518 14.387 21 12 21ZM12 4.5C10.5166 4.5 9.0666 4.93987 7.83323 5.76398C6.59986 6.58809 5.63856 7.75943 5.07091 9.12988C4.50325 10.5003 4.35473 12.0083 4.64411 13.4632C4.9335 14.918 5.64781 16.2544 6.6967 17.3033C7.7456 18.3522 9.08197 19.0665 10.5368 19.3559C11.9917 19.6453 13.4997 19.4968 14.8701 18.9291C16.2406 18.3614 17.4119 17.4001 18.236 16.1668C19.0601 14.9334 19.5 13.4834 19.5 12C19.5 10.0109 18.7098 8.10323 17.3033 6.6967C15.8968 5.29018 13.9891 4.5 12 4.5Z", fill: color })] })] }));
  };

  function AppSelect({ items, label, initialSelectedItem, onChange, name, isDarkMode, errorMessage, }) {
      const wrapperId = randomStringId$2();
      const listId = randomStringId$2();
      const inputId = randomStringId$2();
      const [wrapperRect, setWrapperRect] = hooks.useState({
          x: 0,
          y: 0,
          height: 0,
          width: 0,
      });
      const [isOpen, setIsOpen] = hooks.useState(false);
      const [listClasses, setListClasses] = hooks.useState('sx__app-select__list');
      const [selectedItem, setSelectedItem] = hooks.useState((initialSelectedItem === null || initialSelectedItem === void 0 ? void 0 : initialSelectedItem.value) || '');
      const setPopupPosition = (wrapperEl) => {
          setWrapperRect({
              x: wrapperEl.getBoundingClientRect().left,
              y: wrapperEl.getBoundingClientRect().top,
              height: wrapperEl.getBoundingClientRect().height,
              width: wrapperEl.getBoundingClientRect().width,
          });
      };
      hooks.useEffect(() => {
          const baseClasses = ['sx__app-select__list'];
          if (isDarkMode)
              baseClasses.push('is-dark');
          if (isOpen)
              baseClasses.push('is-open');
          setListClasses(baseClasses.join(' '));
      }, [isOpen, isDarkMode]);
      const toggleOpen = () => {
          if (isOpen) {
              setIsOpen(false);
              return;
          }
          const wrapperEl = document.getElementById(wrapperId);
          const inputEl = document.getElementById(inputId);
          if (!wrapperEl || !inputEl)
              return;
          inputEl.focus();
          setIsOpen(true);
          setPopupPosition(wrapperEl);
          const scrollableParents = getScrollableParents(wrapperEl);
          const boundSetPosition = setPopupPosition.bind(null, wrapperEl);
          const listClickOutsideListener = (event) => {
              const target = event.target;
              if (target instanceof HTMLElement && !target.closest(`#${listId}`)) {
                  setIsOpen(false);
                  document.removeEventListener('click', listClickOutsideListener);
                  scrollableParents.forEach((parentEl) => parentEl.removeEventListener('scroll', boundSetPosition));
              }
          };
          setTimeout(() => {
              document.addEventListener('click', listClickOutsideListener);
              scrollableParents.forEach((parentEl) => parentEl.addEventListener('scroll', boundSetPosition));
          }, 10);
      };
      const clickOnItem = (item) => {
          var _a;
          setSelectedItem(item);
          const inputEl = document.getElementById(inputId);
          if (!(inputEl instanceof HTMLInputElement))
              return;
          inputEl.value = ((_a = items.find((i) => i.value === item)) === null || _a === void 0 ? void 0 : _a.label) || '';
          setIsOpen(false);
      };
      const inputRef = hooks.useRef(null);
      hooks.useEffect(() => {
          var _a;
          onChange(selectedItem);
          if (!inputRef.current)
              return;
          inputRef.current.value =
              ((_a = items.find((i) => i.value === selectedItem)) === null || _a === void 0 ? void 0 : _a.label) || '';
      }, [selectedItem]);
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { class: "sx__form-field", children: [jsxRuntime.jsxs("div", { class: "sx__app-select-wrapper", id: wrapperId, onClick: toggleOpen, children: [jsxRuntime.jsxs("div", { class: "sx__app-select__input-wrapper", children: [jsxRuntime.jsx("input", { ref: inputRef, id: inputId, className: "sx__app-select-input", type: "text", readOnly: true, name: name }), jsxRuntime.jsx("label", { className: 'sx__app-select-label', htmlFor: name, children: label })] }), compat.createPortal(jsxRuntime.jsx("div", { id: listId, class: listClasses, style: {
                                  top: wrapperRect.y + wrapperRect.height + 1,
                                  left: wrapperRect.x,
                                  width: wrapperRect.width,
                              }, children: jsxRuntime.jsx("ul", { children: items.map((item, index) => (jsxRuntime.jsx("li", { onClick: () => clickOnItem(item.value), children: item.label }, index))) }) }), document.body)] }), errorMessage && jsxRuntime.jsx("p", { className: "sx__error-message", children: errorMessage })] }) }));
  }

  const toDateTimeString = (date) => {
      return `${toDateString$2(date)} ${toTimeString$1(date)}`;
  };
  /**
   * Converts a string of format 20240229T235959 to YYYY-MM-DD
   * */
  const dateStringFromICalendarDateTime = (dateTime) => {
      const year = dateTime.slice(0, 4);
      const month = dateTime.slice(4, 6);
      const day = dateTime.slice(6, 8);
      return `${year}-${month}-${day}`;
  };
  /**
   * Converts a string of format 2024-01-01 to 20240101T235959
   * We need to add 23:59:59 to make the date inclusive when selecting an UNTIL date
   * */
  const toICalendarDateTimeWithEndOfDay = (dateTime) => {
      return `${dateTime.replace(/-/g, '')}T235959`;
  };

  const getFrequencies = () => {
      return [
          { label: 'Once', value: '' },
          { label: 'Daily', value: 'DAILY' },
          { label: 'Weekly', value: 'WEEKLY' },
          { label: 'Monthly', value: 'MONTHLY' },
          { label: 'Yearly', value: 'YEARLY' },
      ];
  };
  const getInitialFrequency = (modalPlugin) => {
      var _a;
      const validFrequencies = getFrequencies().map((f) => f.value);
      const rruleParts = modalPlugin.formValues.value.rrule
          ? modalPlugin.formValues.value.rrule.split(';')
          : [];
      const freqPart = rruleParts.find((part) => part.includes('FREQ'));
      const freq = freqPart ? freqPart.split('=')[1] : '';
      if (freq && !validFrequencies.includes(freq)) {
          throw new Error(`Unsupported frequency: ${freq}`);
      }
      return {
          label: ((_a = getFrequencies().find((f) => f.value === freq)) === null || _a === void 0 ? void 0 : _a.label) || '',
          value: freq,
      };
  };
  const getInitialRruleUntil = (modalPlugin) => {
      if (modalPlugin.formValues.value.rrule) {
          const allRruleParts = modalPlugin.formValues.value.rrule.split(';');
          const untilPart = allRruleParts.find((part) => part.includes('UNTIL'));
          return untilPart
              ? dateStringFromICalendarDateTime(untilPart.split('=')[1])
              : '';
      }
      if (modalPlugin.formValues.value.end) {
          return toDateString$2(toJSDate$1(modalPlugin.formValues.value.end));
      }
      return;
  };

  function EventForm({ $app, removeEditAddedEvent }) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31;
      const titleFieldId = randomStringId$2();
      const [wasInitialized, setWasInitialized] = hooks.useState(false);
      const modalPlugin = $app.config.plugins
          .eventModal;
      const dateTimeSeparator = ' ';
      const [isFullDayEvent, setIsFullDayEvent] = hooks.useState(dateStringRegex.test(modalPlugin.formValues.value.start));
      const [startDate, setStartDate] = hooks.useState(modalPlugin.formValues.value.start
          ? toDateString$2(toJSDate$1(modalPlugin.formValues.value.start))
          : '');
      const [startTime, setStartTime] = hooks.useState(modalPlugin.formValues.value.start
          ? toTimeString$1(toJSDate$1(modalPlugin.formValues.value.start))
          : '');
      const [endDate, setEndDate] = hooks.useState(modalPlugin.formValues.value.end
          ? toDateString$2(toJSDate$1(modalPlugin.formValues.value.end))
          : '');
      const [endTime, setEndTime] = hooks.useState(modalPlugin.formValues.value.end
          ? toTimeString$1(toJSDate$1(modalPlugin.formValues.value.end))
          : '');
      const [rruleFreq, setRruleFreq] = hooks.useState(() => getInitialFrequency(modalPlugin).value);
      const [rruleUntil, setRruleUntil] = hooks.useState(() => getInitialRruleUntil(modalPlugin));
      hooks.useEffect(() => {
          modalPlugin.formValues.value.start = isFullDayEvent
              ? startDate
              : startDate + dateTimeSeparator + startTime;
          if (startDate > endDate) {
              setEndDate(startDate);
          }
          if (startTime > endTime && startDate === endDate) {
              setEndTime(startTime);
          }
          if (wasInitialized && modalPlugin.config.onStartUpdate) {
              modalPlugin.config.onStartUpdate(modalPlugin.formValues.value.start);
          }
          setWasInitialized(true);
      }, [startDate, startTime, isFullDayEvent]);
      hooks.useEffect(() => {
          modalPlugin.formValues.value.end = isFullDayEvent
              ? endDate
              : endDate + dateTimeSeparator + endTime;
          if (endDate < startDate) {
              setStartDate(endDate);
          }
          if (endTime < startTime && startDate === endDate) {
              setStartTime(endTime);
          }
          if (rruleUntil && rruleUntil < endDate) {
              setRruleUntil(endDate);
          }
          if (wasInitialized && modalPlugin.config.onEndUpdate) {
              modalPlugin.config.onEndUpdate(modalPlugin.formValues.value.end);
          }
          setWasInitialized(true);
      }, [endDate, endTime, isFullDayEvent]);
      hooks.useEffect(() => {
          Object.values(modalPlugin.formValidationErrors).forEach((error) => {
              error.value = undefined;
          });
      }, []);
      const [shouldValidate, setShouldValidate] = hooks.useState(false);
      const SAVE_BUTTON_BASE_CLASS = 'sx__app-button-filled';
      const [saveButtonClasses, setSaveButtonClasses] = hooks.useState([
          SAVE_BUTTON_BASE_CLASS,
      ]);
      const validate = () => {
          Object.entries({
              ...modalPlugin.config.fields,
              ...modalPlugin.config.customFields,
          }).forEach(([fieldName, field]) => {
              // unwrap custom fields since they are signals
              if ('value' in field)
                  field = field.value;
              if (!('validator' in field) || !field.validator)
                  return;
              const validationResult = field.validator(modalPlugin.formValues.value[fieldName]);
              if (!validationResult.isValid && fieldName) {
                  modalPlugin.formValidationErrors[fieldName].value =
                      validationResult.message;
              }
              else {
                  modalPlugin.formValidationErrors[fieldName].value = undefined;
              }
          });
      };
      const validateIfShouldValidate = () => {
          if (shouldValidate)
              validate();
      };
      const isFormValid = () => {
          return Object.values(modalPlugin.formValidationErrors).every((error) => !error.value);
      };
      const updateExistingEvent = () => {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          const eventId = ((_a = modalPlugin.calendarEvent.value) === null || _a === void 0 ? void 0 : _a.id) || '';
          const eventToUpdate = modalPlugin.eventsService.get(eventId);
          if (!eventToUpdate)
              throw new Error('Did not find event with ID ' + ((_b = modalPlugin.calendarEvent.value) === null || _b === void 0 ? void 0 : _b.id));
          const updatedEvent = {
              ...eventToUpdate,
              ...modalPlugin.formValues.value,
              end: modalPlugin.formValues.value.end || modalPlugin.formValues.value.start,
              id: eventToUpdate.id,
          };
          // for edit_added mode
          if ((_d = (_c = updatedEvent._options) === null || _c === void 0 ? void 0 : _c.additionalClasses) === null || _d === void 0 ? void 0 : _d.includes(ADDED_EVENT_CLASS_NAME)) {
              updatedEvent._options.additionalClasses =
                  updatedEvent._options.additionalClasses.filter((className) => className !== ADDED_EVENT_CLASS_NAME);
          }
          modalPlugin.eventsService.update(updatedEvent);
          modalPlugin.close();
          if (modalPlugin.modalState.value === 'edit_added') {
              (_f = (_e = modalPlugin.config).onAddEvent) === null || _f === void 0 ? void 0 : _f.call(_e, updatedEvent);
          }
          else {
              (_h = (_g = $app.config.callbacks) === null || _g === void 0 ? void 0 : _g.onEventUpdate) === null || _h === void 0 ? void 0 : _h.call(_g, updatedEvent);
          }
      };
      const createNewEvent = () => {
          var _a;
          if (!modalPlugin.config.onAddEvent)
              return;
          const newEvent = {
              id: ((_a = modalPlugin.calendarEvent.value) === null || _a === void 0 ? void 0 : _a.id) || '',
              title: modalPlugin.formValues.value.title,
              description: modalPlugin.formValues.value.description,
              start: modalPlugin.formValues.value.start,
              end: modalPlugin.formValues.value.end,
              people: modalPlugin.formValues.value.people,
              calendarId: modalPlugin.formValues.value.calendarId,
              rrule: modalPlugin.formValues.value.rrule,
              resourceId: modalPlugin.formValues.value.resourceId,
          };
          modalPlugin.eventsService.add(newEvent);
          modalPlugin.close();
          modalPlugin.config.onAddEvent(newEvent);
      };
      const setRrule = () => {
          if (!rruleFreq || !rruleUntil) {
              modalPlugin.formValues.value.rrule = undefined;
              return;
          }
          const rruleParts = [
              'FREQ=' + rruleFreq,
              'UNTIL=' + toICalendarDateTimeWithEndOfDay(rruleUntil),
          ];
          modalPlugin.formValues.value.rrule = rruleParts.join(';');
      };
      const saveEvent = () => {
          setRrule();
          setShouldValidate(true);
          validate();
          if (!isFormValid()) {
              setSaveButtonClasses([SAVE_BUTTON_BASE_CLASS, 'has-shake-animation']);
              setTimeout(() => {
                  setSaveButtonClasses([SAVE_BUTTON_BASE_CLASS]);
              }, 500);
              return;
          }
          if (['edit', 'edit_added'].includes(modalPlugin.modalState.value))
              updateExistingEvent();
          else
              createNewEvent();
      };
      const cancel = () => {
          if (modalPlugin.modalState.value === 'edit')
              return (modalPlugin.modalState.value = 'view');
          if (modalPlugin.modalState.value === 'edit_added')
              removeEditAddedEvent();
          modalPlugin.close();
      };
      const getCalendars = () => {
          return Object.entries($app.config.calendars.value).map(([key, value]) => {
              return { label: value.label || '', value: key };
          });
      };
      const getSelectedCalendarOrUndefined = () => {
          const selectedCalendar = $app.config.calendars.value[modalPlugin.formValues.value.calendarId];
          if (!selectedCalendar)
              return undefined;
          return selectedCalendar
              ? {
                  label: selectedCalendar.label || '',
                  value: modalPlugin.formValues.value.calendarId,
              }
              : undefined;
      };
      const configuredFields = modalPlugin.config.fields;
      const hasConfiguredFields = !!configuredFields;
      const hasConfiguredAllDateTimeFields = hasConfiguredFields &&
          configuredFields.startDate &&
          configuredFields.startTime &&
          configuredFields.endDate &&
          configuredFields.endTime;
      const isAddMode = modalPlugin.modalState.value === 'add';
      const isEditAddedMode = modalPlugin.modalState.value === 'edit_added';
      const showDescription = !hasConfiguredFields || configuredFields.description;
      const showDateTimeFields = isAddMode ||
          isEditAddedMode ||
          !hasConfiguredFields ||
          hasConfiguredAllDateTimeFields;
      const showCalendarField = !hasConfiguredFields ||
          (configuredFields.calendarId &&
              Object.entries(((_a = $app.config) === null || _a === void 0 ? void 0 : _a.calendars) || {}).length > 1);
      const showResourceField = !hasConfiguredFields || configuredFields.resourceId;
      const showRruleFields = !hasConfiguredFields ||
          (configuredFields.rruleFrequency && configuredFields.rruleUntil);
      hooks.useEffect(() => {
          var _a;
          const titleField = document.getElementById(titleFieldId);
          if (titleField) {
              (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.empty();
              setTimeout(() => {
                  titleField.focus();
              }, 10);
          }
      }, []);
      const [isInHiddenCalendar, setIsInHiddenCalendar] = hooks.useState(false);
      const checkIsInHiddenCalendar = () => {
          if (!$app.calendarEvents.filterPredicate.value)
              return;
          const isInHiddenCalendar = [modalPlugin.formValues.value].filter($app.calendarEvents.filterPredicate.value).length === 0;
          setIsInHiddenCalendar(isInHiddenCalendar);
      };
      hooks.useEffect(() => {
          checkIsInHiddenCalendar();
      }, []);
      const resources = 'resourceViewConfig' in $app
          ? $app.resourceViewConfig.resources.value
          : [];
      const getResourceItems = () => {
          return resources.map((resource) => {
              return { label: resource.label || '', value: resource.id };
          });
      };
      const getSelectedResourceOrUndefined = () => {
          const selectedResource = resources.find((resource) => resource.id === modalPlugin.formValues.value.resourceId);
          if (!selectedResource)
              return undefined;
          return {
              label: selectedResource.label || '',
              value: selectedResource.id,
          };
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { className: "sx__event-form", children: [modalPlugin.isEditingRecurringEvent.value && (jsxRuntime.jsxs("div", { className: "sx__event-form-alert sx__event-form-recurrence-warning", children: [jsxRuntime.jsx(WarningSign, {}), "You are editing the first in a series of recurring events."] })), isInHiddenCalendar && (jsxRuntime.jsxs("div", { className: "sx__event-form-alert sx__event-form-info-box", children: [jsxRuntime.jsx(InfoIcon, {}), "This event is in a hidden calendar."] })), jsxRuntime.jsx(TextField, { id: titleFieldId, initialValue: modalPlugin.formValues.value.title || '', onChange: (value) => {
                          var _a, _b, _c;
                          (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.title) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                          modalPlugin.formValues.value.title = value;
                          validateIfShouldValidate();
                      }, label: ((_c = (_b = modalPlugin.config.fields) === null || _b === void 0 ? void 0 : _b.title) === null || _c === void 0 ? void 0 : _c.label) || 'Title', fieldName: ((_e = (_d = modalPlugin.config.fields) === null || _d === void 0 ? void 0 : _d.title) === null || _e === void 0 ? void 0 : _e.name) || 'title', errorMessage: (_f = modalPlugin.formValidationErrors.title) === null || _f === void 0 ? void 0 : _f.value }, modalPlugin.formValues.value), showDateTimeFields && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("div", { className: "sx__event-time-input", children: [jsxRuntime.jsxs("div", { class: "sx__date-time-picker sx__date-time-start", children: [jsxRuntime.jsx(DatePicker, { label: ((_h = (_g = modalPlugin.config.fields) === null || _g === void 0 ? void 0 : _g.startDate) === null || _h === void 0 ? void 0 : _h.label) || 'Start date', name: ((_k = (_j = modalPlugin.config.fields) === null || _j === void 0 ? void 0 : _j.startDate) === null || _k === void 0 ? void 0 : _k.name) || 'start-date', onChange: (newStartDate) => {
                                                  var _a, _b, _c;
                                                  (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.startDate) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newStartDate);
                                                  setStartDate(newStartDate);
                                              }, min: (_l = modalPlugin.config.datePicker) === null || _l === void 0 ? void 0 : _l.min, max: (_m = modalPlugin.config.datePicker) === null || _m === void 0 ? void 0 : _m.max, initialValue: startDate, isDarkMode: $app.calendarState.isDark.value, locale: $app.config.locale.value }), !isFullDayEvent && (jsxRuntime.jsx(TimePicker, { onChange: (newStartTime) => {
                                                  var _a, _b, _c;
                                                  (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.startTime) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newStartTime);
                                                  setStartTime(newStartTime);
                                              }, label: ((_p = (_o = modalPlugin.config.fields) === null || _o === void 0 ? void 0 : _o.startTime) === null || _p === void 0 ? void 0 : _p.label) || '', name: ((_r = (_q = modalPlugin.config.fields) === null || _q === void 0 ? void 0 : _q.startTime) === null || _r === void 0 ? void 0 : _r.name) || 'start-time', initialValue: startTime, placement: $app.calendarState.isCalendarSmall.value
                                                  ? 'bottom-end'
                                                  : 'bottom-start', isDarkMode: $app.calendarState.isDark.value, is12Hour: modalPlugin.config.has12HourTimeFormat || false }))] }), jsxRuntime.jsx("span", { className: 'sx__date-time-until', children: "until" }), jsxRuntime.jsxs("div", { class: "sx__date-time-picker sx__date-time-end", children: [jsxRuntime.jsx(DatePicker, { label: ((_t = (_s = modalPlugin.config.fields) === null || _s === void 0 ? void 0 : _s.endDate) === null || _t === void 0 ? void 0 : _t.label) || 'End date', name: ((_v = (_u = modalPlugin.config.fields) === null || _u === void 0 ? void 0 : _u.endDate) === null || _v === void 0 ? void 0 : _v.name) || 'end-date', onChange: (newEndDate) => {
                                                  var _a, _b, _c;
                                                  (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.endDate) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newEndDate);
                                                  setEndDate(newEndDate);
                                              }, initialValue: endDate, isDarkMode: $app.calendarState.isDark.value, min: (_w = modalPlugin.config.datePicker) === null || _w === void 0 ? void 0 : _w.min, max: (_x = modalPlugin.config.datePicker) === null || _x === void 0 ? void 0 : _x.max, locale: $app.config.locale.value }), !isFullDayEvent && (jsxRuntime.jsx(TimePicker, { onChange: (newEndTime) => {
                                                  var _a, _b, _c;
                                                  (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.endTime) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newEndTime);
                                                  setEndTime(newEndTime);
                                              }, label: ((_z = (_y = modalPlugin.config.fields) === null || _y === void 0 ? void 0 : _y.endTime) === null || _z === void 0 ? void 0 : _z.label) || '', initialValue: endTime, placement: 'bottom-end', isDarkMode: $app.calendarState.isDark.value, name: ((_1 = (_0 = modalPlugin.config.fields) === null || _0 === void 0 ? void 0 : _0.endTime) === null || _1 === void 0 ? void 0 : _1.name) || 'end-time', is12Hour: modalPlugin.config.has12HourTimeFormat || false }))] })] }), jsxRuntime.jsx(AppCheckbox, { label: 'Full-day event', initialValue: isFullDayEvent, onChange: (isChecked) => setIsFullDayEvent(isChecked) })] })), showRruleFields && (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { className: 'sx__rrule-wrapper', children: [jsxRuntime.jsx(AppSelect, { items: getFrequencies(), initialSelectedItem: getInitialFrequency(modalPlugin), label: ((_3 = (_2 = modalPlugin.config.fields) === null || _2 === void 0 ? void 0 : _2.rruleFrequency) === null || _3 === void 0 ? void 0 : _3.label) ||
                                      'Frequency', onChange: (value) => {
                                      var _a, _b, _c;
                                      (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.rruleFrequency) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                                      setRruleFreq(value);
                                  }, name: ((_5 = (_4 = modalPlugin.config.fields) === null || _4 === void 0 ? void 0 : _4.rruleFrequency) === null || _5 === void 0 ? void 0 : _5.name) || 'rrule', isDarkMode: $app.calendarState.isDark.value }), jsxRuntime.jsx(DatePicker, { initialValue: rruleUntil, onChange: (newDate) => {
                                      var _a, _b, _c;
                                      (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.rruleUntil) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, newDate);
                                      setRruleUntil(newDate);
                                  }, isDarkMode: $app.calendarState.isDark.value, disabled: !rruleFreq, label: ((_7 = (_6 = modalPlugin.config.fields) === null || _6 === void 0 ? void 0 : _6.rruleUntil) === null || _7 === void 0 ? void 0 : _7.label) || 'Until', width: '100%', name: ((_9 = (_8 = modalPlugin.config.fields) === null || _8 === void 0 ? void 0 : _8.rruleUntil) === null || _9 === void 0 ? void 0 : _9.name) || 'until', min: (_10 = modalPlugin.config.datePicker) === null || _10 === void 0 ? void 0 : _10.min, max: (_11 = modalPlugin.config.datePicker) === null || _11 === void 0 ? void 0 : _11.max, locale: $app.config.locale.value })] }) })), showDescription && (jsxRuntime.jsx(Textarea, { initialValue: modalPlugin.formValues.value.description || '', onChange: (value) => {
                          var _a, _b, _c;
                          (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.description) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                          modalPlugin.formValues.value.description = value;
                          validateIfShouldValidate();
                      }, label: ((_13 = (_12 = modalPlugin.config.fields) === null || _12 === void 0 ? void 0 : _12.description) === null || _13 === void 0 ? void 0 : _13.label) || 'Description', name: ((_15 = (_14 = modalPlugin.config.fields) === null || _14 === void 0 ? void 0 : _14.description) === null || _15 === void 0 ? void 0 : _15.name) || 'description', errorMessage: (_16 = modalPlugin.formValidationErrors.description) === null || _16 === void 0 ? void 0 : _16.value }, modalPlugin.formValues.value + 'description')), modalPlugin.config.availablePeople && (jsxRuntime.jsx(AppCombobox, { items: modalPlugin.config.availablePeople, initialSelectedItems: modalPlugin.formValues.value.people, onChange: (value) => {
                          var _a, _b, _c;
                          (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.people) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                          modalPlugin.formValues.value.people = value;
                          validateIfShouldValidate();
                      }, label: ((_18 = (_17 = modalPlugin.config.fields) === null || _17 === void 0 ? void 0 : _17.people) === null || _18 === void 0 ? void 0 : _18.label) || 'People', name: ((_20 = (_19 = modalPlugin.config.fields) === null || _19 === void 0 ? void 0 : _19.people) === null || _20 === void 0 ? void 0 : _20.name) || 'people', isDarkMode: $app.calendarState.isDark.value, errorMessage: (_21 = modalPlugin.formValidationErrors.people) === null || _21 === void 0 ? void 0 : _21.value }, modalPlugin.formValues.value + 'people')), showCalendarField && (jsxRuntime.jsx(AppComboboxSingleValue, { items: getCalendars(), initialSelectedItem: getSelectedCalendarOrUndefined(), label: ((_23 = (_22 = modalPlugin.config.fields) === null || _22 === void 0 ? void 0 : _22.calendarId) === null || _23 === void 0 ? void 0 : _23.label) || 'Calendar', onChange: (value) => {
                          var _a, _b, _c;
                          (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.calendarId) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                          modalPlugin.formValues.value.calendarId = value;
                          validateIfShouldValidate();
                          checkIsInHiddenCalendar();
                      }, name: ((_25 = (_24 = modalPlugin.config.fields) === null || _24 === void 0 ? void 0 : _24.calendarId) === null || _25 === void 0 ? void 0 : _25.name) || 'calendar', isDarkMode: $app.calendarState.isDark.value, errorMessage: (_26 = modalPlugin.formValidationErrors.calendarId) === null || _26 === void 0 ? void 0 : _26.value }, modalPlugin.formValues.value + 'calendar')), showResourceField && (jsxRuntime.jsx(AppComboboxSingleValue, { items: getResourceItems(), initialSelectedItem: getSelectedResourceOrUndefined(), label: ((_28 = (_27 = modalPlugin.config.fields) === null || _27 === void 0 ? void 0 : _27.resourceId) === null || _28 === void 0 ? void 0 : _28.label) || 'Resource', onChange: (value) => {
                          var _a, _b, _c;
                          (_c = (_b = (_a = modalPlugin.config.fields) === null || _a === void 0 ? void 0 : _a.resourceId) === null || _b === void 0 ? void 0 : _b.onChange) === null || _c === void 0 ? void 0 : _c.call(_b, value);
                          modalPlugin.formValues.value.resourceId = value;
                          validateIfShouldValidate();
                      }, name: ((_30 = (_29 = modalPlugin.config.fields) === null || _29 === void 0 ? void 0 : _29.resourceId) === null || _30 === void 0 ? void 0 : _30.name) || 'resource', isDarkMode: $app.calendarState.isDark.value, errorMessage: (_31 = modalPlugin.formValidationErrors.resourceId) === null || _31 === void 0 ? void 0 : _31.value }, modalPlugin.formValues.value + 'resource')), modalPlugin.config.customFields && (jsxRuntime.jsx(jsxRuntime.Fragment, { children: Object.entries(modalPlugin.config.customFields).map(([fieldName, field]) => {
                          var _a, _b, _c, _d, _e;
                          return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [field.value.type === 'text' && (jsxRuntime.jsx(TextField, { id: fieldName, initialValue: modalPlugin.formValues.value[fieldName] || '', onChange: (value) => {
                                          var _a, _b;
                                          (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                          modalPlugin.formValues.value[fieldName] = value;
                                          validateIfShouldValidate();
                                      }, label: field.value.label || '', fieldName: fieldName, errorMessage: (_a = modalPlugin.formValidationErrors[fieldName]) === null || _a === void 0 ? void 0 : _a.value }, field.value)), field.value.type == 'select' && (jsxRuntime.jsx(AppSelect, { items: field.value.items || [], label: field.value.label || '', onChange: (value) => {
                                          var _a, _b;
                                          (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                          modalPlugin.formValues.value[fieldName] = value;
                                          validateIfShouldValidate();
                                      }, initialSelectedItem: ((_b = field.value.items) === null || _b === void 0 ? void 0 : _b.find((item) => {
                                          return (item.value ===
                                              modalPlugin.formValues.value[fieldName]);
                                      })) || undefined, name: fieldName }, field.value)), field.value.type === 'textarea' && (jsxRuntime.jsx(Textarea, { initialValue: modalPlugin.formValues.value[fieldName] || '', onChange: (value) => {
                                          var _a, _b;
                                          (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                          modalPlugin.formValues.value[fieldName] = value;
                                          validateIfShouldValidate();
                                      }, label: field.value.label || '', name: fieldName, errorMessage: (_c = modalPlugin.formValidationErrors[fieldName]) === null || _c === void 0 ? void 0 : _c.value }, field.value)), field.value.type === 'combobox' && (jsxRuntime.jsx(AppComboboxSingleValue, { items: field.value.items || [], label: field.value.label || '', onChange: (value) => {
                                          var _a, _b;
                                          (_b = (_a = modalPlugin.config.customFields[fieldName].value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
                                          modalPlugin.formValues.value[fieldName] = value;
                                          validateIfShouldValidate();
                                      }, initialSelectedItem: ((_d = field.value.items) === null || _d === void 0 ? void 0 : _d.find((item) => {
                                          return (item.value ===
                                              modalPlugin.formValues.value[fieldName]);
                                      })) || undefined, name: fieldName, errorMessage: (_e = modalPlugin.formValidationErrors[fieldName]) === null || _e === void 0 ? void 0 : _e.value }, field.value))] }));
                      }) })), jsxRuntime.jsxs("div", { className: 'sx__form-actions', children: [jsxRuntime.jsx(AppButton, { onClick: saveEvent, additionalClasses: saveButtonClasses.join(' '), children: "Save" }), jsxRuntime.jsx(AppButton, { onClick: cancel, additionalClasses: 'sx__app-button-outlined', children: "Cancel" })] })] }) }));
  }

  function DeleteActions({ $app }) {
      const modalPlugin = $app.config.plugins
          .eventModal;
      return (jsxRuntime.jsxs("div", { children: [jsxRuntime.jsx("h2", { className: "sx__modal-delete-headline", children: "Are you sure you want to delete this event?" }), jsxRuntime.jsxs("div", { className: "sx__modal-delete-actions", children: [jsxRuntime.jsx(AppButton, { additionalClasses: "sx__app-button-outlined", onClick: () => {
                              modalPlugin.modalState.value = 'view';
                          }, children: "Cancel" }), jsxRuntime.jsx(AppButton, { additionalClasses: "sx__app-button-danger", onClick: () => {
                              var _a, _b;
                              const eventId = modalPlugin.calendarEvent.value.id;
                              modalPlugin.eventsService.remove(eventId);
                              modalPlugin.close();
                              (_b = (_a = modalPlugin.config).onDeleteEvent) === null || _b === void 0 ? void 0 : _b.call(_a, eventId);
                          }, children: "Delete" })] })] }));
  }

  function InteractiveEventModal({ $app, }) {
      const [modalId] = hooks.useState(randomStringId$2());
      const { value: calendarEvent } = $app.config.plugins.eventModal.calendarEvent;
      const modalPlugin = $app.config.plugins
          .eventModal;
      const removeEditAddedEvent = () => {
          if (calendarEvent && modalPlugin.modalState.value === 'edit_added')
              modalPlugin.config.eventsService.remove(calendarEvent.id);
      };
      const clickOutsideListener = createClickOutsideListener($app, modalId, () => removeEditAddedEvent());
      const callSetPosition = () => {
          var _a, _b, _c;
          setPosition((_a = $app.elements.calendarWrapper) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect(), (_b = $app.config.plugins.eventModal) === null || _b === void 0 ? void 0 : _b.calendarEventDOMRect.value, ((_c = $app.elements.calendarWrapper) === null || _c === void 0 ? void 0 : _c.querySelector('.sx__interactive-event-modal')).clientHeight, modalPlugin.config.has12HourTimeFormat ? 595 : undefined);
      };
      const scrollListener = () => {
          var _a, _b;
          $app.config.plugins.eventModal.calendarEventDOMRect.value =
              (_b = (_a = $app.config.plugins.eventModal) === null || _a === void 0 ? void 0 : _a.calendarEventElement.value) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
          callSetPosition();
      };
      const escapeKeyDownListener = (e) => {
          setTimeout(() => {
              if (e.key === 'Escape' &&
                  !window
                      .__sx_escapeKeyDownBlocker__) {
                  modalPlugin.close();
                  removeEditAddedEvent();
              }
          });
      };
      hooks.useEffect(() => {
          var _a;
          callSetPosition();
          modalPlugin.isOpen.value = true;
          document.addEventListener('click', clickOutsideListener, true);
          const scrollableAncestors = getScrollableParents(((_a = $app.config.plugins.eventModal) === null || _a === void 0 ? void 0 : _a.calendarEventElement.value) || null);
          scrollableAncestors.forEach((el) => el.addEventListener('scroll', scrollListener));
          document.addEventListener('keydown', escapeKeyDownListener);
          return () => {
              scrollableAncestors.forEach((el) => el.removeEventListener('scroll', scrollListener));
              document.removeEventListener('click', clickOutsideListener, true);
              document.removeEventListener('keydown', escapeKeyDownListener);
              modalPlugin.calendarEventDOMRect.value = null;
              modalPlugin.calendarEventElement.value = null;
              modalPlugin.isOpen.value = false;
          };
      }, []);
      hooks.useEffect(() => {
          callSetPosition();
      }, [modalPlugin.modalState.value]);
      const startDrag = (e) => {
          const modal = document.getElementById(modalId);
          if (modal) {
              const modalRect = modal.getBoundingClientRect();
              const offsetX = e.clientX - modalRect.left;
              const offsetY = e.clientY - modalRect.top;
              const move = (e) => {
                  modal.style.left = e.clientX - offsetX + 'px';
                  modal.style.top = e.clientY - offsetY + 'px';
              };
              const stop = () => {
                  document.removeEventListener('mousemove', move);
                  document.removeEventListener('mouseup', stop);
              };
              document.addEventListener('mousemove', move);
              document.addEventListener('mouseup', stop);
          }
      };
      return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs("div", { id: modalId, "data-state": modalPlugin.modalState.value, className: `sx__interactive-event-modal${modalPlugin.isOpen.value ? ' is-open' : ''}`, children: [modalPlugin.config.movable && (jsxRuntime.jsx("div", { onMouseDown: startDrag, className: 'sx__interactive-event-modal__move-bar' })), calendarEvent && (jsxRuntime.jsxs(preact.Fragment, { children: [modalPlugin.modalState.value === 'view' && (jsxRuntime.jsx(EventDisplay, { "$app": $app, calendarEvent: calendarEvent })), ['edit', 'add', 'edit_added'].includes(modalPlugin.modalState.value) && (jsxRuntime.jsx(EventForm, { "$app": $app, removeEditAddedEvent: removeEditAddedEvent })), modalPlugin.modalState.value === 'delete' && (jsxRuntime.jsx(DeleteActions, { "$app": $app }))] }))] }) }));
  }

  const SX_INTERNAL_CALENDAR = '__SX-INTERNAL__';

  /* eslint-disable max-lines */
  const validateConfig = (config) => {
      const fields = config.fields;
      if ((fields === null || fields === void 0 ? void 0 : fields.startDate) ||
          (fields === null || fields === void 0 ? void 0 : fields.endDate) ||
          (fields === null || fields === void 0 ? void 0 : fields.startTime) ||
          (fields === null || fields === void 0 ? void 0 : fields.endTime)) {
          if (!fields.startDate ||
              !fields.endDate ||
              !fields.startTime ||
              !fields.endTime) {
              throw new Error('[Schedule-X error] startDate, startTime, endDate, and endTime must all be configured, if one of them is configured');
          }
      }
  };
  const createInteractiveEventModal = (config) => {
      validateConfig(config);
      const calendarEvent = signals.signal(null);
      const calendarEventDOMRect = signals.signal(null);
      const formValues = signals.signal({
          start: toDateTimeString(new Date()),
          end: toDateTimeString(new Date()),
          title: undefined,
          description: undefined,
          location: undefined,
          people: [],
          calendarId: undefined,
      });
      const modalState = signals.signal('view');
      const isEditingRecurringEvent = signals.signal(false);
      let _$app;
      const _setCalendarEventInViewMode = (event, eventTargetDOMRect) => {
          var _a;
          if (config.canOpenModal && !config.canOpenModal(event))
              return;
          const clickedOnEventInEditAddedMode = modalState.value === 'edit_added' && ((_a = calendarEvent.value) === null || _a === void 0 ? void 0 : _a.id);
          if (clickedOnEventInEditAddedMode) {
              config.eventsService.remove(calendarEvent.value.id);
          }
          modalState.value = 'view';
          calendarEvent.value = event;
          calendarEventDOMRect.value = eventTargetDOMRect;
      };
      const calendarEventElement = signals.signal(null);
      const _setCalendarEventInEditAddedMode = (event, eventTargetDOMRect) => {
          var _a;
          const eventElement = (_a = _$app === null || _$app === void 0 ? void 0 : _$app.elements.calendarWrapper) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-event-id="${event.id}"]`);
          if (eventElement instanceof HTMLElement) {
              calendarEventElement.value = eventElement;
          }
          modalState.value = 'edit_added';
          calendarEvent.value = event;
          calendarEventDOMRect.value = eventTargetDOMRect;
      };
      function clickToCreate(start, otherEventProperties = {}) {
          const eventId = otherEventProperties.id || randomStringId$2();
          const observer = new MutationObserver((mutations) => {
              // wait for an element with data-event-id="eventId" to be added to the DOM
              mutations.forEach((mutation) => {
                  const target = mutation.target;
                  const eventElement = target.dataset.eventId === String(eventId)
                      ? target
                      : target.querySelector(`[data-event-id="${eventId}"]`);
                  const eventInternal = _$app === null || _$app === void 0 ? void 0 : _$app.calendarEvents.list.value.find((event) => event.id === eventId);
                  if (eventElement && eventInternal) {
                      observer.disconnect();
                      const rect = eventElement.getBoundingClientRect();
                      _setCalendarEventInEditAddedMode(eventInternal, rect);
                      formValues.value = {
                          start: eventInternal.start,
                          end: eventInternal.end,
                          title: eventInternal.title,
                          description: eventInternal.description,
                          calendarId: eventInternal.calendarId !== SX_INTERNAL_CALENDAR
                              ? eventInternal.calendarId
                              : undefined,
                          people: eventInternal.people,
                      };
                      modalState.value = 'edit_added';
                  }
              });
          });
          if (_$app) {
              observer.observe(_$app.elements.calendarWrapper || document, {
                  childList: true,
                  subtree: true,
              });
          }
          isEditingRecurringEvent.value = false;
          const _start = start;
          const end = /^\w{4}-\w{2}-\w{2}$/.test(_start)
              ? _start
              : addMinutes(_start, 60);
          const newEvent = {
              id: eventId,
              start: _start,
              end: end,
              calendarId: SX_INTERNAL_CALENDAR,
              _options: {
                  additionalClasses: [ADDED_EVENT_CLASS_NAME],
              },
              ...otherEventProperties,
          };
          if (_$app.calendarEvents.filterPredicate.value) {
              const isInHiddenCalendar = [newEvent].filter(_$app.calendarEvents.filterPredicate.value).length === 0;
              if (isInHiddenCalendar)
                  newEvent.calendarId = SX_INTERNAL_CALENDAR;
          }
          config.eventsService.add(newEvent);
      }
      const allFieldsWithValidators = [];
      Object.entries({
          ...config.fields,
      }).forEach(([fieldName, field]) => {
          if ('validator' in field && field.validator) {
              allFieldsWithValidators.push(fieldName);
          }
      });
      Object.entries({
          ...config.customFields,
      }).forEach(([fieldName, field]) => {
          if ('validator' in field.value && field.value.validator) {
              allFieldsWithValidators.push(fieldName);
          }
      });
      return definePlugin('eventModal', {
          config,
          calendarEventElement: calendarEventElement,
          name: 'eventModal',
          beforeRender($app) {
              _$app = $app;
          },
          calendarEvent,
          calendarEventDOMRect,
          ComponentFn: InteractiveEventModal,
          setCalendarEvent: _setCalendarEventInViewMode,
          formValues,
          formValidationErrors: allFieldsWithValidators.reduce((acc, fieldName) => {
              acc[fieldName] = signals.signal(undefined);
              return acc;
          }, {}),
          modalState,
          eventsService: config.eventsService,
          isEditingRecurringEvent,
          openEventCreationModal: (id, start, otherEventProperties = {}) => {
              isEditingRecurringEvent.value = false;
              modalState.value = 'add';
              const _start = start || toDateTimeString(new Date());
              const newEvent = {
                  id: id,
                  start: _start,
                  end: addMinutes(_start, 60),
                  title: '',
                  description: '',
                  people: [],
                  ...otherEventProperties,
              };
              calendarEvent.value = newEvent;
              formValues.value = {
                  start: newEvent.start,
                  end: newEvent.end,
                  title: newEvent.title,
                  description: newEvent.description,
                  people: newEvent.people,
              };
              calendarEventDOMRect.value = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0,
              };
          },
          clickToCreate(start, otherEventProperties = {}) {
              clickToCreate(start, otherEventProperties);
          },
          close: () => {
              calendarEvent.value = null;
              calendarEventDOMRect.value = null;
          },
          isOpen: signals.signal(false),
      });
  };

  exports.createInputField = createInputField;
  exports.createInteractiveEventModal = createInteractiveEventModal;

}));
